<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2013.6-2013.12俩项目的一些反思和总结</title>
    <url>/2014/2013.6-2013.12%E4%BF%A9%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D%E5%92%8C%E6%80%BB%E7%BB%93/readme/</url>
    <content><![CDATA[<p>从2013.6月中旬到2013.12月，连续参与设计和开发了两个产品（一个是<a href="https://itunes.apple.com/cn/app/zhang-pai/id696406058?mt=8" target="_blank" rel="noopener external nofollow noreferrer">掌拍</a>，另一个是<a href="https://itunes.apple.com/us/app/wang-qiu-quan/id747600291?ls=1&mt=8" target="_blank" rel="noopener external nofollow noreferrer">网球圈</a>），并独立完成了这两个产品的 iOS 客户端开发，期间可谓获益良多，一番反省总结归纳，得益主要在『沟通』『产品设计』『技术』这三方面。</p>
<h2 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h2><p>如何才能有效地沟通呢？</p>
<ol>
<li><p>就事论事，理性讨论，拒绝个人情绪，特别是不良情绪。</p>
</li>
<li><p>以『发现问题，解决问题』为沟通目的。</p>
</li>
<li><p>坚决把讨论的问题限定在指定范围内，拒绝越界、跑题！</p>
</li>
<li><p>准备充分，准备好：『问题』、『论据』、『解决方案』（至少得清楚自己想讨论的是什么问题）。</p>
</li>
</ol>
<p>以上就是我在参与第一个产品开发时，和负责人『吵架』n 次，失败 n 次后得到的经验和教训。此人是搞营销运维的，口头能力甚强，好几次和他讨论问题的时候，就被他用『偷换概念』+『跑题』这两招击败o(╯□╰)o；然后有几次是被他的市场经验打败（这招『扬长避短』甚是好用的，→_→）。。。</p>
<p>而最重要的教训就是发现一旦带着个人情绪进行讨论的时候，很容易擦枪走火，问题不但没解决，还让彼此都不爽。影响工作~~囧rz</p>
<h2 id="产品设计"><a href="#产品设计" class="headerlink" title="产品设计"></a>产品设计</h2><p>产品设计方面的感悟主要是：</p>
<ol>
<li><p>从『问题』本身出发（由于想解决一个这么样的问题，所以才做了这么样的一个产品）。</p>
</li>
<li><p>做你需要的而不是做你想要的（focus on what you need rather than what you want）。</p>
</li>
<li><p><code>为产品设计一套完整的（最好是完善甚至是完美的）『游戏规则』。</code>如果规则模糊不清晰，一来会导致业务流程上产生 bug，二来不利于开发人员的开发。</p>
<p> PS：<code>但是规则对用户而言应该是是友善的、简单可行的。</code></p>
</li>
<li><p>先确定业务，再确定功能，继而确定界面，最后根据业务、功能、界面UI等需求确定技术方案。</p>
</li>
<li><p><code>『和谐』</code>。产品（主要指客户端）应该有统一的风格，一是 UI 的风格一致，如 颜色、色调、背景图、指示器、文字字体等各种元素应该有一致的风格；二是交互方式的风格一致，如统一使用一种方式（点击或者滑动）来切换视图，各种交互语言（UI 中的文本语言以及提示用户操作、网络超时、任务失败等各种提示语）的风格要一致。</p>
</li>
<li><p><code>『理所当然』</code>。让用户使用你的产品的时候会觉得『理所当然，就该如此』，像在网速快的时候，一些交互操作应该可以考虑不提示用户交互的进度吧？</p>
</li>
</ol>
<a id="more"></a>

<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>技术方面的收获主要是：</p>
<ol>
<li><p>更清楚了解 MVC 架构。</p>
</li>
<li><p>对 CoreData 的设计和使用的认知有了质的提升，特别是对 CoreData 的 Relationships（关系）、<a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/CoreData/Articles/cdMOM.html" target="_blank" rel="noopener external nofollow noreferrer">Entity Inheritance</a>（实体继承）、Multithreading（多线程）这三方面有了深入的认识。</p>
</li>
<li><p>模块化设计的意识有了长进，如网球圈客户端设计时，有意识地设计一个单独模块管理定位。</p>
</li>
<li><p>界面中需要经常更新的一些元素不要写或写死在 xib/storyboard 中，尽量使用 code 来控制，以及根据返回的数据逐步显示对应的界面元素。</p>
</li>
</ol>
<h2 id="其它反思"><a href="#其它反思" class="headerlink" title="其它反思"></a>其它反思</h2><ol>
<li><p>以史为鉴，从别人的错误中学习，防止跌入同一个陷阱。</p>
<p> 像在做掌拍这个产品的时候，跟电信的领导有过接触，发现他们会由于知识的盲点而造成无知，继而提出乱七八糟的想法和需求。不过，想来，自己也常由于知识的盲点而造成无知，所以保持开阔视野，吸收学习新知识才是王道啊。</p>
</li>
<li><p><code>保持高工作效率的最好方法是：保持大脑和身体的活力性！</code></p>
<p> <code>a. 每天开始工作前，定制好一天的工作目标和工作量。</code></p>
<p> <code>b. 养成良好的工作规律，如 code 两小时，break 半小时，周而复始。</code></p>
<p> <code>c. 拒绝非必要性的加班，坚拒长时间性的加班。</code></p>
</li>
<li><p>提升产品的价值需要整个团队的团结协助和坦诚，特别是队员们的坦诚：因为队员们在开发该产品的过程<br>中产生的有关该产品的感觉是很有讨论价值的，也特别有助于产品的改进。得知以及讨论他们的感觉认知后，才可<br>让他们认可产品（因为产品的设计从此也有了他们的身影所在），而只有队员们认可了产品，队员们才会有动力和激情做到极致。</p>
</li>
</ol>
<p/>
<p align="right">2013-12-03于华工信元南区</p>]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>人文</tag>
      </tags>
  </entry>
  <entry>
    <title>Compile WebRTC for iOS on Mac OS X</title>
    <url>/2014/Compile%20WebRTC%20for%20iOS%20on%20Mac%20OS%20X/readme/</url>
    <content><![CDATA[<h2 id="我的编译环境："><a href="#我的编译环境：" class="headerlink" title="我的编译环境："></a>我的编译环境：</h2><p>Mac OS X 10.9 + Command Line Tools（XCode 4.6.3）</p>
<h2 id="编译步骤："><a href="#编译步骤：" class="headerlink" title="编译步骤："></a>编译步骤：</h2><h3 id="一、安装依赖工具"><a href="#一、安装依赖工具" class="headerlink" title="一、安装依赖工具"></a>一、安装依赖工具</h3><ol>
<li><p>安装 git、svn（不过，一般Xcode自带安装好了）</p>
</li>
<li><p>安装depot_tools  </p>
<p> a. 在指定目录下执行（我选择在 <code>/Developer</code> ）：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">svn co http://src.chromium.org/svn/trunk/tools/depot_tools</span><br></pre></td></tr></table></figure>

<p> b. 把depot_tools 添加到 PATH（环境变量）中：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /private/etc/paths</span><br></pre></td></tr></table></figure>

<p> 然后往打开的文件添加 <code>depot_tools</code> 的路径（我添加的是：`/Developer/depot_tools ）</p>
</li>
</ol>
<h3 id="二、下载源代码以及生成项目文件"><a href="#二、下载源代码以及生成项目文件" class="headerlink" title="二、下载源代码以及生成项目文件"></a>二、下载源代码以及生成项目文件</h3><p>1.下载源代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir webrtc_src</span><br><span class="line">cd webrtc_src</span><br><span class="line">gclient config http://webrtc.googlecode.com/svn/trunk</span><br><span class="line">giclaient sync —force	//如果中途中断了，再次执行该命令</span><br></pre></td></tr></table></figure>

<p>2.生成 iOS 项目文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd trunk</span><br><span class="line">export GYP_GENERATORS="xcode"	//设置环境配置</span><br><span class="line">./build/gyp_chromium --depth=.  -DOS=ios -Dtarget_arch=arm -Dinclude_tests=0 -Denable_protobuf=0 all.gyp</span><br></pre></td></tr></table></figure>

<p>（其它生成例子：<code>./build/gyp_chromium --depth=.  -DOS=ios -Dtarget_arch=arm -Dinclude_tests=0 -Denable_protobuf=0 -Denable_video=1 webrtc/webrtc.gyp</code>）</p>
<a id="more"></a>

<h2 id="其它知识："><a href="#其它知识：" class="headerlink" title="其它知识："></a>其它知识：</h2><ol>
<li><p>关于 gclient </p>
<p> <a href="http://blog.csdn.net/doon/article/details/9287693" target="_blank" rel="noopener external nofollow noreferrer">http://blog.csdn.net/doon/article/details/9287693</a>  </p>
</li>
<li><p>关于Configuring gyp</p>
<p> <a href="https://code.google.com/p/chromium/wiki/LinuxBuildInstructions" target="_blank" rel="noopener external nofollow noreferrer">https://code.google.com/p/chromium/wiki/LinuxBuildInstructions</a></p>
<blockquote>
<p>Configuring gyp</p>
<p>See Configuring the Build for details; most often you’ll be changing the GYP_DEFINES options, which is discussed here.</p>
<p>gyp supports a minimal amount of build configuration via the -D flag.</p>
<p><code>build/gyp_chromium -Dflag1=value1 -Dflag2=value2</code></p>
<p>You can store these in the GYP_DEFINES environment variable, separating flags with spaces, as in:</p>
<p><code>export GYP_DEFINES=&quot;flag1=value1 flag2=value2&quot;</code></p>
</blockquote>
</li>
</ol>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><a href="http://www.cnblogs.com/ProbeStar/p/3411510.html" target="_blank" rel="noopener external nofollow noreferrer">http://www.cnblogs.com/ProbeStar/p/3411510.html</a></li>
<li><a href="https://bitbucket.org/dashboard/overview" target="_blank" rel="noopener external nofollow noreferrer">https://bitbucket.org/dashboard/overview</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CoreData: Entity Inheritance</title>
    <url>/2014/CoreData%EF%BC%9AEntity%20Inheritance/readme/</url>
    <content><![CDATA[<p>在为『掌拍』iOS 客户端设计数据库的时候，大幅度使用了 CoreData 中的『Entity Inheritance』这个特性，由此很好地解决了多个实体有共同 property 的问题，而特别借助实体类化（由实体生成对应的类）后的动态性，解决了数据动态传递的问题。这之后，对『Entity Inheritance』算是有了经验，但是还没有归纳总结，现在总结如下：</p>
<a id="more"></a>

<p>在 CoreData 中，『实体的继承』（entity inheritance）类似于『类的继承』（class inheritance），如果你有若干个相似的实体，就可以抽离出它们共同的 property (注意：property 包括了Attributes 和Relationships 两方面) 作为一个『父实体』，然后继承该『父实体』，而不是在让多个实体去重复描述共同的property，导致性能的下降。例如，有如下两个实体：</p>
<p><img src="/2014/CoreData%EF%BC%9AEntity%20Inheritance/readme/entity_teacher_student.png" alt=""></p>
<p>如图，Teacher实体和 Student 实体具有相同的attribute，我们可以抽离出来作为一个父实体，再让它们继承父实体，结果如下：</p>
<p><img src="/2014/CoreData%EF%BC%9AEntity%20Inheritance/readme/entity_person_teacher_student.png" alt=""></p>
<p>这样 Teacher 实体和 Student 实体都继承了 name 和 sex 这两个attribute。</p>
<p>那么该如何设置父实体呢？</p>
<ol>
<li><p>使用Xcode的可视化建模工具来创建：</p>
<p> <img src="/2014/CoreData%EF%BC%9AEntity%20Inheritance/readme/xcode_entity_inheritance.png" alt=""></p>
</li>
<li><p>使用 code 来创建。但这需要自顶向下来执行，即一个实体不能直接设置父实体，而只能让父实体去设置子实体。具体操作是：把 Teacher 实体 和 Student 实体添加到子实体数组中，然后让目标父实体 Person 调用 <a href="https://developer.apple.com/library/ios/documentation/cocoa/Reference/CoreDataFramework/Classes/NSEntityDescription_Class/NSEntityDescription.html#jumpTo_25" target="_blank" rel="noopener external nofollow noreferrer"><code>setSubentities:</code></a> 来进行设置。</p>
</li>
</ol>
<hr>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/CoreData/Articles/cdMOM.html" target="_blank" rel="noopener external nofollow noreferrer">https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/CoreData/Articles/cdMOM.html</a></li>
<li><a href="http://www.objc.io/issue-4/core-data-models-and-model-objects.html" target="_blank" rel="noopener external nofollow noreferrer">http://www.objc.io/issue-4/core-data-models-and-model-objects.html</a></li>
<li><a href="http://blog.csdn.net/focusjava/article/details/9949499" target="_blank" rel="noopener external nofollow noreferrer">http://blog.csdn.net/focusjava/article/details/9949499</a></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C: class method VS static method</title>
    <url>/2014/Objective-C%EF%BC%9AClass%20Method%20vs%20Static%20Method/readme/</url>
    <content><![CDATA[<p>在比较之前，你应该了解以下知识：</p>
<ol>
<li><a href="http://blog.csdn.net/likendsl/article/details/7566031" target="_blank" rel="noopener external nofollow noreferrer">Objcetive-C的函数调用机制</a></li>
<li><a href="http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/" target="_blank" rel="noopener external nofollow noreferrer">Objective-C的对象模型</a></li>
<li><a href="http://blog.leezhong.com/ios/2013/08/03/dynamic-tips-and-tricks-with-objective-c.html" target="_blank" rel="noopener external nofollow noreferrer">Objective-C的动态特性</a></li>
</ol>
<hr>
<p>在阅读完毕，了解知道Objective-C 中的 <em>Message、Object、Class、MetaClass、Method（SEL-IMP)</em> 的重要概念后，现在开始比较！</p>
<p>下面是来自 WIKI 的对 static method 的<a href="http://en.wikipedia.org/wiki/Method_(computer_programming)#Static_methods" target="_blank" rel="noopener external nofollow noreferrer">定义</a>：</p>
<blockquote>
<p>Static methods neither require an instance of the class nor can they implicitly access the data (or this, self, Me, etc.) of such an instance. A static method is distinguished in some programming languages with the static keyword placed somewhere in the method’s signature.</p>
</blockquote>
<blockquote>
<p>In statically typed languages such as Java, static methods are called “static” because they are resolved statically (i.e. at compile time) based on the class they are called on and not dynamically as in the case with instance methods which are resolved polymorphically based on the runtime type of the object. Therefore, static methods cannot be overridden.</p>
</blockquote>
<p>从定义可以看出，Objective-C 的 class method 根本不是 static method，而实际上，<strong>Objective-C 也不存在 static method！</strong>（尽管 class method 因为用法而看似 static method，但它们是有本质的差别的。）</p>
<p>那么它们的区别是？（出于好奇心，我们假设下 Objective-C 中有 static method → →）</p>
<a id="more"></a>

<p>从定义可知，<strong>static method 是不可继承(inherit)和覆盖(override)的；</strong></p>
<p>但是，<strong>class method 是可以继承(inherit)和覆盖(override)的。</strong></p>
<p>请看下面的例子：  </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">id</span>)newAnimal;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line">+ (<span class="keyword">id</span>)newAnimal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"now new an animal..."</span>);</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dock</span> : <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dock</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Chicken</span> : <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Chicken</span></span></span><br><span class="line">+ (<span class="keyword">id</span>)newAnimal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> animal = [<span class="keyword">super</span> newAnimal];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"now new a Chicken..."</span>);</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Test</span></span><br><span class="line">Dock *dock = [Dock newAnimal];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"---------------分割线----------------"</span>);</span><br><span class="line">Chicken *chicken = [Chicken newAnimal];</span><br><span class="line">... etc ...</span><br></pre></td></tr></table></figure>

<p>运行结果是：  </p>
<pre><code>now new an animal...
---------------分割线----------------
now new an animal...
now new a Chicken...</code></pre><p>由结果可以验证了class method 是可以继承(inherit)和覆盖(override)的。</p>
<p>那么为什么 class method 是可以继承和覆盖？因为：</p>
<p>在 Objective-C 中，class 其实也是一个对象，只不过它是一个特别的对象——由 MetaClass 生成的一个实例（an instance of metaclass），而 object 则是由 Class 生成的一个实例。（你可以像发送消息给 object 那样发送消息给 class 以调用对应的 class method，如上面的<code>[Chicken newAnimal]</code>，发送一条消息给 <code>Chicken</code> 类以调用 <code>newAnimal</code> 这个class method。）</p>
<p>而 MetaClass 则是 Objective-C 中最基本的类。Object、Class、MetaClass 三者的关系如下图所示：（该图片来自<a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" target="_blank" rel="noopener external nofollow noreferrer">这里</a>）</p>
<p><img src="/2014/Objective-C%EF%BC%9AClass%20Method%20vs%20Static%20Method/readme/class_diagram.png" alt="class_diagram"></p>
<p>所以，<strong>class method 其实就是 MetaClass 的 instance method。</strong>这就是它的本质，也是可以继承和覆盖的原因。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><a href="http://programmers.stackexchange.com/questions/191856/what-is-a-static-method-compared-to-instance-class-private-public-methods" target="_blank" rel="noopener external nofollow noreferrer">http://programmers.stackexchange.com/questions/191856/what-is-a-static-method-compared-to-instance-class-private-public-methods</a></li>
<li><a href="http://stackoverflow.com/questions/15965865/static-method-which-isnt-class-2.method-in-objective-c" target="_blank" rel="noopener">http://stackoverflow.com/questions/15965865/static-method-which-isnt-class-2.method-in-objective-c</a></li>
<li><a href="http://stackoverflow.com/questions/8089186/whats-the-difference-between-class-method-and-static-method" target="_blank" rel="noopener">http://stackoverflow.com/questions/8089186/whats-the-difference-between-class-method-and-static-method</a>  </li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>2014</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>svn2git总结</title>
    <url>/2016/svn2git%E6%80%BB%E7%BB%93/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要总结了<code>svn</code>迁移到<code>git</code>的步骤。</p>
<a id="more"></a>

<h2 id="1-下载迁移工具subgit"><a href="#1-下载迁移工具subgit" class="headerlink" title="1. 下载迁移工具subgit"></a>1. 下载迁移工具<a href="https://subgit.com/" target="_blank" rel="noopener external nofollow noreferrer">subgit</a></h2><p><code>subgit</code>是一个基于java开发的svn2git商业迁移工具，夸平台，其<code>import功能</code>（一次性把代码从<code>svn</code>迁移到<code>git</code>）是免费的，其他功能（主要是各种<code>mirror</code>功能）则是收费的。</p>
<h2 id="2-迁移前的准备工作"><a href="#2-迁移前的准备工作" class="headerlink" title="2. 迁移前的准备工作"></a>2. 迁移前的准备工作</h2><p>由于<code>svn</code>用户格式（只有用户名）与<code>git</code>用户格式（由用户名和用户邮箱组成）是不一样的，需要创建一个用户映射文件<code>authors.txt</code>，以在迁移记录时进行转换。<code>authors.txt</code>的内容格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">york &#x3D; york &lt;york@example.com&gt;</span><br><span class="line">kiii &#x3D; kitty &lt;kitty@example.com&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如何快速获得<code>svn</code>仓库里曾经提交过记录的的用户呢？可通过以下命令行获得：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd path/to/svn_repo</span><br><span class="line">svn log --quiet | grep -E "r[0-9]+ \| .+ \|" | cut -d'|' -f2 | sed 's/ //g' | sort | uniq</span><br></pre></td></tr></table></figure>

<p>或者直接从远程仓库获得：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">svn <span class="built_in">log</span> --quiet http://path/to/root/of/project | grep -E <span class="string">"r[0-9]+ \| .+ \|"</span> | cut -d<span class="string">'|'</span> -f2 | sed <span class="string">'s/ //g'</span> | sort | uniq</span></span><br></pre></td></tr></table></figure>

</blockquote>
<h2 id="3-开始迁移"><a href="#3-开始迁移" class="headerlink" title="3. 开始迁移"></a>3. 开始迁移</h2><ol>
<li><p>使用subgit的import功能，一次性把代码从svn迁移到git</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd svn2git_workspace</span><br><span class="line">path/to/subgit-3.2.2/bin/subgit import --non-interactive --default-domain YOUR_DOMAIN --authors-file path/to/authors.txt --trunk trunk --tags tags --branches branches --username SVN_USERNAME --password SVN_PASSWORD --svn-url http://svn.example.com/path/to/repo repo.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果迁移过程中遇到错误导致中断，执行 <code>subgit import repo.git</code>进行恢复</p>
</blockquote>
</li>
<li><p>克隆一个裸库，去掉无用的svn信息</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --bare repo.git repo-clone.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>推送代码到git远程仓库</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd repo-clone.git</span><br><span class="line">git remote add gitlab http://gitlab.example.com/path/to/repo.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>推送需要的分支到远程参考</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//推送所有本地分支到远程仓库</span><br><span class="line">git push gitlab --all </span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line">//推送指定分支</span><br><span class="line">git push gitlab master:master</span><br><span class="line">git push gitlab v1.3.0:develop</span><br></pre></td></tr></table></figure>
</li>
<li><p>推送所有本地tag到远程仓库</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push gitlab --tags</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>2016</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>ATS 自动开启关闭</title>
    <url>/2017/ATS%20%E8%87%AA%E5%8A%A8%E5%BC%80%E5%90%AF%E5%85%B3%E9%97%AD/readme/</url>
    <content><![CDATA[<p>由于项目的正式网络环境的 host 是走域名，能支持 https ，测试网络环境的 host 是走 IP ，无法支持 https ，导致在做 ATS 支持的时候，遇到一个问题：在 debug 过程需要切换网络环境的时候，也需要手动去开启或者关闭 ATS 。为了节省这些时间，写了一个脚本去解决这个问题，让 ATS 根据网络环境的值自动去开启或者关闭。下面将会列出具体步骤。</p>
<a id="more"></a>

<p>1.在 [<code>Your Target</code>-Build Settings -Preprocessor Macros] 添加你的环境宏变量 <code>NETWORK_FOR_PRODUCTION</code> ，如下图：</p>
<p><img src="/2017/ATS%20%E8%87%AA%E5%8A%A8%E5%BC%80%E5%90%AF%E5%85%B3%E9%97%AD/readme/Preprocessor_Macros_Image.png" alt="Preprocessor_Macros_Image.png"></p>
<p>2.在项目的 <code>Info.plist</code> 文件中添加 <code>NSAppTransportSecurity</code> ，类型为字典；然后在字典中添加一个 <code>NSAllowsArbitraryLoads</code> ，类型为布尔值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAllowsArbitraryLoads<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于配置的坑<br>在 iOS 10下，多了 <code>NSAllowsArbitraryLoadsForMedia</code> 和 <code>NSAllowsArbitraryLoadsInWebContent</code> 两个选项。<br>当这2个选项与 <code>NSAllowsArbitraryLoads</code> 选项同时存在时，在 iOS 10 下，会优先看 <code>NSAllowsArbitraryLoadsForMedia</code> 和 <code>NSAllowsArbitraryLoadsInWebContent</code> 的配置，而忽略掉  <code>NSAllowsArbitraryLoads</code>。<br>基于以上规则，遇到的坑是：我设置了 <code>NSAllowsArbitraryLoadsInWebContent</code> 为 <code>true</code> （允许浏览器加载http网页），设置了 <code>NSAllowsArbitraryLoads</code> 为 <code>false</code> （关闭ATS），在 iOS 10 下，运行APP，ATS 实际上并没有被关闭，因为 iOS 10 优先看了 <code>NSAllowsArbitraryLoadsInWebContent</code> 的配置，认为 ATS 是开启的， 而 <code>NSAllowsArbitraryLoads</code> 的配置是直接被忽略了。</p>
</blockquote>
<p>3.在 [<code>Your Target</code>-Build Phases-Run Script] 添加以下脚本代码即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NETWORK_FOR_PRODUCTION=`echo $&#123;GCC_PREPROCESSOR_DEFINITIONS&#125; | awk '&#123;print $4&#125;'  | awk -F'[=]' '&#123;print $2&#125;'`</span><br><span class="line"></span><br><span class="line">infoplist="$BUILT_PRODUCTS_DIR/$INFOPLIST_PATH"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更改plist文件的ATS配置</span></span><br><span class="line">if [[ $&#123;NETWORK_FOR_PRODUCTION&#125; == 1 ]]; then</span><br><span class="line">    echo "打开ATS"</span><br><span class="line">    /usr/libexec/PlistBuddy -c "Set :NSAppTransportSecurity:NSAllowsArbitraryLoads false" $&#123;infoplist&#125;</span><br><span class="line">else</span><br><span class="line">    echo "关闭ATS"</span><br><span class="line">    /usr/libexec/PlistBuddy -c "Set :NSAppTransportSecurity:NSAllowsArbitraryLoads true" $&#123;infoplist&#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>其中<code>Run Script</code>的配置如下图：</p>
<p><img src="/2017/ATS%20%E8%87%AA%E5%8A%A8%E5%BC%80%E5%90%AF%E5%85%B3%E9%97%AD/readme/Run_Script_Config_Image.png" alt="Run_Script_Config_Image.png"></p>
<blockquote>
<p>关键脚本代码详解：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NETWORK_FOR_PRODUCTION=`echo $&#123;GCC_PREPROCESSOR_DEFINITIONS&#125; | awk '&#123;print $4&#125;'  | awk -F'[=]' '&#123;print $2&#125;'`</span><br></pre></td></tr></table></figure>
<p>此句代码是通过awk解析获取 <code>NETWORK_FOR_PRODUCTION</code> 的具体值：0或者1<br>PS：如果你需要根据其他变量来设置 ATS ，则需要自己调整上述语句，获取你指定的变量的值。</p>
</blockquote>
<p>4.如常运行调试代码即可~enjoy😄</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>教程</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift的字面量类型（Literal Type）和字面量协议（Literal Protocol）</title>
    <url>/2017/Swift%E7%9A%84%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B%EF%BC%88Literal%20Type%EF%BC%89%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E5%8D%8F%E8%AE%AE%EF%BC%88Literal%20Protocol%EF%BC%89/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你自定义了一个数据类型后，是否希望像<code>var num: Int = 10</code>这样通过一个字面量初始化一个类型的实例呢？是的话，请看下文详细介绍。</p>
<a id="more"></a>

<h2 id="一、字面量类型（Literal-Type）"><a href="#一、字面量类型（Literal-Type）" class="headerlink" title="一、字面量类型（Literal Type）"></a>一、字面量类型（Literal Type）</h2><p>在介绍字面量类型前，我们先认识下字面量的概念。</p>
<p><strong>所谓字面量，是指一段能表示特定类型的值（如数值、布尔值、字符串）的源码表达式（it is the source code representation of a fixed value）</strong>。比如下面例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> flag: <span class="type">Bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> str: <span class="type">String</span> = <span class="string">"hello"</span></span><br></pre></td></tr></table></figure>

<p>例子中的<code>10</code>、<code>true</code>、<code>hello</code>都是字面量。</p>
<p>那什么是字面量类型呢？</p>
<p><strong>字面量类型就是支持通过字面量进行实例初始化的数据类型</strong>，如例子中的<code>Int</code>、<code>Bool</code>、<code>String</code>类型。</p>
<p>在Swift中，其的字面量类型有：</p>
<ul>
<li>所有的数值类型: Int、Double、Float以及其的相关类型（如UInt、Int16、Int32等）</li>
<li>布尔值类型：Bool</li>
<li>字符串类型：String</li>
<li>组合类型：Array、Dictionary、Set</li>
<li>空类型：Nil</li>
</ul>
<h2 id="二、字面量协议（Literal-Protocol）"><a href="#二、字面量协议（Literal-Protocol）" class="headerlink" title="二、字面量协议（Literal Protocol）"></a>二、字面量协议（Literal Protocol）</h2><p>Swift是如何让上述的数据类型具有字面量初始化的能力呢？</p>
<p><strong>答案是：实现指定的字面量协议。</strong></p>
<p>所以，如果我们希望自定义的数据类型也能通过字面量进行初始化，只要实现对应的字面量协议即可。</p>
<p>Swift中的字面量协议主要有以下几个：</p>
<ul>
<li><code>ExpressibleByNilLiteral</code> // nil字面量协议</li>
<li><code>ExpressibleByIntegerLiteral</code> // 整数字面量协议</li>
<li><code>ExpressibleByFloatLiteral</code> // 浮点数字面量协议</li>
<li><code>ExpressibleByBooleanLiteral</code> // 布尔值字面量协议</li>
<li><code>ExpressibleByStringLiteral</code> // 字符串字面量协议</li>
<li><code>ExpressibleByArrayLiteral</code> // 数组字面量协议</li>
<li><code>ExpressibleByDictionaryLiteral</code> // 字典字面量协议</li>
</ul>
<p>其中， <code>ExpressibleByStringLiteral</code> 字符串字面量协议相对复杂一点，该协议还依赖于以下2个协议（也就是说，实现<code>ExpressibleByStringLiteral</code>时，还需要实现下面2个协议）:</p>
<ul>
<li><code>ExpressibleByUnicodeScalarLiteral</code></li>
<li><code>ExpressibleByExtendedGraphemeClusterLiteral</code></li>
</ul>
<blockquote>
<p>在 Swift3.0 之前，上述的字面量协议的名称对应如下：</p>
<ul>
<li><code>NilLiteralConvertible</code></li>
<li><code>IntegerLiteralConvertible</code></li>
<li><code>FloatLiteralConvertible</code></li>
<li><code>BooleanLiteralConvertible</code></li>
<li><code>StringLiteralConvertible</code></li>
<li><code>ArrayLiteralConvertible</code></li>
<li><code>DictionaryLiteralConvertible</code></li>
</ul>
</blockquote>
<h2 id="三、字面量协议例子（Literal-Protocol-Example）"><a href="#三、字面量协议例子（Literal-Protocol-Example）" class="headerlink" title="三、字面量协议例子（Literal Protocol Example）"></a>三、字面量协议例子（Literal Protocol Example）</h2><p>下面将会通过具体例子为大家演示如何通过实现上述的字面量协议。</p>
<blockquote>
<p>下面的例子均已经上传GitHub，查看下载请点击<a href="https://github.com/YK-Unit/Swift-LiteralProtocolExample" target="_blank" rel="noopener">LiteralProtocolExample</a></p>
</blockquote>
<h3 id="1、定义Moeny类型，实现通过整数字面量、浮点数字面量、字符串字面量、布尔值字面量初始化Money实例："><a href="#1、定义Moeny类型，实现通过整数字面量、浮点数字面量、字符串字面量、布尔值字面量初始化Money实例：" class="headerlink" title="1、定义Moeny类型，实现通过整数字面量、浮点数字面量、字符串字面量、布尔值字面量初始化Money实例："></a>1、定义<code>Moeny</code>类型，实现通过整数字面量、浮点数字面量、字符串字面量、布尔值字面量初始化<code>Money</code>实例：</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//: Playground - noun: a place where people can play</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(value: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现CustomStringConvertible协议，提供description方法</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Money</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\(value)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现ExpressibleByIntegerLiteral字面量协议</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Money</span>: <span class="title">ExpressibleByIntegerLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">IntegerLiteralType</span> = <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(integerLiteral value: <span class="type">IntegerLiteralType</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(value: <span class="type">Double</span>(value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现ExpressibleByFloatLiteral字面量协议</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Money</span>: <span class="title">ExpressibleByFloatLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(floatLiteral value: <span class="type">FloatLiteralType</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(value: value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现ExpressibleByStringLiteral字面量协议</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Money</span>: <span class="title">ExpressibleByStringLiteral</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(stringLiteral value: <span class="type">StringLiteralType</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> doubleValue = <span class="type">Double</span>(value) &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(value: doubleValue)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(value: <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现ExpressibleByExtendedGraphemeClusterLiteral字面量协议</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(extendedGraphemeClusterLiteral value: <span class="type">StringLiteralType</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> doubleValue = <span class="type">Double</span>(value) &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(value: doubleValue)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(value: <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现ExpressibleByUnicodeScalarLiteral字面量协议</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(unicodeScalarLiteral value: <span class="type">StringLiteralType</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> doubleValue = <span class="type">Double</span>(value) &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(value: doubleValue)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(value: <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现ExpressibleByBooleanLiteral字面量协议</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Money</span>: <span class="title">ExpressibleByBooleanLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(booleanLiteral value: <span class="type">BooleanLiteralType</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> doubleValue: <span class="type">Double</span> = value ? <span class="number">1.0</span> : <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(value: doubleValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过整数字面量初始化</span></span><br><span class="line"><span class="keyword">let</span> intMoney: <span class="type">Money</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过浮点数字面量初始化</span></span><br><span class="line"><span class="keyword">let</span> floatMoney: <span class="type">Money</span> = <span class="number">10.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字符串字面量初始化</span></span><br><span class="line"><span class="keyword">let</span> strMoney: <span class="type">Money</span> = <span class="string">"10.2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过布尔值初始化</span></span><br><span class="line"><span class="keyword">let</span> boolMoney: <span class="type">Money</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="2、定义Book类型，实现通过字典字面量、数组字面量、nil字面量初始化Book实例"><a href="#2、定义Book类型，实现通过字典字面量、数组字面量、nil字面量初始化Book实例" class="headerlink" title="2、定义Book类型，实现通过字典字面量、数组字面量、nil字面量初始化Book实例:"></a>2、定义<code>Book</code>类型，实现通过字典字面量、数组字面量、nil字面量初始化<code>Book</code>实例:</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//: Playground - noun: a place where people can play</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(id: <span class="type">Int</span>, name: <span class="type">String</span> = <span class="string">"unnamed"</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.id = id</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现CustomStringConvertible协议，提供description方法</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Book</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"id:\(id)\nname:《\(name)》"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现ExpressibleByDictionaryLiteral字面量协议</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Book</span>: <span class="title">ExpressibleByDictionaryLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Key</span> = <span class="type">String</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Value</span> = <span class="type">Any</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(dictionaryLiteral elements: (<span class="type">Key</span>, <span class="type">Value</span>)...) &#123;</span><br><span class="line">        <span class="keyword">var</span> dictionary = [<span class="type">Key</span>: <span class="type">Value</span>](minimumCapacity: elements.<span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">for</span> (k, v) <span class="keyword">in</span> elements &#123;</span><br><span class="line">            dictionary[k] = v</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> id = (dictionary[<span class="string">"id"</span>] <span class="keyword">as</span>? <span class="type">Int</span>) ?? <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> name = (dictionary[<span class="string">"name"</span>] <span class="keyword">as</span>? <span class="type">String</span>) ?? <span class="string">"unnamed"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(id: id, name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现ExpressibleByArrayLiteral字面量协议</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Book</span>: <span class="title">ExpressibleByArrayLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ArrayLiteralElement</span> = <span class="type">Any</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(arrayLiteral elements: <span class="type">ArrayLiteralElement</span>...) &#123;</span><br><span class="line">        <span class="keyword">var</span> id: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> eId = elements.first <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">            id = eId</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">"unnamed"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> eName = elements[<span class="number">1</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">            name = eName</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(id: id, name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现ExpressibleByNilLiteral字面量协议</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Book</span>: <span class="title">ExpressibleByNilLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(nilLiteral: ()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字典字面量初始化</span></span><br><span class="line"><span class="keyword">let</span> dictBook: <span class="type">Book</span> = [<span class="string">"id"</span>: <span class="number">100</span>, <span class="string">"name"</span>: <span class="string">"Love is Magic"</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(dictBook)\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过数组字面量初始化</span></span><br><span class="line"><span class="keyword">let</span> arrayBook: <span class="type">Book</span> = [<span class="number">101</span>, <span class="string">"World is word"</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(arrayBook)\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过nil字面量初始化</span></span><br><span class="line"><span class="keyword">let</span> nilBook: <span class="type">Book</span> = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(nilBook)\n"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="四、关于-‘not-expressible-by-any-literal-enum’-Error"><a href="#四、关于-‘not-expressible-by-any-literal-enum’-Error" class="headerlink" title="四、关于 ‘not expressible by any literal enum’ Error"></a>四、关于 ‘not expressible by any literal enum’ Error</h2><p>当你使用自定义数据类型定义枚举时，可能会遇到以下类似错误：</p>
<blockquote>
<p>raw type ‘XX_TYPE’ is not expressible by any literal<br>enum XX_ENUM: XX_TYPE</p>
</blockquote>
<p>这是说你的自定义数据类型没有实现字面量协议。然而需要注意的是，<strong>enum目前支持的字面量协议是有限制的，其目前只支持以下几个字面量协议：</strong></p>
<ul>
<li>ExpressibleByIntegerLiteral</li>
<li>ExpressibleByFloatLiteral</li>
<li>ExpressibleByStringLiteral</li>
</ul>
<p>也就是说，若你的自定义数据类型实现的字面量协议没有包含上面中的一个，就会得到此种错误。具体示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//: Playground - noun: a place where people can play</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StockType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现CustomStringConvertible协议，提供description方法</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StockType</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stock Number:\(number)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Equatable协议，提供==方法</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StockType</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: StockType, rhs: StockType)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.number == rhs.number</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现ExpressibleByDictionaryLiteral字面量协议</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StockType</span>: <span class="title">ExpressibleByDictionaryLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Key</span> = <span class="type">String</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Value</span> = <span class="type">Any</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(dictionaryLiteral elements: (<span class="type">Key</span>, <span class="type">Value</span>)...) &#123;</span><br><span class="line">        <span class="keyword">var</span> dictionary = [<span class="type">Key</span>: <span class="type">Value</span>](minimumCapacity: elements.<span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">for</span> (k, v) <span class="keyword">in</span> elements &#123;</span><br><span class="line">            dictionary[k] = v</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> number = (dictionary[<span class="string">"number"</span>] <span class="keyword">as</span>? <span class="type">Int</span>) ?? <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(number: number)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现ExpressibleByIntegerLiteral字面量协议</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StockType</span>: <span class="title">ExpressibleByIntegerLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(integerLiteral value: <span class="type">IntegerLiteralType</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(number: value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 若StockType没有实现 ExpressibleByIntegerLiteral、ExpressibleByFloatLiteral、ExpressibleByStringLiteral中的一个，会报错误：error: raw type 'StockType' is not expressible by any literal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 你可以尝试去掉ExpressibleByIntegerLiteral的实现，看看编译器报的错误</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Stock</span>: <span class="title">StockType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> apple = <span class="number">1001</span></span><br><span class="line">    <span class="keyword">case</span> google = <span class="number">1002</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> appleStock = <span class="type">Stock</span>.apple.rawValue</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(appleStock)"</span>)</span><br></pre></td></tr></table></figure>

<p>上述例子中，定义了<code>StockType</code>数据类型和<code>Stock</code>枚举类型。若<code>StockType</code>去掉<code>ExpressibleByIntegerLiteral</code>字面量的协议的实现，将会获得上述的编译错误。</p>
<h2 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h2><ul>
<li><a href="https://developer.apple.com/documentation/swift/initialization_with_literals" target="_blank" rel="noopener external nofollow noreferrer">Initialization with Literals</a></li>
<li><a href="http://blog.krzyzanowskim.com/2015/03/12/swift-raw-not-representable-enum/" target="_blank" rel="noopener external nofollow noreferrer">Swift: Raw{Not}Representable enum</a></li>
<li><a href="https://www.tutorialspoint.com/swift/swift_literals.htm" target="_blank" rel="noopener external nofollow noreferrer">Swift - Literals</a></li>
<li><a href="http://nshipster.com/swift-literal-convertible/" target="_blank" rel="noopener external nofollow noreferrer">Swift Literal Convertibles</a></li>
<li><a href="http://swifter.tips/literal/" target="_blank" rel="noopener external nofollow noreferrer">字面量转换</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>Airbnb 开源动画库 Lottie 介绍以及详细示例</title>
    <url>/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该文章主要介绍了 Lottie是什么，如何为 Lottie 制作动画，以及 Lottie的应用场景。适合设计师和开发者阅读以及结对实践。</p>
<a id="more"></a>


<h2 id="Lottie-介绍"><a href="#Lottie-介绍" class="headerlink" title="Lottie 介绍"></a>Lottie 介绍</h2><p>Lottie 是 Airbnb 开源的一个动画渲染库，同时支持 Android、iOS、React Native 平台。Lottie 目前只支持渲染播放 After Effects 动画。 <a href="http://airbnb.design/lottie/" target="_blank" rel="noopener external nofollow noreferrer">Lottie</a> 使用从 <a href="https://github.com/bodymovin/bodymovin" target="_blank" rel="noopener">bodymovin</a> (开源的 After Effects 插件)导出的json数据来作为动画数据。所以从动画制作到动画使用的整个工作流程如下：</p>
<p><img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/Lottie%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="此图引用自http://cdn.trojx.me/blog_pic/lottie_sum.png"></p>
<ol>
<li>设计师使用 After Effects 制作动画，并导出json文件给开发者</li>
<li>各端的开发者通过 Lottie 渲染播放动画</li>
</ol>
<p>截止目前，各平台的 Lottie 支持的 After Effects 特性可从下面网页获得：</p>
<blockquote>
<p><a href="http://airbnb.io/lottie/supported-features.html" target="_blank" rel="noopener external nofollow noreferrer">http://airbnb.io/lottie/supported-features.html</a></p>
</blockquote>
<p><strong>所以，设计师在使用 After Effects 制作动画时，建议先预览上述网页，以知道应该使用哪些特性制作动画，因为若使用 Lottie 还不支持的特性，如3D图层，则 Lottie 会无法正确渲染。</strong></p>
<p>为了推广Lottie，Airbnb 还建立了一个Lottie动画网站，供网友分享自己制作的动画。网站地址为：</p>
<blockquote>
<p><a href="https://www.lottiefiles.com" target="_blank" rel="noopener external nofollow noreferrer">https://www.lottiefiles.com</a></p>
</blockquote>
<h2 id="为-Lottie-制作动画"><a href="#为-Lottie-制作动画" class="headerlink" title="为 Lottie 制作动画"></a>为 Lottie 制作动画</h2><p>为 Lottie 制作动画，需要： After Effects + bodymovin。After Effects制作好动画后，通过插件 bodymovin 导出一份 json文件，然后使用 Lottie 进行渲染播放。下面将会介绍如何安装该插件以及如何导出json文件。</p>
<h3 id="安装-After-Effects"><a href="#安装-After-Effects" class="headerlink" title="安装 After Effects"></a>安装 After Effects</h3><p>PS： 已经安装好 After Effects 的童鞋可以忽略此环节</p>
<p>After Effects 可以从Adobe官网下载安装试用，其目前售价为：3499￥/年，相对来说还是很贵的。对于负担不起的童鞋来说，也可以考虑破解版本。以下是Mac 的破解版本的下载链接：</p>
<blockquote>
<p>百度云盘：<a href="https://pan.baidu.com/s/1eRMCL26" target="_blank" rel="noopener external nofollow noreferrer">https://pan.baidu.com/s/1eRMCL26</a><br>提取密码：xyu5</p>
</blockquote>
<p>下载的文件夹中包含安装文件<code>After Effects CC 2017.dmg</code>以及破解文件<code>Adobe Zii cc2017.app</code>压缩包。安装好 After Effects 后，解压运行Adobe Zii cc2017.app 即可免费使用 After Effects 。但是，建议负担的起的童鞋还是购买正版服务，始终可以得到各种升级服务。</p>
<h3 id="安装-After-Effects-插件-bodymovin"><a href="#安装-After-Effects-插件-bodymovin" class="headerlink" title="安装 After Effects 插件 bodymovin"></a>安装 After Effects 插件 bodymovin</h3><p><strong>1. 下载插件 <code>bodymovin.zxp</code></strong></p>
<ul>
<li>下载 <a href="https://codeload.github.com/bodymovin/bodymovin/zip/master" target="_blank" rel="noopener external nofollow noreferrer">bodymovin压缩文件</a></li>
<li>解压文件，在目录 ‘/build/extension’ 找到 <code>bodymovin.zxp</code></li>
</ul>
<p><strong>2. 安装插件</strong></p>
<ul>
<li><p>下载 After Effects 插件安装器 <a href="http://aescripts.com/learn/zxp-installer/" target="_blank" rel="noopener external nofollow noreferrer">ZXP Installer</a>（有 Windows 和 Mac 版本）</p>
</li>
<li><p>运行 <code>ZXP Installer</code>，按照指示拖动<code>bodymovin.zxp</code> 到其窗口，即可安装完成</p>
<p>  <img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/%E6%8B%96%E5%8A%A8%E5%AE%89%E8%A3%85bodymovin.zxp.png" alt="拖动安装bodymovin.zxp.png"></p>
<p>安装成功后，如图所示：</p>
<p><img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/bodymovin.zxp%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" alt="bodymovin.zxp安装成功.png"></p>
</li>
</ul>
<p><strong>3. 重启 After Effects，然后修改 AE 的设置，在 ‘After Effects CC -&gt; Preferences -&gt;  General’ 中打开<br> ‘Allow Scripts to Write Files and Access Network’</strong></p>
<p>   <img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/%E6%89%93%E5%BC%80-'Allow-Scripts-to-Write-Files-and-Access-Network'.png" alt="打开
 &#39;Allow Scripts to Write Files and Access Network&#39;.png"></p>
<p>   现在可以开始制作你的动画了，制作完毕后，需要使用 bodymovin 时，前往 ‘window -&gt; extensions’ 即可找到 bodymovin：</p>
<p>   <img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/bodymovin.png" alt="bodymovin.png"></p>
<h3 id="使用-After-Effects-制作动画"><a href="#使用-After-Effects-制作动画" class="headerlink" title="使用 After Effects 制作动画"></a>使用 After Effects 制作动画</h3><p><img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/%E6%AD%A4%E5%A4%84%E8%AF%B7%E5%BC%80%E5%A7%8B%E4%BD%A0%E7%9A%84%E8%A1%A8%E6%BC%94~.png" alt="此处请开始你的表演~"></p>
<h3 id="使用-bodymovin-导出-json文件"><a href="#使用-bodymovin-导出-json文件" class="headerlink" title="使用 bodymovin 导出 json文件"></a>使用 bodymovin 导出 json文件</h3><p>当动画制作完毕后，运行 bodymovin，选择你要导出的动画，以及保存json文件的目录，点击 ‘Render’ 即可导出，具体流程如图所示：</p>
<p><img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/%E5%AF%BC%E5%87%BAjson%E6%96%87%E4%BB%B6%E6%B5%81%E7%A8%8B.png" alt="导出json文件流程.png"></p>
<h3 id="在线预览动画效果"><a href="#在线预览动画效果" class="headerlink" title="在线预览动画效果"></a>在线预览动画效果</h3><p>制作好 After Effects 动画，导出json文件，当然要验证一下 Lottie 能否正确渲染播放了。</p>
<p>Airbnb 提供了  <a href="https://www.lottiefiles.com/ios" target="_blank" rel="noopener external nofollow noreferrer">iOS APP</a> 、<a href="https://www.lottiefiles.com/android" target="_blank" rel="noopener external nofollow noreferrer"> Android APP</a> 以及 <a href="https://www.lottiefiles.com/preview" target="_blank" rel="noopener external nofollow noreferrer">Lottie 动画在线预览网站</a> 供设计师进行动画预览。</p>
<p>在网站预览的话，设计师只要把导出后的 json 文件，拖动到网页的预览框，即可在线看到 Lottie 渲染播放的动画效果。</p>
<p>使用 APP 预览的话，则需要上传 json 文件到服务端，通过链接进行预览。建议设计师上传文件到 Airbnb 建立的分享网站 <a href="https://www.lottiefiles.com" target="_blank" rel="noopener external nofollow noreferrer">lottiefiles.com</a>。</p>
<h2 id="哪些场景适宜使用-Lottie？"><a href="#哪些场景适宜使用-Lottie？" class="headerlink" title="哪些场景适宜使用 Lottie？"></a>哪些场景适宜使用 Lottie？</h2><p>Lottie 作为一个动画渲染库，在探索过程中，笔者认为其比较适宜解决以下场景的问题：</p>
<ul>
<li>启动(splash)动画：典型场景是APP logo动画的播放</li>
<li>上下拉刷新动画：所有APP都必备的功能，利用 Lottie 可以做的更加简单酷炫了</li>
<li>加载(loading)动画：典型场景是网络请求的loading动画</li>
<li>提示(tips)动画：典型场景是空白页的提示</li>
<li>按钮(button)动画：典型场景如switch按钮、编辑按钮、播放按钮等按钮的切换过渡动画</li>
<li>礼物(gift)动画：典型场景是直播类APP的高级动画播放</li>
<li>视图转场动画</li>
</ul>
<p>各场景的示例如下：（以iOS平台为例）</p>
<ul>
<li><p>启动(splash)动画.gif</p>
<p>  <img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/%E5%90%AF%E5%8A%A8(splash)%E5%8A%A8%E7%94%BB.gif" alt="启动(splash)动画.gif"></p>
</li>
<li><p>上下拉刷新动画<br>  <img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/%E4%B8%8A%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%8A%A8%E7%94%BB.gif" alt="上下拉刷新动画.gif"></p>
</li>
<li><p>加载(loading)动画+提示(tips)动画<br>  <img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/%E5%8A%A0%E8%BD%BD(loading)%E5%8A%A8%E7%94%BB+%E6%8F%90%E7%A4%BA(tips)%E5%8A%A8%E7%94%BB.gif" alt="加载(loading)动画+提示(tips)动画.gif"></p>
</li>
<li><p>按钮(button)动画+礼物(gift)动画<br>  <img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/%E6%8C%89%E9%92%AE(button)%E5%8A%A8%E7%94%BB+%E7%A4%BC%E7%89%A9(gift)%E5%8A%A8%E7%94%BB.gif" alt="按钮(button)动画+礼物(gift)动画.gif"></p>
</li>
<li><p>转场动画<br>  <img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB.gif" alt="转场动画.gif"></p>
</li>
</ul>
<h2 id="接入-Lottie"><a href="#接入-Lottie" class="headerlink" title="接入 Lottie"></a>接入 Lottie</h2><p>制作好动画，导出json文件后，iOS、Android、React Native的开发者们就可以像使用静态资源一样使用动画了。接入教程可以看官网教程或者 各平台的 Lottie 项目的github：</p>
<ul>
<li><a href="http://airbnb.io/lottie/" target="_blank" rel="noopener external nofollow noreferrer">官网教程</a></li>
<li><a href="https://github.com/airbnb/lottie-ios" target="_blank" rel="noopener">lottie-ios-git</a></li>
<li><a href="https://github.com/airbnb/lottie-android" target="_blank" rel="noopener">lottie-android-git</a></li>
<li><a href="https://github.com/airbnb/lottie-react-native" target="_blank" rel="noopener">lottie-react-native-git</a></li>
</ul>
<blockquote>
<p>lottie-iOS 的应用示例（包括上述所有例子）可访问：<br><a href="https://github.com/YK-Unit/LottieExample" target="_blank" rel="noopener">https://github.com/YK-Unit/LottieExample</a></p>
</blockquote>
<h2 id="lottie-ios-极速上手手册"><a href="#lottie-ios-极速上手手册" class="headerlink" title="lottie-ios 极速上手手册"></a>lottie-ios 极速上手手册</h2><h3 id="安装-Lottie"><a href="#安装-Lottie" class="headerlink" title="安装 Lottie"></a>安装 Lottie</h3><p>可通过 Cocoapods 或者 Carthage 导入 Lottie。</p>
<ul>
<li>Cocoapods：<code>pod &#39;lottie-ios&#39;</code></li>
<li>Carthage： <code>github &quot;airbnb/lottie-ios&quot; &quot;master&quot;</code></li>
</ul>
<h3 id="加载-Lottie-动画"><a href="#加载-Lottie-动画" class="headerlink" title="加载 Lottie 动画"></a>加载 Lottie 动画</h3><p>Lottie 动画支持从本地或者服务器的json文件加载。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从本地json加载</span></span><br><span class="line">LOTAnimationView *animationView = [LOTAnimationView animationNamed:<span class="string">@"Lottie"</span>];</span><br><span class="line"><span class="comment">//从本地指定的bundle的json加载</span></span><br><span class="line">LOTAnimationView *animationView = [LOTAnimationView animationNamed:<span class="string">@"Lottie"</span> inBundle:[<span class="built_in">NSBundle</span> YOUR_BUNDLE]];</span><br><span class="line"><span class="comment">//从服务器的json加载</span></span><br><span class="line">LOTAnimationView *animationView = [[LOTAnimationView alloc] initWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:URL_TO_JSON]];</span><br><span class="line"></span><br><span class="line">animationView.frame = <span class="built_in">CGRectMake</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:animationView];</span><br></pre></td></tr></table></figure>

<h3 id="播放-Lottie-动画"><a href="#播放-Lottie-动画" class="headerlink" title="播放 Lottie 动画"></a>播放 Lottie 动画</h3><p>Lottie 动画的播放控制，除了常规的控制，还支持进度播放、帧播放。</p>
<ul>
<li><p>播放、暂停、停止</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">LOTAnimationView *animationView = [LOTAnimationView animationNamed:<span class="string">@"Lottie"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//从上一次的动画位置开始播放</span></span><br><span class="line">[animationView play];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//暂停动画播放</span></span><br><span class="line">[animationView pause];</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"><span class="comment">//停止动画播放，此时动画进度重置为0</span></span><br><span class="line">[animationView stop];</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制进度播放：可参考示例的上下拉刷新动画</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">LOTAnimationView *animationView = [LOTAnimationView animationNamed:<span class="string">@"RefreshHeaderAnim"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接播放到指定进度</span></span><br><span class="line">[animationView playToProgress:<span class="number">0.8</span> withCompletion:^(<span class="built_in">BOOL</span> animationFinished) &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//从进度A播放到进度B</span></span><br><span class="line">[animationView playFromProgress:<span class="number">0</span> toProgress:<span class="number">0.8</span> withCompletion:^(<span class="built_in">BOOL</span> animationFinished) &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接设置当前进度</span></span><br><span class="line">animationView.animationProgress = currentProgress;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制帧播放：可参考示例的switch按钮动画</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">LOTAnimationView *animationView = [LOTAnimationView animationNamed:<span class="string">@"Switch"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接播放到指定帧</span></span><br><span class="line">[animationView playToFrame:@(<span class="number">40</span>) withCompletion:^(<span class="built_in">BOOL</span> animationFinished) &#123;</span><br><span class="line"></span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//从A帧播放到B帧</span></span><br><span class="line">[animationView playFromFrame:@(<span class="number">20</span>) toFrame:@(<span class="number">40</span>) withCompletion:^(<span class="built_in">BOOL</span> animationFinished) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环播放动画：可参考示例的Play-Pause按钮动画</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">LOTAnimationView *animationView = [LOTAnimationView animationNamed:<span class="string">@"Play-Pause"</span>];</span><br><span class="line"><span class="comment">//设置循环播放</span></span><br><span class="line">animationView.loopAnimation = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//设置自动倒退播放</span></span><br><span class="line">animationView.autoReverseAnimation = <span class="literal">YES</span>;</span><br><span class="line">[animationView playFromFrame:@(<span class="number">90</span>) toFrame:@(<span class="number">180</span>) withCompletion:^(<span class="built_in">BOOL</span> animationFinished) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑某帧的动画对象的属性：可参考示例的switch按钮动画</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.switchButton setValue:[<span class="built_in">UIColor</span> orangeColor] forKeypath:<span class="string">@"Background 2.Shape 1.Fill 1.Color"</span> atFrame:@(<span class="number">0</span>)];</span><br><span class="line">[<span class="keyword">self</span>.switchButton setValue:[<span class="built_in">UIColor</span> blueColor] forKeypath:<span class="string">@"Background 2.Shape 1.Fill 1.Color"</span> atFrame:@(<span class="number">13</span>)];</span><br></pre></td></tr></table></figure>

<p>  要修改对象的属性，需要知道属性的路径（Keypath）。获取属性的路径的方法有：</p>
<ul>
<li><p>直接打印对象的所有层级属性，从日志中获取：<br>  <code>[animationView logHierarchyKeypaths];</code> </p>
<p><img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/logHierarchyKeypaths%E6%97%A5%E5%BF%97.png" alt="logHierarchyKeypaths日志.png"></p>
</li>
<li><p>通过AE文件获得：<code>Background 2.Shape 1.Fill 1.Color</code></p>
<p><img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/Keypath.png" alt="Keypath.png"></p>
</li>
</ul>
</li>
<li><p>视图控制器转场动画（View Controller Transitions）：可参考示例的转场动画<br>Lottie 提供了 <code>LOTAnimationTransitionController</code>生成 <code>id &lt;UIViewControllerAnimatedTransitioning&gt;</code> 对象。</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">pragma</span> mark - UIViewControllerTransitioningDelegate</span></span><br><span class="line"> - (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source &#123;</span><br><span class="line">	</span><br><span class="line">    LOTAnimationTransitionController *animationController = [[LOTAnimationTransitionController alloc] initWithAnimationNamed:<span class="string">@"vcTransition1"</span></span><br><span class="line">                                                                                                              fromLayerNamed:<span class="string">@"outLayer"</span></span><br><span class="line">                                                                                                                toLayerNamed:<span class="string">@"inLayer"</span></span><br><span class="line">                                                                                                     applyAnimationTransform:<span class="literal">NO</span>];</span><br><span class="line">    <span class="keyword">return</span> animationController;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed &#123;</span><br><span class="line">    LOTAnimationTransitionController *animationController = [[LOTAnimationTransitionController alloc] initWithAnimationNamed:<span class="string">@"vcTransition2"</span></span><br><span class="line">                                                                                                              fromLayerNamed:<span class="string">@"outLayer"</span></span><br><span class="line">                                                                                                                toLayerNamed:<span class="string">@"inLayer"</span></span><br><span class="line">                                                                                                     applyAnimationTransform:<span class="literal">NO</span>];</span><br><span class="line">    <span class="keyword">return</span> animationController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="添加视图到-Layer-层：可参考“添加-View-到-Layer-示例”"><a href="#添加视图到-Layer-层：可参考“添加-View-到-Layer-示例”" class="headerlink" title="添加视图到 Layer 层：可参考“添加 View 到 Layer 示例”"></a>添加视图到 Layer 层：可参考“添加 View 到 Layer 示例”</h3><p>Lottie 除了支持动画播放，还支持添加自定义的视图到指定的 Layer ：</p>
<p><img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/%E6%B7%BB%E5%8A%A0%E8%A7%86%E5%9B%BE%E5%88%B0Layer%E5%B1%82.gif" alt="添加视图到Layer层.gif"></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *layerNames = @[<span class="string">@"Green Solid 1"</span>,<span class="string">@"Shape Layer 1"</span>,<span class="string">@"Shape Layer 2"</span>,<span class="string">@"Shape Layer 3"</span>,<span class="string">@"Shape Layer 4"</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *layerName <span class="keyword">in</span> layerNames) &#123;</span><br><span class="line">    <span class="built_in">CGRect</span> subRectViewFrame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">UIView</span> *subRectView = [[<span class="built_in">UIView</span> alloc] initWithFrame:subRectViewFrame];</span><br><span class="line">    subRectViewFrame = [<span class="keyword">self</span>.rectView convertRect:subRectViewFrame toLayerNamed:layerName];</span><br><span class="line">    subRectView.frame = subRectViewFrame;</span><br><span class="line">    subRectView.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    [<span class="keyword">self</span>.rectView addSubview:subRectView toLayerNamed:layerName applyTransform:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在AE中，我们一般会用到2种类型的 Layer 来制作动画：Solid Layer（固态图层）和 Shape Layer（形状图层）。图中，绿色的视图元素就是Solid Layer，蓝色、红色、黄色、棕色的视图元素就是 Shape Layer。</p>
<p>细心的读者可以发现，添加同一个 subRectView 到 不同的 Layer ，subRectView 的绘制位置不一样，这是因为不同类型的 Layer 其坐标系统不一样：</p>
<ul>
<li><p>Solid Layer 的坐标原点在左上角位置，向右是X轴正方向，向下是Y轴正方向</p>
</li>
<li><p>Shape Layer 的坐标原点由<code>ShapeLayer-Contents-layer-AnchorPoint</code>（内容图层的锚点位置）决定，X轴和Y轴的正方向则取决于其<code>ShapeLayer-Transform-Scale</code>的值的正负，具体如图所示：</p>
</li>
</ul>
<p><img src="/2017/Airbnb%20%E5%BC%80%E6%BA%90%E5%8A%A8%E7%94%BB%E5%BA%93%20Lottie%20%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B/readme/Shape-Layer%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F.jpg" alt="Shape Layer坐标系统.jpg"></p>
<p>在上面演示的Gif图中，<code>Shape Layer 1</code>、<code>Shape Layer 2</code>、<code>Shape Layer 3</code>、<code>Shape Layer 4</code>的坐标原点都在图层中心位置，不同的是其X轴和Y轴的正方向位置。感兴趣的同学，可以下载打开 Demo 里的 <a href="https://github.com/YK-Unit/LottieExample/tree/master/AE-Files" target="_blank" rel="noopener">RectComp.aep</a> 文件，查看对应 Layer 的坐标系统数据，然后你也可以尝试编辑修改对应图层的坐标原点位置和XY轴方向，导出动画数据进行试验。</p>
<p>总得来说，若你要添加视图到Layer，在添加前，最好打开AE文件，查看对应的 Layer 的坐标系统信息。当然，更好的做法还是和AE设计师结对开发动画，这样可以更方便知道各个Layer的信息。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>教程</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>Unicode和UTF-8、UTF-16</title>
    <url>/2017/Unicode%E5%92%8CUTF-8%E3%80%81UTF-16/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Unicode 和 UTF-8 、UTF-16是什么关系呢？这是我最近好奇的一个问题。</p>
<a id="more"></a>

<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode 是计算机科学领域里的一项业界标准，包括字符集（包含来自世界各国各地的文字字符）和编码方案（将每个字符唯一映射到一个二进制编码）。</p>
<h3 id="Unicode-编码方式"><a href="#Unicode-编码方式" class="headerlink" title="Unicode 编码方式"></a>Unicode 编码方式</h3><p>Unicode 的基本元素是<em>码位（code point）</em>，共包含1114112个码位。码位通过使用数值表示，数值格式为：<em>U+hhhh</em>，其中每个<em>h</em>代表一个十六进制数字。</p>
<p>Unicode 的所有码位组成了一个编码空间。在Unicode编码空间，Unicode码位分为17组编排，每组称为<strong>平面</strong>（Plane），而每平面拥有65536个码位。如下图所示：</p>
<p><img src="/2017/Unicode%E5%92%8CUTF-8%E3%80%81UTF-16/readme/Unicode%E7%BC%96%E7%A0%81%E7%A9%BA%E9%97%B4.png" alt="Unicode 编码空间.png"></p>
<p>Unicode 遵守既定规则把世界上的字符一一映射到码位中。被使用的码位，其码点值就是对应字符的Unicode编码。如， <a href="http://unicode.org/cldr/utility/character.jsp?a=A" target="_blank" rel="noopener external nofollow noreferrer">U+0041</a> 表示拉丁字母 “A”；<a href="http://unicode.org/cldr/utility/character.jsp?a=40000&B1=Show" target="_blank" rel="noopener external nofollow noreferrer">U+40000</a> 由于没使用，不表示任何字符。</p>
<p>截止目前，才128237 个码位被使用——编码空间的 12% 被赋值，在后面还有很多空间可应对新出现的字符。</p>
<h3 id="Unicode-实现方式"><a href="#Unicode-实现方式" class="headerlink" title="Unicode 实现方式"></a>Unicode 实现方式</h3><p>Unicode 规定了字符的编码，但是没有规定如何实现字符的编码。实现编码的方式称为<strong>Unicode 转换格式</strong>（Unicode Transformation Format，简称为UTF）。</p>
<p>Unicode 编码范围从 U+0000 到 U+10FFFF。对于计算机而言，实现Unicode 编码的最简单方式是使用32-bit表示。但是每个字符使用4个字节表示会造成浪费。当你处理大量文本的时候，使用 32-bit 存储 Unicode 字符会占用大量额外存储、内存、带宽等，因为大多字符的第1和第2个字节都是0。</p>
<p>在日常，Unicode编码的实现方式主要有：UTF-8、UTF-16。</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>UTF-8是一种可变长度字符编码方式，以8-bit 为单元，使用1至4个字节为每个字符编码。</p>
<p>UTF-8编码规则如下：</p>
<table>
<thead>
<tr>
<th>Unicode编码范围 （十六进制）</th>
<th>UTF-8编码占用字节</th>
<th>UTF-8 编码（二进制）</th>
</tr>
</thead>
<tbody><tr>
<td>U+0000 - U+007F</td>
<td>1</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>U+0080 - U+07FF</td>
<td>2</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>U+0800 - U+FFFF</td>
<td>3</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>U+10000 - U+10FFFF</td>
<td>4</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<ul>
<li><p>根据字符所在编码范围，确定其所占字节数</p>
</li>
<li><p>单字节的字符，字节的第一位设为0</p>
</li>
<li><p>n个字节的字符(n&gt;1)，第一个字节的前n位设为1，第n+1位设为0，后面字节的前两位都设为10，这n个字节的其余空位填充该字符unicode码，高位用0补足</p>
</li>
</ul>
<p>下面，以汉字<a href="http://unicode.org/cldr/utility/character.jsp?a=9C7C&B1=Show" target="_blank" rel="noopener external nofollow noreferrer">“鱼”</a>为例，演示如何实现UTF-8编码。</p>
<p>“鱼”的Unicode编码是<code>9C7C</code>（<code>1001 1100 0111 1100</code>），根据上表，<code>9C7C</code> 的UTF-8编码需要占用3个字节，其格式为<code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，<strong>从“鱼”的最后一个二进制位开始，依次从后向前填入格式中的<code>x</code>，多出的位补<code>0</code></strong>。这样，就得到“鱼”的UTF-8编码：<code>11101001 10110001 10111100</code>，转换为十六进制就是：<code>E9B1BC</code></p>
<h2 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h2><p>UTF-16是一种可变长度字符编码方式，以16-bit 为单元，使用2个或4个字节为每个字符编码。</p>
<p>UTF-16的编码规则如下：</p>
<table>
<thead>
<tr>
<th>Unicode编码范围 （十六进制）</th>
<th>UTF-16编码占用字节</th>
<th>UTF-16 编码（二进制）</th>
</tr>
</thead>
<tbody><tr>
<td>U+0000 - U+FFFF</td>
<td>2</td>
<td>xxxxxxxx xxxxxxxx</td>
</tr>
<tr>
<td>U+10000 - U+10FFFF</td>
<td>4</td>
<td>110110yyyyyyyyyy 110111xxxxxxxxxx</td>
</tr>
</tbody></table>
<ul>
<li><p>把字符的Unicode编码记作 U</p>
</li>
<li><p>若U &lt; 0x10000，字符的UTF-16编码就是U对应的16位二进制：xxxxxxxx xxxxxxxx </p>
</li>
<li><p>若U ≥ 0x10000，则把字符拆分为2部分（U+10000 ~ U+10FFFF的空间大小是2^20），前十位映射到U+D800<del>U+DBFF，后十位映射到U+DC00</del>U+DFFF。具体拆分计算如下：</p>
<ul>
<li>计算U’=U-0x10000，</li>
<li>将U’写成二进制形式：yyyy yyyy yyxx xxxx xxxx，</li>
<li>按照<code>110110yyyyyyyyyy 110111xxxxxxxxxx</code>格式填入，即得到U的UTF-16编码（二进制）：110110yyyyyyyyyy 110111xxxxxxxxxx</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>在基本平面（0x0000<del>0xFFFF）内，U+D800</del>U+DFFF是一个空段，即这些码位不对应任何字符</li>
<li>辅助平面（0x10000~0x10FFFF）的字符位共有2^20个</li>
<li>U+D800<del>U+DBFF，空间大小是2^10；U+DC00</del>U+DFFF，空间大小是2^10。二者组合起来，正好可以表示辅助平面的字符。即：辅助平面的字符可以拆分为两个基本平面的字符表示——字符前10位映射在U+D800到U+DBFF，后10位映射在U+DC00到U+DFFF</li>
</ul>
</blockquote>
<p>下面，以汉字<a href="http://unicode.org/cldr/utility/character.jsp?a=9C7C&B1=Show" target="_blank" rel="noopener external nofollow noreferrer">“鱼”</a>和字符<a href="http://unicode.org/cldr/utility/character.jsp?a=1D300&B1=Show" target="_blank" rel="noopener external nofollow noreferrer">“𝌀”</a>为例，演示如何实现UTF-16编码。</p>
<p>“鱼”的Unicode编码是<code>9C7C</code>，根据上表，<code>9C7C &lt; 0x10000</code> ，其UTF-16编码就是其Unicode编码：<code>1001 1100 0111 1100</code>，即0x9C7C。</p>
<p>“𝌀”的Unicode编码是<code>1D300</code>，根据上表，<code>1D300 &gt; 0x10000</code>，然后减去0x10000，得到0xD300，按<code>yyyy yyyy yyxx xxxx xxxx</code>格式写成二进制是：<code>0000 1101 0011 0000 0000</code>，然后按照<code>110110yyyyyyyyyy 110111xxxxxxxxxx</code>格式填入，得到“𝌀”的UTF-16编码（二进制）：<code>1101100000110100 1101111100000000</code>，即<code>0xD834 0xDF00</code>。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>回到先前的疑问：Unicode 和 UTF-8 、UTF-16是什么关系呢？</p>
<p>打个比喻，它们理论和实现的关系：Unicode制定了的理论，UTF-8和UTF-16是具体的实现方案。</p>
<p>而更形象的比喻则是：Unicode相当于中文, UTF-8、 UTF-16等相当于 行书、 楷书、草书等各种书写方式。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener external nofollow noreferrer">https://zh.wikipedia.org/wiki/Unicode</a><br><a href="https://zh.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener external nofollow noreferrer">https://zh.wikipedia.org/wiki/UTF-8</a><br><a href="https://zh.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener external nofollow noreferrer">https://zh.wikipedia.org/wiki/UTF-16</a><br><a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="noopener external nofollow noreferrer">http://www.ruanyifeng.com/blog/2014/12/unicode.html</a><br><a href="http://blog.jobbole.com/111261/" target="_blank" rel="noopener external nofollow noreferrer">http://blog.jobbole.com/111261/</a><br><a href="http://blog.csdn.net/softman11/article/details/6124345" target="_blank" rel="noopener external nofollow noreferrer">http://blog.csdn.net/softman11/article/details/6124345</a><br><a href="https://www.zhihu.com/question/23374078" target="_blank" rel="noopener external nofollow noreferrer">https://www.zhihu.com/question/23374078</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>YKPageControllerScrollView设计总结</title>
    <url>/2017/YKPageControllerScrollView%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/readme/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://github.com/YK-Unit/YKPageControllerScrollView" target="_blank" rel="noopener">YKPageControllerScrollView</a> 是一个 <code>UIViewController</code> 容器类的滚动视图，支持 <code>UIViewController</code> 重用机制。<code>YKPageControllerScrollView</code> 类的设计参考了 <code>UICollectionView</code> 类，所以你会发现，其接口以及代理方法和 <code>UICollectionView</code> 的是很相似的，使用上也是相似的。</p>
<a id="more"></a>

<h2 id="如何与『容器内容』交互？"><a href="#如何与『容器内容』交互？" class="headerlink" title="如何与『容器内容』交互？"></a>如何与『容器内容』交互？</h2><p>容器有一个特性在我看来是很重要的，那就是『容器』和『容器内容』之间的交互：『容器』告知『容器内容』其状态的变更。<br>对于<code>YKPageControllerScrollView</code>而言，这交互就是：告知『VC实例』的显示状态（将出现 or 已出现 or 已消失在视图中）以及生命状态（被容器回收了）的变更。</p>
<p>那么怎么达到以上的目的呢？此处是设计了一个协议 <code>YKPageControllerScrollViewLifeCycleProtocol</code> ，每个要放置入容器内的 <code>UIViewController</code> 类都应该去实现这么一个协议。协议内容如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YKPageControllerScrollViewLifeCycleProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)controllerWillAppearInPageControllerScrollView;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)controllerDidAppearInPageControllerScrollView;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)controllerDidDisappearInPageControllerScrollView;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)controllerDidBeReclaimedByPageControllerScrollView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>实现了上述协议的 <code>UIViewController</code> 在状态有变更时，会得到来自容器的通知。</p>
<h2 id="怎么通知VC实例显示状态的变更"><a href="#怎么通知VC实例显示状态的变更" class="headerlink" title="怎么通知VC实例显示状态的变更"></a>怎么通知VC实例显示状态的变更</h2><p><code>YKPageControllerScrollView</code> 继承自 <code>UIView</code>，那在其内部，到底是谁真正装载了 <code>UIViewController</code> 的视图内容呢？</p>
<p>答案是：<code>UICollectionView</code>。</p>
<p>而 <code>YKPageControllerScrollView</code> 是怎么获取到VC实例的显示状态（将出现 or 已出现 or 已消失在视图中）呢？正是借助了<code>UICollectionView</code> 的 <code>UICollectionViewDelegate</code> 里的相关回调方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView willDisplayCell:(<span class="built_in">UICollectionViewCell</span> *)cell forItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView didEndDisplayingCell:(<span class="built_in">UICollectionViewCell</span> *)cell forItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br></pre></td></tr></table></figure>

<p>但是上述的回调只是帮助 <code>YKPageControllerScrollView</code> 通知应用层哪些VC实例  『将出现在视图中』 和 『已消失在视图中』 而已（包括通知对应的VC实例），另外一个『已出现在视图中』的状态，<code>YKPageControllerScrollView</code> 怎么通知应用层呢？</p>
<p>方法其实也很简单——当<code>YKPageControllerScrollView</code> 里的视图滑动<br>停止后，获取当前的VC实例，即可告知应用层哪个VC实例已出现在视图中（包括通知当前VC实例）。</p>
<p><code>YKPageControllerScrollView</code> 的滑动的产生，一个源自用户手动滑动，一个源自程序接口 <code>[UICollectionView setContentOffset:animated:]</code>。</p>
<p>若是用户手动滑动视图，则在 <code>- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView</code> 回调中，执行上述通知逻辑即可。</p>
<p>若是通过 <code>[UICollectionView setContentOffset:animated:]</code> 滑动视图，则需要进一步区分 <code>animated</code> 为 YES 和 NO 的情况：</p>
<ul>
<li><p>当<code>animated</code> 为 YES  时：</p>
<p>此时在 <code>- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView</code> 回调中，执行上述通知逻辑即可。</p>
</li>
<li><p>当<code>animated</code> 为 NO  时：</p>
<p>  此时在 <code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView</code> 回调中，判断当前的滑动是非用户手动滑动且<code>animated</code> 为 NO的情况下，才执行上述通知逻辑，具体代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.isScrollWithAnim &amp;&amp; !scrollView.isTracking &amp;&amp; !scrollView.isDragging &amp;&amp; !scrollView.isDecelerating) &#123;</span><br><span class="line">        <span class="keyword">self</span>.currentIndex = (<span class="built_in">NSInteger</span>)(scrollView.contentOffset.x / <span class="keyword">self</span>.frame.size.width);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UIViewController</span>&lt;YKPageControllerScrollViewLifeCycleProtocol&gt; *currentVC = [<span class="keyword">self</span> currentViewController];</span><br><span class="line">        <span class="comment">//如果当前VC还没生成，则推迟发送通知</span></span><br><span class="line">        <span class="keyword">if</span> (currentVC) &#123;</span><br><span class="line">            [<span class="keyword">self</span> sendDidDisplayNotificationToViewController:currentVC];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//停止滚动后，回收可回收的VC</span></span><br><span class="line">            [<span class="keyword">self</span> recycleViewController];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            [<span class="built_in">NSObject</span> cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(scrollViewDidEndScrollingAnimation:) object:scrollView];</span><br><span class="line">            [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(scrollViewDidEndScrollingAnimation:) withObject:scrollView afterDelay:<span class="number">1.0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="UIViewController-重用机制"><a href="#UIViewController-重用机制" class="headerlink" title="UIViewController 重用机制"></a>UIViewController 重用机制</h2><p><code>YKPageControllerScrollView</code> 支持的 <code>UIViewController</code> 重用机制类似于 <code>UICollectionView</code> 的 <code>cell</code> 重用机制。</p>
<p>在应用层面上，二者的使用是近似的：</p>
<ol>
<li>通过 <code>[YKPageControllerScrollView registerClassForController:class]</code> 注册可重用的 <code>ViewController</code> 类。</li>
<li>通过 <code>[YKPageControllerScrollView dequeueReusableViewControllerWithReuseClass:class forIndex:index]</code> 返回可重用的VC实例。若返回的实例为 nil，则由应用层生成一个新的VC实例</li>
</ol>
<p>那么，在 <code>YKPageControllerScrollView</code> 内，该机制是如何实现的呢？</p>
<p>重用机制，总体来说，涉及3个方面：</p>
<ul>
<li>VC是怎么得到的？</li>
<li>VC是怎么重新利用的？</li>
<li>VC是怎么回收的？</li>
</ul>
<p>在解答上述3个问题前，先了解一下<code>YKPageControllerScrollView</code> 的辅助属性：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *dict4ReusableArray; </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *dict4ActiveController; </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *array4PendingControllerIndex;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dict4ReusableArray</code> 用于保存可重用的VC实例（没加载到容器上的VC实例）数组</li>
<li><code>dict4ActiveController</code> 用于保存正在使用的VC实例（加载到容器上的VC实例）</li>
<li><code>array4PendingControllerIndex</code> 用于保存那些不可见的VC实例（加载到容器上，但是没在可视区域的VC实例）的索引</li>
</ul>
<h3 id="VC是怎么得到的？"><a href="#VC是怎么得到的？" class="headerlink" title="VC是怎么得到的？"></a>VC是怎么得到的？</h3><p>在回调 <code>- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath</code> 中，通知应用层返回一个VC实例，并存放到<code>dict4ActiveController</code> 字典中：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UICollectionViewCell</span> *cell = [collectionView dequeueReusableCellWithReuseIdentifier:YKPageControllerScrollViewCellIdentifier forIndexPath:indexPath];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> index = indexPath.row;</span><br><span class="line">    <span class="keyword">self</span>.currentIndex = index;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.delegate &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(pageControllerScrollView:controllerForItemAtIndex:)]) &#123;</span><br><span class="line">        <span class="built_in">UIViewController</span>&lt;YKPageControllerScrollViewLifeCycleProtocol&gt; *vc = [<span class="keyword">self</span>.delegate pageControllerScrollView:<span class="keyword">self</span> controllerForItemAtIndex:index];</span><br><span class="line">        </span><br><span class="line">        vc.view.frame = cell.contentView.bounds;</span><br><span class="line">        [cell.contentView addSubview:vc.view];</span><br><span class="line">        [<span class="keyword">self</span>.containerViewController addChildViewController:vc];</span><br><span class="line">        [<span class="keyword">self</span>.dict4ActiveController setObject:vc forKey:@(index)];</span><br><span class="line">        [<span class="keyword">self</span>.array4PendingControllerIndex removeObject:@(index)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//NSLog(@"cellForItemAtIndex:%d",index);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VC是怎么重新利用的？"><a href="#VC是怎么重新利用的？" class="headerlink" title="VC是怎么重新利用的？"></a>VC是怎么重新利用的？</h3><p>在应用层上，当 <code>YKPageControllerScrollView</code> 通知返回一个 VC实例时，应用层首先调用 <code>YKPageControllerScrollView</code> 的<code>dequeueReusableViewControllerWithReuseClass:forIndex:</code>  方法获取一个可重用的VC实例，若为nil，才生成一个VC实例给<code>YKPageControllerScrollView</code>。VC能够重新利用的重点就在于 <code>dequeueReusableViewControllerWithReuseClass:forIndex:</code>的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIViewController</span>&lt;YKPageControllerScrollViewLifeCycleProtocol&gt; *)dequeueReusableViewControllerWithReuseClass:(<span class="keyword">nonnull</span> Class)reuseClass forIndex:(<span class="built_in">NSInteger</span>)index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIViewController</span>&lt;YKPageControllerScrollViewLifeCycleProtocol&gt; *reusableVC = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *identifier = [reuseClass description];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *reusableArray = [<span class="keyword">self</span>.dict4ReusableArray objectForKey:identifier];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若reusableArray为nil，说明没有注册reuseClass（执行[YKPageControllerScrollView registerClassForController:reuseClass]）</span></span><br><span class="line">    <span class="keyword">if</span> (reuseClass &amp;&amp; reusableArray) &#123;</span><br><span class="line">        <span class="built_in">UIViewController</span>&lt;YKPageControllerScrollViewLifeCycleProtocol&gt; *vc = [<span class="keyword">self</span>.dict4ActiveController objectForKey:@(index)];</span><br><span class="line">        <span class="keyword">if</span> (vc) &#123;</span><br><span class="line">            reusableVC = vc;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            vc = [reusableArray firstObject];</span><br><span class="line">            <span class="keyword">if</span> (vc) &#123;</span><br><span class="line">                reusableVC = vc;</span><br><span class="line">                [reusableArray removeObject:vc];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> reusableVC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>YKPageControllerScrollView</code> 根据 <code>class</code>，从 <code>dict4ReusableArray</code> 字典中获取对应的VC重用数组，然后从数组中取出一个可用的VC实例。若数组为空，则返回 nil，由应用层自己生成一个VC实例。</p>
<h3 id="VC是怎么回收？"><a href="#VC是怎么回收？" class="headerlink" title="VC是怎么回收？"></a>VC是怎么回收？</h3><p> 在<code>YKPageControllerScrollView</code> 滑动过程中，会把显示的VC实例的索引从 <code>array4PendingControllerIndex</code> 中移除，把消失的VC实例的索引添加到 <code>array4PendingControllerIndex</code> 中。<br>当 <code>YKPageControllerScrollView</code> 停止滑动后，执行回收操作 <code>[YKPageControllerScrollView  recycleViewController]</code>：把消失的且距离当前索引的距离大于3的VC实例从 <code>dict4ActiveController</code> 字典中回收到对应重用数组中。回收操作具体如下：</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)recycleViewController</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *tempArray = [<span class="built_in">NSArray</span> arrayWithArray:<span class="keyword">self</span>.array4PendingControllerIndex];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *indexNum <span class="keyword">in</span> tempArray) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> index = [indexNum integerValue];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (labs(<span class="keyword">self</span>.currentIndex - index) &gt;= <span class="number">3</span> ) &#123;</span><br><span class="line">            <span class="built_in">UIViewController</span>&lt;YKPageControllerScrollViewLifeCycleProtocol&gt; *vc = [<span class="keyword">self</span>.dict4ActiveController objectForKey:@(index)];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (vc) &#123;</span><br><span class="line">                [vc.view removeFromSuperview];</span><br><span class="line">                [vc removeFromParentViewController];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> ([vc respondsToSelector:<span class="keyword">@selector</span>(controllerDidBeReclaimedByPageControllerScrollView)]) &#123;</span><br><span class="line">                    [vc controllerDidBeReclaimedByPageControllerScrollView];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                [<span class="keyword">self</span>.dict4ActiveController removeObjectForKey:@(index)];</span><br><span class="line">                [<span class="keyword">self</span>.array4PendingControllerIndex removeObject:@(index)];</span><br><span class="line">                </span><br><span class="line">                Class reuseClass = [vc <span class="keyword">class</span>];</span><br><span class="line">                <span class="built_in">NSString</span> *identifier = [reuseClass description];</span><br><span class="line">                <span class="built_in">NSMutableArray</span> *reusableArray = [<span class="keyword">self</span>.dict4ReusableArray objectForKey:identifier];</span><br><span class="line">                [reusableArray addObject:vc];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>YKPageControllerScrollView</code> 内形成了VC实例的生成、回收、重用的闭环。</p>
<h2 id="怎么通知VC实例生命状态的变更"><a href="#怎么通知VC实例生命状态的变更" class="headerlink" title="怎么通知VC实例生命状态的变更"></a>怎么通知VC实例生命状态的变更</h2><p>VC实例在<code>YKPageControllerScrollView</code>里的生命状态的变更主要是：VC实例被 <code>YKPageControllerScrollView</code> 回收了。</p>
<p>所以，只需要在 <code>YKPageControllerScrollView</code> 执行回收操作的时候，通知被回收的VC实例即可。具体代码，可看<code>[YKPageControllerScrollView  recycleViewController]</code> 。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>YKWebViewJavascriptBridge设计总结</title>
    <url>/2017/YKWebViewJavascriptBridge%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/readme/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 iOS 开发中，你应该会碰到以下这个问题：</p>
<blockquote>
<p>如何实现 APP 内的 web 页面和 Native 页面的交互功能?<br><em>该问题的本质是：实现 JS 和 OC 的相互调用。</em></p>
</blockquote>
<p><a href="https://github.com/YK-Unit/YKWebViewJavascriptBridge" target="_blank" rel="noopener">YKWebViewJavascriptBridge</a> 是我针对上述问题实现的库。下面将会具体介绍该库的设计思路和具体实现。</p>
<a id="more"></a>

<h1 id="YKWebViewJavascriptBridge"><a href="#YKWebViewJavascriptBridge" class="headerlink" title="YKWebViewJavascriptBridge"></a>YKWebViewJavascriptBridge</h1><p><code>YKWebViewJavascriptBridge</code> 是基于 <code>WKWebView</code>+<code>messageHandler</code>+<code>自定义文本协议</code> 进行实现的，协议的传输采取的是请求响应模式。</p>
<p><code>YKWebViewJavascriptBridge</code> 的设计很简单，其内部只有2个类：</p>
<ul>
<li><code>YKNativeBridgeEngine</code>：提供 Native 层调用 JS 方法的接口；管理供 JS 调用的 OC 方法；与 Web 层进行协议通讯（对协议进行编码、解码以及传输）</li>
<li><code>YKWebBridgeEngine</code>：提供 Web 层调用 OC 方法的接口；管理供OC 调用的 JS 方法；与 Native 层进行协议通讯（对协议进行编码、解码以及传输）</li>
</ul>
<h2 id="关于『自定义文本协议』"><a href="#关于『自定义文本协议』" class="headerlink" title="关于『自定义文本协议』"></a>关于『自定义文本协议』</h2><p><code>YKWebViewJavascriptBridge</code> 里设计的『协议』是一个 JSON 格式的文本协议，其具体格式如下：</p>
<ul>
<li>请求方发出的协议数据：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"reqId"</span>:<span class="number">100</span>, <span class="comment">// 请求ID</span></span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"GetLocation"</span>, <span class="comment">// 请求响应方执行的方法</span></span><br><span class="line">    <span class="attr">"data"</span>:<span class="string">"some data from Requester"</span> <span class="comment">// 给响应方的数据（若没有数据给响应方，则不存在该key）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>响应方返回的协议数据：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"respId"</span>:<span class="number">100</span>, <span class="comment">// 响应ID，值源自reqId</span></span><br><span class="line">    <span class="attr">"data"</span>:<span class="string">"some data from Responser"</span> <span class="comment">// 给请求方的响应数据（若没有响应数据，则不存在该key）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于『编码、解码』"><a href="#关于『编码、解码』" class="headerlink" title="关于『编码、解码』"></a>关于『编码、解码』</h2><p><code>YKWebViewJavascriptBridge</code> 的编码和解码，其实就是把数据对象序列化为 JSON 和把 JSON 反序列化为数据对象。</p>
<h2 id="关于『协议传输』"><a href="#关于『协议传输』" class="headerlink" title="关于『协议传输』"></a>关于『协议传输』</h2><p>Native层的协议传输和Web层的协议传输分别由 <code>YKNativeBridgeEngine</code>  和 <code>YKWebBridgeEngine</code> 各自实现。其传输接口实现如下：</p>
<ul>
<li><code>YKNativeBridgeEngine</code>的协议传输接口</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_bridgeEngineDidWriteData:(<span class="built_in">NSString</span> *)jsonMessage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!jsonMessage) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![jsonMessage isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用YKWebBridgeEngine的_bridgeEngineDidReadData方法传递协议数据给YKWebBridgeEngine</span></span><br><span class="line">    <span class="built_in">NSString</span> *jsCode = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"YKWebBridgeEngine._bridgeEngineDidReadData('%@')"</span>,jsonMessage];</span><br><span class="line">    [<span class="keyword">self</span>.webView evaluateJavaScript:jsCode completionHandler:^(<span class="keyword">id</span> _Nullable result, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"bridgeEngineDidWriteData:%@-%@"</span>,result,error);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_bridgeEngineDidReadData:(<span class="built_in">NSString</span> *)jsonMessage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!jsonMessage) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![jsonMessage isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对接收到的json文本协议进行解码，转换层字典对象</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *messgaeDict = [<span class="keyword">self</span> deserializeJSONMessage:jsonMessage];</span><br><span class="line">    <span class="keyword">if</span> (!messgaeDict) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据解码后的协议，执行具体操作</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>YKWebBridgeEngine</code>的协议传输接口</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_bridgeEngineDidWriteData</span>(<span class="params">jsonMessage</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//通过WKWebView的messageHandler功能，传递数据给YKNativeBridgeEngine     </span></span><br><span class="line">    <span class="built_in">window</span>.webkit.messageHandlers.NativeBridgeEngineDidReadData.postMessage(jsonMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_bridgeEngineDidReadData</span>(<span class="params">jsonMessage</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 对接收到的json文本协议进行解码，转换层字典对象</span></span><br><span class="line">    <span class="keyword">var</span> messageDict = <span class="built_in">JSON</span>.parse(jsonMessage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据解码后协议内容，执行具体的操作</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉<code>WKWebView</code>+<code>messageHandler</code> 的童鞋看到这，应该知道，<code>YKWebViewJavascriptBridge</code> 的协议传输完全是基于 <code>WKWebView</code> 实现的：</p>
<ul>
<li><p><code>[WKWebView evaluateJavaScript:completionHandler:]</code> 提供了 Native 层发数据给 Web 层的能力</p>
</li>
<li><p><code>window.webkit.messageHandlers. NativeMethod.postMessage(messageData);</code> 提供了 Web 层发送数据给 Native 层的能力</p>
</li>
</ul>
<h2 id="YKNativeBridgeEngine-设计要点"><a href="#YKNativeBridgeEngine-设计要点" class="headerlink" title="YKNativeBridgeEngine 设计要点"></a>YKNativeBridgeEngine 设计要点</h2><h3 id="在应用中的初始化流程"><a href="#在应用中的初始化流程" class="headerlink" title="在应用中的初始化流程"></a>在应用中的初始化流程</h3><p><code>YKNativeBridgeEngine</code> 在应用中的初始化代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WKWebViewConfiguration</span> *configuration = [[<span class="built_in">WKWebViewConfiguration</span> alloc] init];</span><br><span class="line">configuration.userContentController = [<span class="built_in">WKUserContentController</span> new];</span><br><span class="line"></span><br><span class="line"><span class="built_in">WKPreferences</span> *preferences = [<span class="built_in">WKPreferences</span> new];</span><br><span class="line">preferences.javaScriptCanOpenWindowsAutomatically = <span class="literal">YES</span>;</span><br><span class="line">preferences.minimumFontSize = <span class="number">40.0</span>;</span><br><span class="line">configuration.preferences = preferences;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、根据WKWebViewConfiguration生成nativeBridgeEngine实例</span></span><br><span class="line"><span class="keyword">self</span>.nativeBridgeEngine = [[YKNativeBridgeEngine alloc] initWithWebViewConfiguration:configuration];;</span><br><span class="line"><span class="keyword">self</span>.webView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">200</span>, <span class="keyword">self</span>.view.frame.size.width, <span class="keyword">self</span>.view.frame.size.height - <span class="number">100</span>) configuration:<span class="keyword">self</span>.nativeBridgeEngine.configuration];</span><br><span class="line"><span class="comment">// 2、绑定具体的WKWebView实例</span></span><br><span class="line">[<span class="keyword">self</span>.nativeBridgeEngine bridgeForWebView:<span class="keyword">self</span>.webView];</span><br></pre></td></tr></table></figure>

<p>如上述代码所示，<code>YKNativeBridgeEngine</code> 在应用中的初始化需要2步：</p>
<ol>
<li><p>根据 <code>WKWebViewConfiguration</code> 生成 <code>nativeBridgeEngine</code> 实例</p>
<blockquote>
<p>为什么需要 <code>WKWebViewConfiguration</code> 来生成<code>nativeBridgeEngine</code> 实例？<br>看代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithWebViewConfiguration:(<span class="built_in">WKWebViewConfiguration</span> *)configuration</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (configuration) &#123;</span><br><span class="line">            <span class="keyword">self</span>.configuration = configuration;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">WKWebViewConfiguration</span> *configuration = [[<span class="built_in">WKWebViewConfiguration</span> alloc] init];</span><br><span class="line">            configuration.userContentController = [[<span class="built_in">WKUserContentController</span> alloc] init];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.configuration = configuration;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.configuration.userContentController) &#123;</span><br><span class="line">            <span class="keyword">self</span>.configuration.userContentController = [<span class="built_in">WKUserContentController</span> new];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过JS注入方式，初始化WebBridgeEngine</span></span><br><span class="line">        <span class="built_in">NSString</span> *js = YKWebBridgeEngine_js();</span><br><span class="line">        <span class="built_in">WKUserScript</span> *script = [[<span class="built_in">WKUserScript</span> alloc] initWithSource:js</span><br><span class="line">                                                      injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentStart</span></span><br><span class="line">                                                   forMainFrameOnly:<span class="literal">YES</span>];</span><br><span class="line">        [<span class="keyword">self</span>.configuration.userContentController addUserScript:script];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.configuration.userContentController addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@"NativeBridgeEngineDidReadData"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>WKWebViewConfiguration</code> 的作用主要是：</p>
<ul>
<li>注入 JS 代码到 <code>WebView</code>，在 <code>Document</code> 元素开始生成时，执行 <code>YKWebBridgeEngine</code> 初始化代码</li>
<li>添加 ScriptMessageHandler，提供方法给 <code>YKWebBridgeEngine</code> 发送数据给 <code>YKNativeBridgeEngine</code> </li>
</ul>
</blockquote>
</li>
<li><p>绑定具体的 <code>WKWebView</code> 实例</p>
<blockquote>
<p>为什么需要绑定具体的 <code>WKWebView</code> 实例？<br>看代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_bridgeEngineDidWriteData:(<span class="built_in">NSString</span> *)jsonMessage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!jsonMessage) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![jsonMessage isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *jsCode = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"YKWebBridgeEngine._bridgeEngineDidReadData('%@')"</span>,jsonMessage];</span><br><span class="line">    [<span class="keyword">self</span>.webView evaluateJavaScript:jsCode completionHandler:^(<span class="keyword">id</span> _Nullable result, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"bridgeEngineDidWriteData:%@-%@"</span>,result,error);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>YKNativeBridgeEngine</code> 内部持有 <code>webView</code> 的用处就是在于借助 <code>webView</code> 的 <code>evaluateJavaScript:completionHandler:</code> 功能，达到发数据给 <code>YKWebBridgeEngine</code> 的目的。</p>
</blockquote>
</li>
</ol>
<h3 id="关于『解码后的逻辑』"><a href="#关于『解码后的逻辑』" class="headerlink" title="关于『解码后的逻辑』"></a>关于『解码后的逻辑』</h3><p>在 <code>YKNativeBridgeEngine</code> 收到 <code>YKWebBridgeEngine</code> 发来的 JSON文本数据后，<code>YKNativeBridgeEngine</code> 会对数据进行解码：反序列化JSON，得到一个 <code>messageDict</code> ，然后根据其内容进行具体的逻辑操作。核心代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_bridgeEngineDidReadData:(<span class="built_in">NSString</span> *)jsonMessage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!jsonMessage) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![jsonMessage isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDictionary</span> *messgaeDict = [<span class="keyword">self</span> deserializeJSONMessage:jsonMessage];</span><br><span class="line">    <span class="keyword">if</span> (!messgaeDict) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *allKeys = messgaeDict.allKeys;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//收到WebBridgeEngine发来的请求</span></span><br><span class="line">    <span class="keyword">if</span> ([allKeys containsObject:<span class="string">@"reqId"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> reqId = [[messgaeDict objectForKey:<span class="string">@"reqId"</span>] integerValue];</span><br><span class="line">        <span class="keyword">id</span> data = [messgaeDict objectForKey:<span class="string">@"data"</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *name = [messgaeDict objectForKey:<span class="string">@"name"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!name) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        YKMessageHandler handler = [<span class="keyword">self</span>.messageHandlerDict objectForKey:name];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        YKResponseCallback responseCallback = ^(<span class="keyword">id</span> responseData) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *respMessageDict = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">8</span>];</span><br><span class="line">            [respMessageDict setObject:@(reqId) forKey:<span class="string">@"respId"</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (responseData) &#123;</span><br><span class="line">                [respMessageDict setObject:responseData forKey:<span class="string">@"data"</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSString</span> *jsonMessage = [weakSelf serializeMessage:respMessageDict];</span><br><span class="line">            [weakSelf _bridgeEngineDidWriteData:jsonMessage];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        handler(data,responseCallback);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//收到WebBridgeEngine返回的响应数据</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([allKeys containsObject:<span class="string">@"respId"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> respId = [[messgaeDict objectForKey:<span class="string">@"respId"</span>] integerValue];</span><br><span class="line">        <span class="keyword">id</span> responseData = [messgaeDict objectForKey:<span class="string">@"data"</span>];</span><br><span class="line">        YKResponseCallback responseCallback = [<span class="keyword">self</span>.responseCallbackDict objectForKey:@(respId)];</span><br><span class="line">        <span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">            responseCallback(responseData);</span><br><span class="line">            [<span class="keyword">self</span>.responseCallbackDict removeObjectForKey:@(respId)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在收到数据后，会根据解码后的 <code>messgaeDict</code> 的 key 判断这是一个『请求类型的数据』还是一个『响应类的数据』：若 key 中存在 <code>reqId</code> ，则是『请求类型的数据』，然后执行对应的请求，并返回响应数据；若是存在 <code>respId</code> ，则是一个『响应类型的数据』，然后把返回的响应数据通过回调告知应用层。</p>
<h2 id="关于-YKWebBridgeEngine"><a href="#关于-YKWebBridgeEngine" class="headerlink" title="关于 YKWebBridgeEngine"></a>关于 YKWebBridgeEngine</h2><p><code>YKWebBridgeEngine</code> 的设计（接口和功能） 和 <code>YKNativeBridgeEngine</code> 是一样的，区别在于前者是 OC 语言实现的，后者是 JS 语言实现而已。另外需要注意的是，<code>YKWebBridgeEngine</code>初始化依赖与<code>YKNativeBridgeEngine</code>，通过 JS注入，让<code>webview</code>在开始加载 <code>Document</code> 元素时执行<code>YKWebBridgeEngine</code>的初始化代码。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p> 想详细了解<code>WKWebView</code> 和 <code>messageHandler</code> 的童鞋，可以参考下面文章：</p>
<ul>
<li><a href="http://www.jianshu.com/p/433e59c5a9eb" target="_blank" rel="noopener external nofollow noreferrer">iOS下JS与OC互相调用（三）–MessageHandler</a></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.jianshu.com/p/433e59c5a9eb" target="_blank" rel="noopener external nofollow noreferrer">iOS下JS与OC互相调用（三）–MessageHandler</a></li>
<li><a href="https://github.com/marcuswestin" target="_blank" rel="noopener">marcuswestin</a>/<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>2017</tag>
        <tag>大前端</tag>
      </tags>
  </entry>
  <entry>
    <title>private_external_symbol VS external_symbol</title>
    <url>/2017/private_external_symbol%20VS%20external_symbol/readme/</url>
    <content><![CDATA[<p>腾讯提供的iOS SDK ——<a href="http://wiki.open.qq.com/wiki/mobile/SDK%E4%B8%8B%E8%BD%BD" target="_blank" rel="noopener external nofollow noreferrer">TencentOpenApi</a> 是静态库，然后因为业务需求，需要把它转换为动态库（取名：DynamicTencentOpenApi）。在实际开发时，发现了一个奇怪的事情：</p>
<a id="more"></a>

<p>整个工程如下：<br>（有兴趣的读者，可直接下载<a href="https://github.com/YK-Unit/DynamicTencentOpenApi" target="_blank" rel="noopener">该工程</a>，进行实验）</p>
<p><img src="/2017/private_external_symbol%20VS%20external_symbol/readme/DynamicTencentOpenApi-Project.png" alt="DynamicTencentOpenApi Project.png"></p>
<p>Demo 的测试 DynamicTencentOpenApi.Framework  的主要代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试TencentOAuth</span></span><br><span class="line"><span class="built_in">NSString</span> *version = [TencentOAuth sdkVersion];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,version);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试QQApiInterface</span></span><br><span class="line"><span class="built_in">NSString</span> *qqInstallUrl = [QQApiInterface getQQInstallUrl];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,qqInstallUrl);</span><br></pre></td></tr></table></figure>
<p>运行编译工程的 DynamicTencentOpenApi Target 和 Demo Target，得到结果如下：</p>
<ul>
<li>DynamicTencentOpenApi.Framework 编译运行成功</li>
<li>Demo 编译链接失败，报错误：<code>Undefined symbols for architecture x86_64: &quot;_OBJC_CLASS_$_QQApiInterface&quot;</code></li>
</ul>
<p>这里奇怪的地方在于：</p>
<ul>
<li>DynamicTencentOpenApi.Framework 编译运行成功</li>
<li>Demo 编译链接时，TencentOAuth 的 symbol 能找到，QQApiInterface 的 symbol 却找不到？</li>
</ul>
<p>用 <a href="https://github.com/gdbinit/MachOView" target="_blank" rel="noopener">MachOView</a> 查看 DynamicTencentOpenApi.Framework 里的 binary 文件发现：</p>
<p><img src="/2017/private_external_symbol%20VS%20external_symbol/readme/TencentOAuth-Symbol.png" alt="TencentOAuth Symbol.png"></p>
<p><img src="/2017/private_external_symbol%20VS%20external_symbol/readme/QQApiInterface-Symbol.png" alt="QQApiInterface Symbol.png"></p>
<ul>
<li><code>_OBJC_CLASS_$_QQApiInterface</code> symbol 的类型是：<code>N_PEXT</code></li>
<li><code>_OBJC_CLASS_$_TencentOAuth</code> symbol 的类型是：<code>N_EXT</code></li>
</ul>
<p><code>N_PEXT</code> 和 <code>N_EXT</code> 的区别是：</p>
<blockquote>
<p>N_PEXT (0x10)—If this bit is on, this symbol is marked as having limited global scope. When the file is fed to the static linker, it clears the N_EXT bit for each symbol with the N_PEXT bit set. (The ld option -keep_private_externs turns off this behavior.) With macOS GCC, you can use the <strong>private_extern</strong> function attribute to set this bit.</p>
<p>N_EXT (0x01)—If this bit is on, this symbol is an external symbol, a symbol that is either defined outside this file or that is defined in this file but can be referenced by other files.</p>
<p><a href="https://developer.apple.com/documentation/kernel/nlist_64" target="_blank" rel="noopener external nofollow noreferrer">https://developer.apple.com/documentation/kernel/nlist_64</a></p>
</blockquote>
<p>翻译过来，这2者的区别是：</p>
<ul>
<li><code>N_PEXT</code> ，意思是：private_extern。该类型的 symbol 在指定范围内可见</li>
<li><code>N_EXT</code> ，意思是：extern。该类型的 symbol，在任何范围内均可见</li>
</ul>
<p>关于范围如图所示：</p>
<p><img src="/2017/private_external_symbol%20VS%20external_symbol/readme/N_PEXT%E5%92%8CN_EXT%E7%9A%84%E8%8C%83%E5%9B%B4.png" alt="N_PEXT和N_EXT的范围.png"></p>
<p>因此，在编译Demo-OC时，到链接阶段时，就找不到这个<code>_OBJC_CLASS_$_QQApiInterface</code> symbol，继而编译失败。</p>
<p>那么如何解决这个问题呢？</p>
<p>创建一个<code>QQApiInterface镜像类</code> ，镜像类 wrap <code>QQApiInterface</code>，对外提供和<code>QQApiInterface</code>一致的接口，在内则把对应的方法响应转发给<code>QQApiInterface</code>。具体可看例子中的镜像类 <a href="https://github.com/YK-Unit/DynamicTencentOpenApi/blob/master/DynamicTencentOpenApi/QQApiInterfaceMirror.m" target="_blank" rel="noopener">QQApiInterfaceMirror</a>。</p>
<p>原来准备按照这个方案实现 DynamicTencentOpenApi ，但是后面发现，TencentOpenApi SDK 里不止 QQApiInterface 的 symbol 是<code>N_PEXT</code>类型，还有<code>QQApiTextObject</code>、<code>QQApiExtendObject</code>、<code>QQApiImageObject</code>、<code>QQApiWebImageObject</code> 等类的 symbol 都是<code>N_PEXT</code>类型的。考虑到开发成本（为这些类创建同等的镜像类）和维护成本（TencentOpenApi SDK 升级后，每个镜像类都得重新测试），最终是放弃把 TencentOpenApi 从静态库转换到动态库 DynamicTencentOpenApi。</p>
<p>这种编译链接的错误（symbol的范围受限导致链接失败），相对来说，是比较少见的，因而花了很多时间去查，才找到了原因。希望这篇文章能让后面的来者可以避开此坑。enjoy~</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul>
<li><a href="https://pewpewthespells.com/blog/convert_static_to_dynamic.html" target="_blank" rel="noopener external nofollow noreferrer">convert_static_to_dynamic</a></li>
<li><a href="https://developer.apple.com/documentation/kernel/nlist_64" target="_blank" rel="noopener external nofollow noreferrer">https://developer.apple.com/documentation/kernel/nlist_64</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/Articles/SymbolVisibility.html" target="_blank" rel="noopener external nofollow noreferrer">Controlling Symbol Visibility</a></li>
<li><a href="https://stackoverflow.com/questions/32485110/how-to-use-static-library-in-embedded-private-frameworks-and-app-on-ios" target="_blank" rel="noopener">How to Use Static Library in Embedded Private Frameworks and App on iOS</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>『 merge --ff』 VS 『 merge --no-ff 』 VS『 rebase 』</title>
    <url>/2017/%E3%80%8E%20merge%20--ff%E3%80%8F%20VS%20%E3%80%8E%20merge%20--no-ff%20%E3%80%8F%20VS%E3%80%8E%20rebase%20%E3%80%8F/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在合并分支时（如合并develop分支到master分支），我们可以有以下命令的选择：</p>
<ul>
<li><code>git merge // 等同于 git merge --ff</code></li>
<li><code>git merge --no-ff</code></li>
<li><code>git rebase</code></li>
</ul>
<p>那么，这三者之间有哪些区别呢？对此，我将会通过下面的实验进行比较说明：</p>
<p><img src="/2017/%E3%80%8E%20merge%20--ff%E3%80%8F%20VS%20%E3%80%8E%20merge%20--no-ff%20%E3%80%8F%20VS%E3%80%8E%20rebase%20%E3%80%8F/readme/%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E5%AE%9E%E9%AA%8C%E8%AF%B4%E6%98%8E%E5%9B%BE.png" alt="分支合并实验说明图.png"></p>
<a id="more"></a>

<h2 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h2><p>在日常开发中，合并的两个分支（下面将会以日常用到的master分支和develop分支这2个分支进行举例），存在这2个情形：</p>
<ul>
<li>master分支和develop分支无分叉：只有develop分支有更新</li>
<li>master分支和develop分支有分叉：两个分支均有更新</li>
</ul>
<p>接下来的实验就是：分别在这两个情形下，分别通过 <code>git merge --ff</code> 、<code>git merge --no-ff</code> 、<code>git rebase</code> 命令把develop分支合并到master分支，然后比较合并后的master的commit-tree。</p>
<p><code>merge --ff</code> 、<code>merge --no-ff</code> 、<code>rebase</code> 各自合并的步骤如下：</p>
<ul>
<li><p>使用 <code>merge --ff</code>合并的步骤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge develop  // 等同 git merge --ff develop</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>merge --no-ff</code> 合并的步骤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge --no-ff develop</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>rebase</code> 合并的步骤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git rebase master</span><br><span class="line">git checkout master</span><br><span class="line">git merge develop</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="分支无分叉的场景下："><a href="#分支无分叉的场景下：" class="headerlink" title="分支无分叉的场景下："></a>分支无分叉的场景下：</h3><p>合并前：</p>
<p><img src="/2017/%E3%80%8E%20merge%20--ff%E3%80%8F%20VS%20%E3%80%8E%20merge%20--no-ff%20%E3%80%8F%20VS%E3%80%8E%20rebase%20%E3%80%8F/readme/%E5%90%88%E5%B9%B6%E5%89%8D.png" alt="合并前.png"></p>
<p>分别执行merge/rebase后的情况对比：</p>
<ul>
<li><p>应用<code>git merge --ff</code></p>
<p>  <img src="/2017/%E3%80%8E%20merge%20--ff%E3%80%8F%20VS%20%E3%80%8E%20merge%20--no-ff%20%E3%80%8F%20VS%E3%80%8E%20rebase%20%E3%80%8F/readme/merge-ff.png" alt="merge-ff.png"></p>
</li>
<li><p>应用<code>git merge --no-ff</code></p>
<p>  <img src="/2017/%E3%80%8E%20merge%20--ff%E3%80%8F%20VS%20%E3%80%8E%20merge%20--no-ff%20%E3%80%8F%20VS%E3%80%8E%20rebase%20%E3%80%8F/readme/merge-no-ff.png" alt="merge-no-ff.png"></p>
</li>
<li><p>应用<code>git rebase</code></p>
<p>  <img src="/2017/%E3%80%8E%20merge%20--ff%E3%80%8F%20VS%20%E3%80%8E%20merge%20--no-ff%20%E3%80%8F%20VS%E3%80%8E%20rebase%20%E3%80%8F/readme/rebase.png" alt="rebase.png"></p>
</li>
</ul>
<h3 id="分支有分叉的场景下："><a href="#分支有分叉的场景下：" class="headerlink" title="分支有分叉的场景下："></a>分支有分叉的场景下：</h3><p>合并前：</p>
<p><img src="/2017/%E3%80%8E%20merge%20--ff%E3%80%8F%20VS%20%E3%80%8E%20merge%20--no-ff%20%E3%80%8F%20VS%E3%80%8E%20rebase%20%E3%80%8F/readme/%E5%90%88%E5%B9%B6%E5%89%8D-2.png" alt="合并前.png"></p>
<p>分别执行merge/rebase后的情况对比：</p>
<ul>
<li><p>应用<code>git merge --ff</code></p>
<p>  <img src="/2017/%E3%80%8E%20merge%20--ff%E3%80%8F%20VS%20%E3%80%8E%20merge%20--no-ff%20%E3%80%8F%20VS%E3%80%8E%20rebase%20%E3%80%8F/readme/merge-ff-2.png" alt="merge-ff.png"> </p>
</li>
<li><p>应用<code>git merge --no-ff</code></p>
<p>  <img src="/2017/%E3%80%8E%20merge%20--ff%E3%80%8F%20VS%20%E3%80%8E%20merge%20--no-ff%20%E3%80%8F%20VS%E3%80%8E%20rebase%20%E3%80%8F/readme/merge-no-ff-2.png" alt="merge-no-ff.png"></p>
</li>
<li><p>应用<code>git rebase</code></p>
<p>  <img src="/2017/%E3%80%8E%20merge%20--ff%E3%80%8F%20VS%20%E3%80%8E%20merge%20--no-ff%20%E3%80%8F%20VS%E3%80%8E%20rebase%20%E3%80%8F/readme/rebase-2.png" alt="rebase.png"></p>
</li>
</ul>
<h2 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h2><p>通过结果图的对比，可以得到以下结论：</p>
<table>
<thead>
<tr>
<th></th>
<th align="left">git merge –ff</th>
<th align="left">git merge –no-ff</th>
<th align="left">git rebase</th>
</tr>
</thead>
<tbody><tr>
<td>分支无分叉</td>
<td align="left">把develop上新的commit嫁接到master的最后commit上，效果等同于rebase，让master的commit-tree保持线性</td>
<td align="left">生成一个新的commit用于记录这个合并操作</td>
<td align="left">把develop上新的commit嫁接到master的最后一个commit上，让master的commit-tree保持线性</td>
</tr>
<tr>
<td>分支有分叉</td>
<td align="left">合并时，由于存在冲突，生成一个新的commit用于记录此冲突，效果等同于 merge –no-ff</td>
<td align="left">生成一个新的commit用于记录这个合并操作</td>
<td align="left">通过rebase，把develop上新的commit嫁接到master的最后一个commit上，让master的commit-tree保持线性</td>
</tr>
</tbody></table>
<h2 id="怎么选择"><a href="#怎么选择" class="headerlink" title="怎么选择"></a>怎么选择</h2><p>通过合并结果对比可以知道，在合并时，我们就只需要『merge –no-ff 』和 『rebase』之间做选择即可。那么在日常开发中怎么选择呢？根据你的合并目的来：</p>
<table>
<thead>
<tr>
<th>合并目的</th>
<th align="center">需要记录此次合并，如合并release分支</th>
<th align="center">希望commit-tree整洁和成线性，如合并feature分支</th>
<th align="center">对commit-tree无要求，适合初学者</th>
</tr>
</thead>
<tbody><tr>
<td>合并命令</td>
<td align="center">git merge –no-ff</td>
<td align="center">git rebase</td>
<td align="center">git merge</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.idaima.com/article/6773" target="_blank" rel="noopener external nofollow noreferrer">https://www.idaima.com/article/6773</a><br><a href="http://www.jianshu.com/p/73ea5aca8bf3" target="_blank" rel="noopener external nofollow noreferrer">http://www.jianshu.com/p/73ea5aca8bf3</a><br><a href="http://www.jianshu.com/p/0613d8249863" target="_blank" rel="noopener external nofollow noreferrer">http://www.jianshu.com/p/0613d8249863</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>二级指针指向的数据结构是什么样的？</title>
    <url>/2017/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/readme/</url>
    <content><![CDATA[<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码片段摘自苹果开源的runtime代码（objc4-208版本）</span></span><br><span class="line"><span class="comment">//https://opensource.apple.com/source/objc4/objc4-208/runtime/objc-class.h</span></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;			</span><br><span class="line">	<span class="keyword">struct</span> objc_class *isa;	</span><br><span class="line">	<span class="keyword">struct</span> objc_class *super_class;	</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;		</span><br><span class="line">	<span class="keyword">long</span> version;</span><br><span class="line">	<span class="keyword">long</span> info;</span><br><span class="line">	<span class="keyword">long</span> instance_size;</span><br><span class="line">	<span class="keyword">struct</span> objc_ivar_list *ivars;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(Release3CompatibilityBuild)</span></span><br><span class="line">	<span class="keyword">struct</span> objc_method_list *methods;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">struct</span> objc_method_list **methodLists;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> objc_cache *cache;</span><br><span class="line"> 	<span class="keyword">struct</span> objc_protocol_list *protocols;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是Objective-C 2.0中的类的代码，相信做iOS开发的同学都很熟悉的了。有天在查资料又看到它的时候，想到了一个好奇的问题：</p>
<blockquote>
<p><code>methodLists</code> 是一个二级指针，在内存中，它指向的是什么呢？（或者说，其指向的数据结构到底是怎么样的？）</p>
</blockquote>
<a id="more"></a>

<p>然后，我想到了下面几个可能性：</p>
<ul>
<li><p><code>methodLists</code> 指向的是一个结构体的指针</p>
<p><img src="/2017/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/readme/aP-bP-obj.png" alt="aP-bP-obj.png"></p>
</li>
<li><p><code>methodLists</code> 指向的是结构体数组的指针</p>
<p><img src="/2017/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/readme/aP-bP-objArray.png" alt="aP-bP-objArray.png"></p>
</li>
<li><p><code>methodLists</code> 指向的是结构体指针数组</p>
<p><img src="/2017/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/readme/aP-bPArray.png" alt="aP-bPArray.png"></p>
</li>
</ul>
<p>那么上面的可能性都是存在的吗？为了验证，我写了下面的代码进行测试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> version;</span><br><span class="line">&#125; method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  method **methodList;</span><br><span class="line"></span><br><span class="line">  method aMethod;</span><br><span class="line">  aMethod.version = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">  method bMethod;</span><br><span class="line">  bMethod.version = <span class="number">2.2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"开始验证第1种可能性：aP-&gt;bP-&gt;obj\n"</span>);</span><br><span class="line">  method *aMethodP = &amp;aMethod;</span><br><span class="line">  methodList = &amp;aMethodP;</span><br><span class="line"></span><br><span class="line">  method* currentMethod = *methodList;</span><br><span class="line">  <span class="keyword">float</span> version = currentMethod-&gt;version;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"version:%0.1f\n"</span>,version);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"结束验证第1种可能性。\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"开始验证第2种可能性：aP-&gt;bP-&gt;obj[]\n"</span>);</span><br><span class="line">  method methodArray[<span class="number">2</span>];</span><br><span class="line">  methodArray[<span class="number">0</span>] = aMethod;</span><br><span class="line">  methodArray[<span class="number">1</span>] = bMethod;</span><br><span class="line"></span><br><span class="line">  *methodList = methodArray;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    method* currentMethod = &amp;((*methodList)[i]);</span><br><span class="line">    <span class="keyword">float</span> version = currentMethod-&gt;version;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"version:%0.1f\n"</span>,version);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"结束验证第2种可能性。\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"开始验证第3种可能性：aP-&gt;[(bP-&gt;obj)]\n"</span>);</span><br><span class="line">  method* methodPointArray[<span class="number">2</span>];</span><br><span class="line">  methodPointArray[<span class="number">0</span>]=&amp;aMethod;</span><br><span class="line">  methodPointArray[<span class="number">1</span>]=&amp;bMethod;</span><br><span class="line"></span><br><span class="line">  methodList = &amp;(methodPointArray[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    method* currentMethod = *(methodList+i);</span><br><span class="line">    <span class="keyword">float</span> version = currentMethod-&gt;version;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"version:%0.1f\n"</span>,version);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"结束验证第3种可能性。\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/2017/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/readme/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%8F%AF%E8%83%BD%E6%80%A7%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="二级指针可能性运行结果.png"></p>
<p>按照上面提出的模型所编写的代码可以运行通过，这证明所说的3种可能性都存在，然而在<code>runtime</code>里使用的是哪种呢？</p>
<p>为此，特意去看了相关的代码，得到的答案是：第三种。</p>
<p>论据为：<code>runtime</code>中的<code>class</code>移除<code>method</code>的方法代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码片段摘自苹果开源的runtime代码（objc4-208版本）</span></span><br><span class="line"><span class="comment">//https://opensource.apple.com/source/objc4/objc4-208/runtime/objc-class.m</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_removeMethods</span> <span class="params">(Class cls, struct objc_method_list * meths)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Remove atomically.</span></span><br><span class="line">	_objc_removeMethods (meths, &amp;((struct objc_class *) cls)-&gt;methodLists);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Must flush when dynamically removing methods.  No need to flush</span></span><br><span class="line">	<span class="comment">// all the class method caches.  If cls is a meta class, though,</span></span><br><span class="line">	<span class="comment">// this will still flush it and any of its sub-meta classes.</span></span><br><span class="line">	flush_caches (cls, NO); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码片段摘自苹果开源的runtime代码（objc4-208版本）</span></span><br><span class="line"><span class="comment">//https://opensource.apple.com/source/objc4/objc4-208/runtime/objc-runtime.m</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _objc_removeMethods (struct objc_method_list * mlist, struct objc_method_list *** <span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **	<span class="title">ptr</span>;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Locate list in the array </span></span><br><span class="line">        ptr = *<span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">while</span> (*ptr != mlist) &#123;</span><br><span class="line">                <span class="comment">// fix for radar # 2538790</span></span><br><span class="line">                <span class="keyword">if</span> ( *ptr == END_OF_METHODS_LIST ) <span class="keyword">return</span>;</span><br><span class="line">                ptr += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Remove this entry </span></span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Left shift the following entries</span></span><br><span class="line">        <span class="keyword">while</span> (*(++ptr) != END_OF_METHODS_LIST)</span><br><span class="line">                *(ptr<span class="number">-1</span>) = *ptr;</span><br><span class="line">        *(ptr<span class="number">-1</span>) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>那么对于标题提出的问题：『二级指针指向的数据结构是什么样的？』，它的标准答案是什么呢？</p>
<p>答案是：没有标准答案，它的答案应该是结合具体的业务代码来回答的，比如<code>Runtime</code>里的<code>methodLists</code>。</p>
<p>另外，在最后，不得不感叹下：指针真是C语言的灵魂，其让C变得何其灵活！（当然，同时也让C变得复杂，在你不知道作者的指针意图的时候）</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>2017</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>在Mac下使用Atom搭建C开发环境</title>
    <url>/2017/%E5%9C%A8Mac%E4%B8%8B%E4%BD%BF%E7%94%A8Atom%E6%90%AD%E5%BB%BAC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/readme/</url>
    <content><![CDATA[<p>在 Mac 下写 C 的时候，如果程序并不复杂，其实蛮不愿意打开 Xcode 这个庞然大物的。为此，特意找时间解决了这个事情：<code>Atom</code> + <code>Atom 插件</code> = <code>C 轻量级 IDE</code>。</p>
<p>下面将会列出所用到的主要插件：</p>
<ul>
<li><p><a href="https://atom.io/packages/autocomplete-clang" target="_blank" rel="noopener external nofollow noreferrer">autocomplete-clang</a><br>autocomplete for C/C++/ObjC using clang</p>
</li>
<li><p><a href="https://atom.io/packages/build" target="_blank" rel="noopener external nofollow noreferrer">build</a><br>Build your current project, directly from Atom</p>
</li>
<li><p><a href="https://atom.io/packages/linter" target="_blank" rel="noopener external nofollow noreferrer">linter</a><br>A Base Linter with Cow Powers to visualize errors and other kind-of messages, easily</p>
</li>
<li><p><a href="https://atom.io/packages/linter-clang" target="_blank" rel="noopener external nofollow noreferrer">linter-clang</a><br>A linter plugin for <a href="https://atom.io/packages/linter" target="_blank" rel="noopener external nofollow noreferrer">Linter</a> provides an interface to clang</p>
</li>
<li><p><a href="https://atom.io/packages/script" target="_blank" rel="noopener external nofollow noreferrer">script</a><br>Run code in Atom!</p>
<blockquote>
<p>在 Mac 下，按 cmd-i ，该插件就会调用 clang 编译并运行当前的 c 程序</p>
</blockquote>
</li>
</ul>
<p>安装完毕后，开始你的 C 旅程吧~</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>配置多个SSH-Key</title>
    <url>/2017/%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key/readme/</url>
    <content><![CDATA[<p>为了安全性，个人的github和公司的gitlab需要配置不同的SSH-Key。具体如下：</p>
<ol>
<li><p>切换到系统的SSH目录</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure>
</li>
<li><p>为个人的github生成SSH-Key（若还没有）</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "your_mail@example.com" -f github_rsa</span><br></pre></td></tr></table></figure>

<p> 然后，前往github添加SSH公钥。</p>
</li>
<li><p>为公司的gitlab生成SSH-Key（若还没有）</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "your_mail@company.com" -f company_rsa</span><br></pre></td></tr></table></figure>

<p> 然后，前往gitlab添加SSH公钥。</p>
</li>
<li><p>添加配置文件（若还没有）</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch config</span><br></pre></td></tr></table></figure>
</li>
<li><p>为配置文件<code>config</code>添加如下内容</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> github.com</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/github_rsa</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab.company.com</span></span><br><span class="line">Host gitlab.company.com</span><br><span class="line">HostName gitlab.company.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/company_rsa</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p> 输出：</p>
<blockquote>
<p>Hi YK-Unit! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
</blockquote>
<p> 以上表示成功连接到了个人的github。<br> 然后可以用同样方式测试公司的gitlab。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>Gambler&#39;s Ruin Problem（赌徒破产问题）研究总结</title>
    <url>/2018/Gambler&#39;s%20Ruin%20Problem%EF%BC%88%E8%B5%8C%E5%BE%92%E7%A0%B4%E4%BA%A7%E9%97%AE%E9%A2%98%EF%BC%89%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/readme/</url>
    <content><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>以下是对“赌徒破产”系列问题的研究总结。通过数学证明，可见“十赌九输”并非虚言。</p>
<p>PS：由于MarkDown不支持数学公式，所以下面问题的证明过程是通过 <a href="https://chrome.google.com/webstore/detail/daum-equation-editor/dinfmiceliiomokeofbocegmacmagjhe?hl=zh-CN" target="_blank" rel="noopener external nofollow noreferrer">Daum Equation Editor</a> 来撰写，然后导出图片来展示。</p>
<a id="more"></a>


<h2 id="庄家输掉所有筹码的概率"><a href="#庄家输掉所有筹码的概率" class="headerlink" title="庄家输掉所有筹码的概率"></a>庄家输掉所有筹码的概率</h2><blockquote>
<p>庄家有n个筹码，每次有概率p赢得一个筹码，或者概率q（q=1-p）输掉一个筹码。庄家输掉所有钱后，即终止游戏。假设各次赌博都是独立的，求庄家把所有筹码输光的概率。</p>
</blockquote>
<p><strong>解答如下：</strong></p>
<p><img src="/2018/Gambler%27s%20Ruin%20Problem%EF%BC%88%E8%B5%8C%E5%BE%92%E7%A0%B4%E4%BA%A7%E9%97%AE%E9%A2%98%EF%BC%89%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/readme/%E5%BA%84%E5%AE%B6%E8%BE%93%E6%8E%89%E6%89%80%E6%9C%89%E7%AD%B9%E7%A0%81%E7%9A%84%E6%A6%82%E7%8E%87.png" alt="庄家输掉所有筹码的概率.png"></p>
<p><strong>这是上述数学公式的二维图形：</strong></p>
<p><img src="/2018/Gambler%27s%20Ruin%20Problem%EF%BC%88%E8%B5%8C%E5%BE%92%E7%A0%B4%E4%BA%A7%E9%97%AE%E9%A2%98%EF%BC%89%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/readme/%E5%BA%84%E5%AE%B6%E8%BE%93%E6%8E%89%E6%89%80%E6%9C%89%E7%AD%B9%E7%A0%81%E7%9A%84%E6%A6%82%E7%8E%87-%E4%BA%8C%E7%BB%B4%E5%9B%BE.png" alt="庄家输掉所有筹码的概率-二维图.png"></p>
<p>由公式和图可得：</p>
<ul>
<li>当 p  &lt; q 时，庄家必然输光筹码</li>
<li>当 p  &gt;= q 时，p 相同时，庄家钱越多，输光筹码的概率越小</li>
</ul>
<h2 id="赌徒赢得N个筹码的概率"><a href="#赌徒赢得N个筹码的概率" class="headerlink" title="赌徒赢得N个筹码的概率"></a>赌徒赢得N个筹码的概率</h2><blockquote>
<p>一个赌徒初始时有n个筹码，每次有概率p赢得一个筹码，或者概率q（q=1-p）输掉一个筹码。赌徒赢得N个筹码后，或者输掉所有钱后，即终止游戏。假设各次赌博都是独立的，求赌徒在输掉初始筹码前赢得N个筹码的概率。</p>
</blockquote>
<p><strong>解答如下：</strong></p>
<p><img src="/2018/Gambler%27s%20Ruin%20Problem%EF%BC%88%E8%B5%8C%E5%BE%92%E7%A0%B4%E4%BA%A7%E9%97%AE%E9%A2%98%EF%BC%89%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/readme/%E8%B5%8C%E5%BE%92%E8%B5%A2%E5%BE%97N%E4%B8%AA%E7%AD%B9%E7%A0%81%E7%9A%84%E6%A6%82%E7%8E%87.png" alt="赌徒赢得N个筹码的概率.png"></p>
<p><strong>这是上述数学公式的二维图形：</strong></p>
<p><img src="/2018/Gambler%27s%20Ruin%20Problem%EF%BC%88%E8%B5%8C%E5%BE%92%E7%A0%B4%E4%BA%A7%E9%97%AE%E9%A2%98%EF%BC%89%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/readme/%E8%B5%8C%E5%BE%92%E8%B5%A2%E5%BE%97N%E4%B8%AA%E7%AD%B9%E7%A0%81%E7%9A%84%E6%A6%82%E7%8E%87-%E4%BA%8C%E7%BB%B4%E5%9B%BE.png" alt="赌徒赢得N个筹码的概率-二维图.png"></p>
<p>由公式和图可得：</p>
<ul>
<li>当 p  &lt;= q 时，赌徒是无法赢得了目标筹码数目的</li>
<li>当 p  &gt; q 时，p 相同时，赢钱目标越大，赌徒赢取的概率越大</li>
</ul>
<p>综合以上数学证明，再结合现实情况：</p>
<ul>
<li>庄家的筹码往往多于一般赌徒</li>
<li>没有一个赌场会让赌徒赢的概率超过50%（即 p &gt; q ）</li>
</ul>
<p>赌徒进去赌场后，在有钱的庄家面前，玩着不超过50%胜率的游戏，赢钱就只是一个美丽的泡沫。</p>
<p>如果你不想输钱，那就远离赌博吧——这是保证百分之一百不会输钱的方法。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>2018</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>UICollectionView-DecorationView 开发总结</title>
    <url>/2018/UICollectionView-DecorationView%20%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在项目新版本中，要实现类似以下的效果：给每个<code>section</code>区域添加一个卡片装饰背景以及一个袖标装饰图标（卡片在所有的<code>cell</code>下，袖标在<code>cell</code>上面）。</p>
<p><img src="/2018/UICollectionView-DecorationView%20%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/readme/%E6%95%88%E6%9E%9C-1.png" alt="效果-1.png"></p>
<p><img src="/2018/UICollectionView-DecorationView%20%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/readme/%E6%95%88%E6%9E%9C-2.png" alt="效果-2.png"></p>
<p>这可以通过<code>UICollectionView</code> 的 <code>DecorationView</code> 特性来达到以上效果。本文主要是总结 <code>DecorationView</code> 的实现、重用机制和存在的坑。</p>
<a id="more"></a>

<h2 id="DecorationView-的实现（包括坑）"><a href="#DecorationView-的实现（包括坑）" class="headerlink" title="DecorationView 的实现（包括坑）"></a>DecorationView 的实现（包括坑）</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li>继承 <code>UICollectionViewLayoutAttributes</code>，实现用于描述装饰视图的布局属性的类，如描述卡片装饰视图的<code>SectionCardDecorationCollectionViewLayoutAttributes</code></li>
<li>继承 <code>UICollectionReusableView</code>，实现自己的装饰视图，如卡片装饰视图 <code>SectionCardDecorationReusableView</code></li>
<li>继承 <code>UICollectionViewFlowLayout</code>，实现自己的布局计算：主要是注册自定义的装饰视图和计算管理这些装饰视图的布局属性。如 <code>SectionCardDecorationCollectionViewLayout</code></li>
<li>继承 <code>UICollectionView</code>，override <code>layoutSubviews</code> 方法，解决装饰视图的一个坑（关于此坑，请看文章具体描述）</li>
</ol>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p><strong>1. 自定义装饰图的布局属性</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// section卡片装饰图的布局属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SectionCardDecorationCollectionViewLayoutAttributes</span>: <span class="title">UICollectionViewLayoutAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//背景色</span></span><br><span class="line">    <span class="keyword">var</span> backgroundColor = <span class="type">UIColor</span>.white</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所定义属性的类型需要遵从 NSCopying 协议</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(with zone: NSZone? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">Any</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> copy = <span class="keyword">super</span>.copy(with: zone) <span class="keyword">as</span>! <span class="type">SectionCardDecorationCollectionViewLayoutAttributes</span></span><br><span class="line">        copy.backgroundColor = <span class="keyword">self</span>.backgroundColor</span><br><span class="line">        <span class="keyword">return</span> copy</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所定义属性的类型还要实现相等判断方法（isEqual）</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">isEqual</span><span class="params">(<span class="number">_</span> object: <span class="keyword">Any</span>?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> rhs = object <span class="keyword">as</span>? <span class="type">SectionCardDecorationCollectionViewLayoutAttributes</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !<span class="keyword">self</span>.backgroundColor.isEqual(rhs.backgroundColor) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.isEqual(object)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 自定义装饰图</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Section卡片装饰视图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SectionCardDecorationReusableView</span>: <span class="title">UICollectionReusableView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">        <span class="keyword">self</span>.customInit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)!</span><br><span class="line">        <span class="keyword">self</span>.customInit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">customInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = <span class="type">UIColor</span>.white</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.layer.cornerRadius = <span class="number">6.0</span></span><br><span class="line">        <span class="keyword">self</span>.layer.borderColor = <span class="type">UIColor</span>.clear.cgColor</span><br><span class="line">        <span class="keyword">self</span>.layer.borderWidth = <span class="number">1.0</span></span><br><span class="line">        <span class="comment">// SketchShadow: color-(0,0,0,0.17),x-0,y-1,blur-2,spread-0</span></span><br><span class="line">        <span class="keyword">self</span>.layer.shadowColor = <span class="type">UIColor</span>.black.cgColor</span><br><span class="line">        <span class="keyword">self</span>.layer.shadowOpacity = <span class="number">0.17</span></span><br><span class="line">        <span class="keyword">self</span>.layer.shadowOffset = <span class="type">CGSize</span>.<span class="keyword">init</span>(width: <span class="number">0</span>, height: <span class="number">1.0</span>)</span><br><span class="line">        <span class="keyword">self</span>.layer.shadowRadius = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过apply方法让自定义属性生效</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(<span class="number">_</span> layoutAttributes: UICollectionViewLayoutAttributes)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.apply(layoutAttributes)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> attr = layoutAttributes <span class="keyword">as</span>? <span class="type">SectionCardDecorationCollectionViewLayoutAttributes</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.backgroundColor = attr.backgroundColor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="type">SectionCardDecorationViewKind</span> = <span class="string">"SectionCardDecorationReuseIdentifier"</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 自定义 <code>UICollectionViewFlowLayout</code></strong></p>
<blockquote>
<p>自定义 <code>UICollectionViewFlowLayout</code>，主要是实现自己的布局计算。主要的计算操作有：</p>
<ul>
<li>初始化时进行装饰视图的注册操作（对应 <code>setup</code> 方法）</li>
<li>override <code>prepare</code> 方法，计算生成装饰视图的布局属性</li>
<li>override <code>layoutAttributesForElements</code> 方法，返回可视范围下装饰视图的布局属性</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 卡片式背景CollectionViewLayout</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SectionCardDecorationCollectionViewLayout</span>: <span class="title">UICollectionViewFlowLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存所有自定义的section背景的布局属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> cardDecorationViewAttrs: [<span class="type">Int</span>:<span class="type">UICollectionViewLayoutAttributes</span>] = [:]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> armbandDecorationViewAttrs: [<span class="type">Int</span>:<span class="type">UICollectionViewLayoutAttributes</span>] = [:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">weak</span> <span class="keyword">var</span> decorationDelegate: <span class="type">SectionCardDecorationCollectionViewLayoutDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        setup()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line"></span><br><span class="line">        setup()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化时进行一些注册操作</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//注册DecorationView</span></span><br><span class="line">        <span class="keyword">self</span>.register(<span class="type">SectionCardDecorationReusableView</span>.<span class="keyword">self</span>,</span><br><span class="line">                      forDecorationViewOfKind: <span class="type">SectionCardDecorationViewKind</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.register(<span class="type">SectionCardArmbandDecorationReusableView</span>.<span class="keyword">self</span>,</span><br><span class="line">                      forDecorationViewOfKind: <span class="type">SectionCardArmbandDecorationViewKind</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepare()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果collectionView当前没有分区，则直接退出</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> numberOfSections = <span class="keyword">self</span>.collectionView?.numberOfSections</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> flowLayoutDelegate: <span class="type">UICollectionViewDelegateFlowLayout?</span> = <span class="keyword">self</span>.collectionView?.delegate <span class="keyword">as</span>? <span class="type">UICollectionViewDelegateFlowLayout</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不存在cardDecorationDelegate就退出</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> strongCardDecorationDelegate = decorationDelegate <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除旧的装饰视图的布局数据</span></span><br><span class="line">        <span class="keyword">self</span>.cardDecorationViewAttrs.removeAll()</span><br><span class="line">        <span class="keyword">self</span>.armbandDecorationViewAttrs.removeAll()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分别计算每个section的装饰视图的布局属性</span></span><br><span class="line">        <span class="keyword">for</span> section <span class="keyword">in</span> <span class="number">0</span>..&lt;numberOfSections &#123;</span><br><span class="line">            <span class="comment">//获取该section下第一个，以及最后一个item的布局属性</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> numberOfItems = <span class="keyword">self</span>.collectionView?.numberOfItems(inSection: section),</span><br><span class="line">                numberOfItems &gt; <span class="number">0</span>,</span><br><span class="line">                <span class="keyword">let</span> firstItem = <span class="keyword">self</span>.layoutAttributesForItem(at:</span><br><span class="line">                    <span class="type">IndexPath</span>(item: <span class="number">0</span>, section: section)),</span><br><span class="line">                <span class="keyword">let</span> lastItem = <span class="keyword">self</span>.layoutAttributesForItem(at:</span><br><span class="line">                    <span class="type">IndexPath</span>(item: numberOfItems - <span class="number">1</span>, section: section))</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取该section的内边距</span></span><br><span class="line">            <span class="keyword">var</span> sectionInset = <span class="keyword">self</span>.sectionInset</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> inset = flowLayoutDelegate?.collectionView?(<span class="keyword">self</span>.collectionView!,</span><br><span class="line">                                                              layout: <span class="keyword">self</span>, insetForSectionAt: section) &#123;</span><br><span class="line">                sectionInset = inset</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算得到该section实际的位置</span></span><br><span class="line">            <span class="keyword">var</span> sectionFrame = firstItem.frame.union(lastItem.frame)</span><br><span class="line">            <span class="comment">//计算得到该section实际的尺寸</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.scrollDirection == .horizontal &#123;</span><br><span class="line">                sectionFrame.origin.x -= sectionInset.<span class="keyword">left</span></span><br><span class="line">                sectionFrame.origin.y = sectionInset.top</span><br><span class="line">                sectionFrame.size.width += sectionInset.<span class="keyword">left</span> + sectionInset.<span class="keyword">right</span></span><br><span class="line">                sectionFrame.size.height = <span class="keyword">self</span>.collectionView!.frame.height</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sectionFrame.origin.x = sectionInset.<span class="keyword">left</span></span><br><span class="line">                sectionFrame.origin.y -= sectionInset.top</span><br><span class="line">                sectionFrame.size.width = <span class="keyword">self</span>.collectionView!.frame.width</span><br><span class="line">                sectionFrame.size.height += sectionInset.top + sectionInset.bottom</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 想判断卡片是否可见</span></span><br><span class="line">            <span class="keyword">let</span> cardDisplayed = strongCardDecorationDelegate.collectionView(<span class="keyword">self</span>.collectionView!, layout: <span class="keyword">self</span>, decorationDisplayedForSectionAt: section)</span><br><span class="line">            <span class="keyword">guard</span> cardDisplayed == <span class="literal">true</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算卡片装饰图的属性</span></span><br><span class="line">            <span class="keyword">let</span> cardDecorationInset = strongCardDecorationDelegate.collectionView(<span class="keyword">self</span>.collectionView!, layout: <span class="keyword">self</span>, decorationInsetForSectionAt: section)</span><br><span class="line">            <span class="comment">//计算得到cardDecoration该实际的尺寸</span></span><br><span class="line">            <span class="keyword">var</span> cardDecorationFrame = sectionFrame</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.scrollDirection == .horizontal &#123;</span><br><span class="line">                cardDecorationFrame.origin.x = sectionFrame.origin.x + cardDecorationInset.<span class="keyword">left</span></span><br><span class="line">                cardDecorationFrame.origin.y = cardDecorationInset.top</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cardDecorationFrame.origin.x = cardDecorationInset.<span class="keyword">left</span></span><br><span class="line">                cardDecorationFrame.origin.y = sectionFrame.origin.y + cardDecorationInset.top</span><br><span class="line">            &#125;</span><br><span class="line">            cardDecorationFrame.size.width = sectionFrame.size.width - (cardDecorationInset.<span class="keyword">left</span> + cardDecorationInset.<span class="keyword">right</span>)</span><br><span class="line">            cardDecorationFrame.size.height = sectionFrame.size.height - (cardDecorationInset.top + cardDecorationInset.bottom)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据上面的结果计算卡片装饰图的布局属性</span></span><br><span class="line">            <span class="keyword">let</span> cardAttr = <span class="type">SectionCardDecorationCollectionViewLayoutAttributes</span>(</span><br><span class="line">                forDecorationViewOfKind: <span class="type">SectionCardDecorationViewKind</span>,</span><br><span class="line">                with: <span class="type">IndexPath</span>(item: <span class="number">0</span>, section: section))</span><br><span class="line">            cardAttr.frame = cardDecorationFrame</span><br><span class="line"></span><br><span class="line">            <span class="comment">// zIndex用于设置front-to-back层级；值越大，优先布局在上层；cell的zIndex为0</span></span><br><span class="line">            cardAttr.zIndex = -<span class="number">1</span></span><br><span class="line">            <span class="comment">//通过代理方法获取该section卡片装饰图使用的颜色</span></span><br><span class="line">            <span class="keyword">let</span> backgroundColor = strongCardDecorationDelegate.collectionView(<span class="keyword">self</span>.collectionView!, layout: <span class="keyword">self</span>, decorationColorForSectionAt: section)</span><br><span class="line">            cardAttr.backgroundColor = backgroundColor</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将该section的卡片装饰图的布局属性保存起来</span></span><br><span class="line">            <span class="keyword">self</span>.cardDecorationViewAttrs[section] = cardAttr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先判断袖标是否可见</span></span><br><span class="line">            <span class="keyword">let</span> armbandDisplayed = strongCardDecorationDelegate.collectionView(<span class="keyword">self</span>.collectionView!, layout: <span class="keyword">self</span>, armbandDecorationDisplayedForSectionAt: section)</span><br><span class="line">            <span class="keyword">guard</span> armbandDisplayed == <span class="literal">true</span> <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果袖标图片名称为nil，就跳过</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> imageName = strongCardDecorationDelegate.collectionView(<span class="keyword">self</span>.collectionView!, layout: <span class="keyword">self</span>, armbandDecorationImageForSectionAt: section) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算袖标装饰图的属性</span></span><br><span class="line">            <span class="keyword">var</span> armbandDecorationInset = cardDecorationInset</span><br><span class="line">            armbandDecorationInset.<span class="keyword">left</span> = <span class="number">1</span></span><br><span class="line">            armbandDecorationInset.top = <span class="number">18</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> topOffset = strongCardDecorationDelegate.collectionView(<span class="keyword">self</span>.collectionView!, layout: <span class="keyword">self</span>, armbandDecorationTopOffsetForSectionAt: section) &#123;</span><br><span class="line">                armbandDecorationInset.top = topOffset</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算得到armbandDecoration该实际的尺寸</span></span><br><span class="line">            <span class="keyword">var</span> armbandDecorationFrame = sectionFrame</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.scrollDirection == .horizontal &#123;</span><br><span class="line">                armbandDecorationFrame.origin.x = sectionFrame.origin.x + armbandDecorationInset.<span class="keyword">left</span></span><br><span class="line">                armbandDecorationFrame.origin.y = armbandDecorationInset.top</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                armbandDecorationFrame.origin.x = armbandDecorationInset.<span class="keyword">left</span></span><br><span class="line">                armbandDecorationFrame.origin.y = sectionFrame.origin.y + armbandDecorationInset.top</span><br><span class="line">            &#125;</span><br><span class="line">            armbandDecorationFrame.size.width = <span class="number">80</span></span><br><span class="line">            armbandDecorationFrame.size.height = <span class="number">53</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据上面的结果计算袖标装饰视图的布局属性</span></span><br><span class="line">            <span class="keyword">let</span> armbandAttr = <span class="type">SectionCardArmbandDecorationCollectionViewLayoutAttributes</span>(</span><br><span class="line">                forDecorationViewOfKind: <span class="type">SectionCardArmbandDecorationViewKind</span>,</span><br><span class="line">                with: <span class="type">IndexPath</span>(item: <span class="number">0</span>, section: section))</span><br><span class="line">            armbandAttr.frame = armbandDecorationFrame</span><br><span class="line">            armbandAttr.zIndex = <span class="number">1</span></span><br><span class="line">            armbandAttr.imageName = imageName</span><br><span class="line">            <span class="comment">//将该section的袖标装饰视图的布局属性保存起来</span></span><br><span class="line">            <span class="keyword">self</span>.armbandDecorationViewAttrs[section] = armbandAttr</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回rect范围下父类的所有元素的布局属性以及子类自定义装饰视图的布局属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutAttributesForElements</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span></span><br><span class="line">        -&gt; [<span class="type">UICollectionViewLayoutAttributes</span>]? &#123;</span><br><span class="line">            <span class="keyword">var</span> attrs = <span class="keyword">super</span>.layoutAttributesForElements(<span class="keyword">in</span>: rect)</span><br><span class="line">            attrs?.append(contentsOf: <span class="keyword">self</span>.cardDecorationViewAttrs.values.<span class="built_in">filter</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> rect.intersects($<span class="number">0</span>.frame)</span><br><span class="line">            &#125;)</span><br><span class="line">            attrs?.append(contentsOf: <span class="keyword">self</span>.armbandDecorationViewAttrs.values.<span class="built_in">filter</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> rect.intersects($<span class="number">0</span>.frame)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> attrs</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回对应于indexPath的位置的装饰视图的布局属性</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutAttributesForDecorationView</span><span class="params">(ofKind elementKind: String,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    at indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewLayoutAttributes?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> section = indexPath.section</span><br><span class="line">        <span class="keyword">if</span> elementKind == <span class="type">SectionCardDecorationViewKind</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.cardDecorationViewAttrs[section]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> elementKind == <span class="type">SectionCardArmbandDecorationViewKind</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.armbandDecorationViewAttrs[section]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.layoutAttributesForDecorationView(ofKind: elementKind,</span><br><span class="line">                                                       at: indexPath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 自定义 <code>UICollectionView</code>，解决装饰视图的坑</strong></p>
<blockquote>
<p>在描述这个坑前，需要先普及一个知识点：如何控制<code>UICollectionView</code>的子视图的层级关系，如让卡片装饰视图居于cell下面？</p>
<p>答案是：使用<code>UICollectionViewLayoutAttributes</code> 的 <code>zIndex</code> 属性。  <code>UICollectionView</code>进行布局时，会依据子视图的布局属性的 <code>zIndex</code> 的值的大小来控制子视图的 <strong>front-to-back</strong> 层级关系（在前或者在后）。cell 的布局属性的 <code>zIndex</code> 的值为0，所以若要卡片装饰视图在 cell 下面，只要设置其布局属性的 <code>zIndex</code> 的值小于0即可。</p>
<p>在知道这个知识点后，让我来具体描述一下的 <code>UICollectionView</code> 的在装饰视图的坑：在iOS10+上，<code>zIndex</code> 会随机失效。具体表现为，卡片装饰视图的布局属性的 <code>zIndex</code> 设置为 -1，比 cell 的小，理论上进行布局时，卡片装饰视图应该总是在 cell 下面；但是实际上，当你的 <code>UICollectionView</code> 比较复杂时，会 <strong>随机</strong> 出现某些 cell 布局在了卡片装饰视图下面，如图所示（由于这个“随机问题”只出现在具体的项目中，不出现在Demo中，为了方便说明问题，特意“手动”实现这种“随机问题”的效果来生成截图😂）：</p>
<p><img src="/2018/UICollectionView-DecorationView%20%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/readme/bug%E7%A4%BA%E4%BE%8B.png" alt="bug示例.png"></p>
<p>对于这个“随机”问题，国外论坛也有对应的<a href="https://github.com/lionheart/openradar-mirror/issues/15453" target="_blank" rel="noopener">讨论</a>。</p>
<p>在该讨论的帖子下，有开发者建议通过设置 <code>cell.layer.zPosition</code> 来解决，但是我在尝试后，发现这个方法无效。最后，我使用了另一个方法来解决：自定义 <code>UICollectionView</code>，override <code>layoutSubviews</code> 方法，手动调整装饰视图和cell的层级关系。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CardCollectionView</span>: <span class="title">UICollectionView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> sectionCardViews: [<span class="type">UIView</span>] = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.subviews.forEach &#123; (subview) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> decorationView = subview <span class="keyword">as</span>? <span class="type">SectionCardDecorationReusableView</span> &#123;</span><br><span class="line">                sectionCardViews.append(decorationView)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sectionCardViews.forEach &#123; (decorationView) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.sendSubview(toBack: decorationView)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DecorationView-的重用机制"><a href="#DecorationView-的重用机制" class="headerlink" title="DecorationView 的重用机制"></a>DecorationView 的重用机制</h2><p>在 <code>UICollectionView</code> 里，DecorationView 的重用机制和 Cell 的重用机制是一致的：使用前，先注册（只不过 DecorationView 的注册是由<code>UICollectionViewFlowLayout</code>来发起——实际还是 UICollectionView 进行最终的注册操作）；使用时，由<code>UICollectionView</code>根据上下文创建新的 DecorationView 或者返回旧的 DecorationView。</p>
<p>那么以上结论的依据是什么呢？请看下面的<code>UICollectionView</code>的重用队列属性即可知道：</p>
<p><img src="/2018/UICollectionView-DecorationView%20%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/readme/UICollectionView%E7%9A%84%E9%87%8D%E7%94%A8%E9%98%9F%E5%88%97%E5%B1%9E%E6%80%A7.png" alt="UICollectionView的重用队列属性.png"></p>
<p>在 <code>UICollectionView</code> 里面有2种视图类型的重用队列，分别是 Cell 类型（对应<code>cellReuseQueues</code>） 和 Supplementary 类型（对应<code>supplementaryReuseQueues</code>）。这2种类型的重用机制是一样的。其中，DecorationView 是 SupplementaryView 的一种。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最后，附上Demo代码。具体，请点击这个 <a href="https://github.com/YK-Unit/DecorationViewDemo" target="_blank" rel="noopener">repo</a>。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode 文本宏（Text Macros）的介绍和应用</title>
    <url>/2018/Xcode%20%E6%96%87%E6%9C%AC%E5%AE%8F%EF%BC%88Text%20Macros%EF%BC%89%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%BA%94%E7%94%A8/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文本宏（<code>Text Macros</code>）是Xcode隐藏的特性，直到Xcode 9.0后，苹果官方才开始允许开发者进行自定义文本宏。下面将会详细介绍文本宏的相关知识和应用场景。</p>
<a id="more"></a>

<h2 id="什么是文本宏"><a href="#什么是文本宏" class="headerlink" title="什么是文本宏"></a>什么是文本宏</h2><p>文本宏（<code>Text Macro</code>）是一种可以就地展开（<code>expanded in-place</code>）为特定文本的符号。其常见于Xcode文件模板中，如图所示：</p>
<p><img src="/2018/Xcode%20%E6%96%87%E6%9C%AC%E5%AE%8F%EF%BC%88Text%20Macros%EF%BC%89%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%BA%94%E7%94%A8/readme/NSObjectObjective-C%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF.png" alt="NSObjectObjective-C文件模板"></p>
<p>图中的<code>FILEHEADER</code>、<code>FILEBASENAME</code>、<code>FILEBASENAMEASIDENTIFIER</code>就是所说的文本宏。Xcode在使用文件模板创建文件时，会把文件模板中的文本宏，展开生成特定的文本，如使用<code>NSObjectObjective-C</code>文件模板创建一个文件名为<code>MyObject.m</code>的文件时，<code>FILEHEADER</code>会展开生成头部注释信息，<code>FILEBASENAME</code>会展开生成字符串<code>MyObject</code>，<code>FILEBASENAMEASIDENTIFIER</code>会展开生成字符串<code>MyObject</code>，如下图所示：</p>
<p><img src="/2018/Xcode%20%E6%96%87%E6%9C%AC%E5%AE%8F%EF%BC%88Text%20Macros%EF%BC%89%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%BA%94%E7%94%A8/readme/%E6%96%87%E6%9C%AC%E5%AE%8F%E8%A7%A3%E9%87%8A%E7%A4%BA%E4%BE%8B.png" alt="文本宏解释示例"></p>
<blockquote>
<p><strong>延伸阅读</strong></p>
<p>Xcode模板有文件模板和工程模板。模板文件按照开发平台存放，其中每个平台的模板位置如下：</p>
<ul>
<li>macOS平台模板：<code>/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates</code></li>
<li>iOS平台模板：<code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates</code></li>
<li>tvOS平台模板：<code>/Applications/Xcode.app/Contents/D
eveloper/Platforms/AppleTVOS.platform/Developer/Library/Xcode/Templates</code></li>
<li>watchOS平台模板：<code>/Applications/Xcode.app/Contents/Developer/Platforms/WatchOS.platform/Developer/Library/Xcode/Templates</code></li>
</ul>
</blockquote>
<h2 id="公开可用的文本宏"><a href="#公开可用的文本宏" class="headerlink" title="公开可用的文本宏"></a>公开可用的文本宏</h2><p>当前Xcode在其官方文档公开给开发者可用的文本宏有以下几类：</p>
<p><strong>时间类：</strong></p>
<ul>
<li><p>DATE</p>
<blockquote>
<p>当前的日期，如<code>2018/12/20</code>。</p>
</blockquote>
</li>
<li><p>YEAR</p>
<blockquote>
<p>四位数字格式的当前年数，如<code>2018</code></p>
</blockquote>
</li>
<li><p>TIME</p>
<blockquote>
<p>当前的时间，如<code>20:48</code></p>
</blockquote>
</li>
</ul>
<p><strong>开发环境类：</strong></p>
<ul>
<li><p>RUNNINGMACOSVERSION</p>
<blockquote>
<p>当前<code>macOS</code>系统的版本。</p>
</blockquote>
</li>
<li><p>DEFAULTTOOLCHAINSWIFTVERSION</p>
<blockquote>
<p>当前工程使用的<code>Swift</code>版本。</p>
</blockquote>
</li>
<li><p>FULLUSERNAME</p>
<blockquote>
<p>当前系统用户的全名。</p>
</blockquote>
</li>
<li><p>USERNAME</p>
<blockquote>
<p>当前<code>macOS</code>用户的登录名。</p>
</blockquote>
</li>
</ul>
<p><strong>开发工程配置类：</strong></p>
<ul>
<li><p>ORGANIZATIONNAME</p>
<blockquote>
<p>当前工程配置的公司名称。</p>
</blockquote>
</li>
<li><p>WORKSPACENAME</p>
<blockquote>
<p>当前<code>Workspace</code>的名称。如果<code>Workspace</code>中只有一个 <code>Project</code>，那么这个宏的值便是当前打开的<code>Project</code>的名称。</p>
</blockquote>
</li>
<li><p>PROJECTNAME</p>
<blockquote>
<p>当前工程的名称。</p>
</blockquote>
</li>
<li><p>TARGETNAME</p>
<blockquote>
<p>当前<code>Target</code>的名称。</p>
</blockquote>
</li>
<li><p>PACKAGENAME</p>
<blockquote>
<p>当前工程<code>Scheme</code>所设置的包名。</p>
</blockquote>
</li>
<li><p>PACKAGENAMEASIDENTIFIER</p>
<blockquote>
<p>把不符合<code>C语言标识符规范</code>的字符替换为下划线（<code>_</code>）后的<code>PACKAGENAME</code>。</p>
</blockquote>
</li>
<li><p>PRODUCTNAME</p>
<blockquote>
<p>当前工程<code>Scheme</code>设置的应用名称。</p>
</blockquote>
</li>
<li><p>COPYRIGHT</p>
<blockquote>
<p>当前工程的版权信息，如<code>Copyright © 2018 YK-Unit. All rights reserved.</code>。</p>
<p>需要注意的是，若当前Xcode工程没有配置公司名，该值会是一个空字符串。</p>
</blockquote>
</li>
</ul>
<p><strong>文本文件信息类：</strong></p>
<ul>
<li><p>FILENAME</p>
<blockquote>
<p>当前文件的完整名称，包括扩展名。</p>
</blockquote>
</li>
<li><p>FILEBASENAME</p>
<blockquote>
<p>删除掉扩展名后的<code>FILENAME</code>，如创建一个名为<code>MyObject.m</code>的文件，该值为<code>MyObject</code>。</p>
</blockquote>
</li>
<li><p>FILEBASENAMEASIDENTIFIER</p>
<blockquote>
<p>把不符合<code>C语言标识符规范</code>的字符替换为下划线（<code>_</code>）后的<code>FILEBASENAME</code>，如创建一个名为<code>My-Object.m</code>的文件，该值为<code>My_Object</code>。</p>
<p>注：<code>C语言标识符规范</code>只允许使用字母（<code>A-Z</code>, <code>a-z</code>）和数字（<code>0-9</code>）以及下划线（<code>_</code>），使用这个宏会把其他的字符自动替换成下划线。</p>
</blockquote>
</li>
<li><p>FILEHEADER</p>
<blockquote>
<p>每个文本文件头部的文本。</p>
<p>注：该文本宏其实是由多个文本宏组成，其首先是展开生成以下文本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  ___FILENAME___</span><br><span class="line">&#x2F;&#x2F;  ___PACKAGENAME___</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  Created by ___FULLUSERNAME___ on ___DATE___.</span><br><span class="line">&#x2F;&#x2F;  ___COPYRIGHT___</span><br><span class="line">&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>
<p>之后Xcode再把上述的宏文本展开生成对应的文本，最后生成的就是我们日常看到的文件头部注释信息了。</p>
</blockquote>
</li>
</ul>
<p><strong>其他：</strong></p>
<ul>
<li><p>NSHUMANREADABLECOPYRIGHTPLIST</p>
<blockquote>
<p><code>macOS app</code>工程的<code>target</code>中的<code>Info.plist</code> 文件中<code>人类可读的版权信息</code>条目的值，该值包括这个条目的<code>key</code>和<code>value</code>以及<code>XML</code>的分隔符，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;NSHumanReadableCopyright&lt;&#x2F;key&gt;</span><br><span class="line">&lt;string&gt;Copyright © 2017 Apple, Inc. All rights reserved.&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure>



</blockquote>
</li>
<li><p>UUID</p>
<blockquote>
<p>使用这个宏的时候，会返回一个唯一<code>ID</code>。具体应用场景待探索。</p>
</blockquote>
</li>
</ul>
<h2 id="如何使用文本宏"><a href="#如何使用文本宏" class="headerlink" title="如何使用文本宏"></a>如何使用文本宏</h2><p>使用文本宏的方式很简单，只需要在文本宏之前和之后添加三条下划线（<code>_</code>）即可，如使用<code>FILENAME</code>文本宏：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">___FILENAME___</span><br></pre></td></tr></table></figure>

<h2 id="如何格式化文本宏的值"><a href="#如何格式化文本宏的值" class="headerlink" title="如何格式化文本宏的值"></a>如何格式化文本宏的值</h2><p>文本宏展开生成的值，不一定符合开发要求，如创建文件时，开发者输入的文件名带有非法的字符。为此，Xcode通过提供修饰符（<code>modifier</code>）来对文本宏的值进行格式化。使用修饰符的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;MACRO&gt;:&lt;modifier&gt;[,&lt;modifier&gt;]…</span><br></pre></td></tr></table></figure>

<p>文本宏和修饰符之间用分号（<code>:</code>）分隔。多个修饰符之间可以用逗号（<code>,</code>）分隔。</p>
<p>把文本宏和特定的修饰符结合起来后，就可以修改文本宏的最终值，如下面这段宏可以删除掉的<code>FILENAME</code>的扩展名以及使用下划线（<code>_</code>）替换掉不符合<code>C标识符</code>的字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FILENAME:deletingPathExtension,identifier</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这时候的<code>FILENAME:deletingPathExtension,identifier</code>等同于<code>FILEBASENAMEASIDENTIFIER</code></p>
</blockquote>
<p>当前Xcode提供的修饰符有：</p>
<ul>
<li><p>identifier</p>
<blockquote>
<p>用下划线（<code>_</code>）替换所有不符合<code>C语言标识符规范</code>的字符。</p>
<p>注：<code>C语言标识符规范</code>只允许使用字母（<code>A-Z</code>, <code>a-z</code>）和数字（<code>0-9</code>）以及下划线（<code>_</code>）</p>
</blockquote>
</li>
<li><p>bundleIdentifier</p>
<blockquote>
<p>用连字符（<code>-</code>）替换所有不符合<code>bundle标识符规范</code>的字符。</p>
<p>注：<code>bundle标识符规范</code>只允许使用字母（<code>A-Z</code>, <code>a-z</code>）和数字（<code>0-9</code>）以及连字符（<code>-</code>）。</p>
</blockquote>
</li>
<li><p>rfc1034Identifier</p>
<blockquote>
<p>用连字符（<code>-</code>）替换所有不符合<a href="https://www.ietf.org/rfc/rfc1034.txt" target="_blank" rel="noopener external nofollow noreferrer"><code>rfc1034标识符规范</code></a>的字符</p>
</blockquote>
</li>
<li><p>xml</p>
<blockquote>
<p>将一些特殊的<code>XML</code>字符用其转义字符替换。如，<code>&lt;</code>会被 <code>&amp;lt</code> 替换。</p>
</blockquote>
</li>
<li><p>deletingLastPathComponent</p>
<blockquote>
<p>从展开的字符串中删除最后一个路径组件 (<code>path component</code>)。</p>
</blockquote>
</li>
<li><p>deletingPathExtension</p>
<blockquote>
<p>从展开的字符串中删除扩展名。</p>
</blockquote>
</li>
<li><p>deletingTrailingDot</p>
<blockquote>
<p>删除所有句子末尾的句点（<code>.</code>）</p>
</blockquote>
</li>
<li><p>lastPathComponent</p>
<blockquote>
<p>仅返回字符最后一个路径组件。</p>
</blockquote>
</li>
<li><p>pathExtension</p>
<blockquote>
<p>返回字符的扩展名。</p>
</blockquote>
</li>
</ul>
<p>​    </p>
<h2 id="文本宏的应用"><a href="#文本宏的应用" class="headerlink" title="文本宏的应用"></a>文本宏的应用</h2><p>从Xcode 9.0开始，开发者可以自定义文本宏（覆盖已有的文本宏或者添加新的文本宏）。但是，实际开发中，文本宏的应用场景很少，目前暂时只发现了2个应用场景（若有其他场景，欢迎补充）：</p>
<ul>
<li>自定义文件头部注释</li>
<li>给创建的类都添加统一前缀</li>
</ul>
<p>下面将会演示如何如何实现上述场景。</p>
<p>但是，<strong>在这之前，开发者需要创建一个名为<code>IDETemplateMacros.plist</code>的文件，并把文件放置在下面文件目录列表中的一个</strong>：</p>
<blockquote>
<p>注意：</p>
<ul>
<li>不同位置具有不同的影响范围。</li>
<li><code>IDETemplateMacros.plist</code>文件可以放置到以下几个位置中的任何一个。但是建议只放置在一个地方。</li>
<li>当存在多个<code>IDETemplateMacros.plist</code>文件时，Xcode只会使用最先找到的<code>IDETemplateMacros.plist</code>。</li>
</ul>
</blockquote>
<ul>
<li><p><code>Project user data</code>位置:</p>
<p>  <code>&lt;ProjectName&gt;.xcodeproj/xcuserdata/[username].xcuserdatad/IDETemplateMacros.plist</code></p>
<p>  影响范围：对当前 Project 指定的用户（username）创建的文件有影响</p>
</li>
<li><p><code>Project shared data</code>位置:</p>
<p>  <code>&lt;ProjectName&gt;.xcodeproj/xcshareddata/IDETemplateMacros.plist</code></p>
<p>  影响范围：对当前 Project 的所有成员创建的文件有影响</p>
</li>
<li><p><code>Workspace user data</code>位置:</p>
<p>  <code>&lt;WorkspaceName&gt;.xcworkspace/xcuserdata/[username].xcuserdatad/IDETemplateMacros.plist</code></p>
<p>  影响范围：对当前的 Workspace 下的指定的用户（username）创建的文件有影响</p>
</li>
<li><p><code>Workspace shared data</code>位置:</p>
<p>  <code>&lt;WorkspaceName&gt;.xcworkspace/xcshareddata/IDETemplateMacros.plist</code></p>
<p>  影响范围：对当前 Workspace 下的所有成员创建的文件有影响</p>
</li>
<li><p><code>User Xcode data</code>位置:</p>
<p>  <code>~/Library/Developer/Xcode/UserData/IDETemplateMacros.plist</code></p>
<p>  影响范围：对当前 Xcode 创建的文件都有影响</p>
</li>
</ul>
<h3 id="自定义文件头部注释"><a href="#自定义文件头部注释" class="headerlink" title="自定义文件头部注释"></a>自定义文件头部注释</h3><p>Xcode文件模板中，使用<code>FILEHEADER</code>文本宏来展开生成头部注释，所以只需要在<code>IDETemplateMacros.plist</code>中重定义<code>FILEHEADER</code>即可。编辑后的<code>IDETemplateMacros.plist</code>如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Apple//DTD PLIST 1.0//EN"</span> <span class="meta-string">"http://www.apple.com/DTDs/PropertyList-1.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>FILEHEADER<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span></span><br><span class="line">//                         __   _,--="=--,_   __</span><br><span class="line">//                        /  \."    .-.    "./  \</span><br><span class="line">//                       /  ,/  _   : :   _  \/` \</span><br><span class="line">//                       \  `| /o\  :_:  /o\ |\__/</span><br><span class="line">//                        `-'| :="~` _ `~"=: |</span><br><span class="line">//                           \`     (_)     `/</span><br><span class="line">//                    .-"-.   \      |      /   .-"-.</span><br><span class="line">//.------------------&#123;     &#125;--|  /,.-'-.,\  |--&#123;     &#125;-----------------.</span><br><span class="line">// )                 (_)_)_)  \_/`~-===-~`\_/  (_(_(_)                (</span><br><span class="line">//                                                                     </span><br><span class="line">//		File Name:		___FILENAME___</span><br><span class="line">//		Product Name:	___PRODUCTNAME___</span><br><span class="line">//		Author:			___AUTHOR___</span><br><span class="line">//		Swift Version:	___DEFAULTTOOLCHAINSWIFTVERSION___</span><br><span class="line">//		Created Date:	___DATETIME___</span><br><span class="line">//		</span><br><span class="line">//		Copyright © ___YEAR___ ___ORGANIZATIONNAME___.</span><br><span class="line">//		All rights reserved.</span><br><span class="line">// )                                                                  (</span><br><span class="line">//'--------------------------------------------------------------------'</span><br><span class="line">	<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>AUTHOR<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>___USERNAME___@___ORGANIZATIONNAME___<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>DATETIME<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>___DATE___ ___TIME___<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：示例中不止是重定义<code>FILEHEADER</code>，还新增了新的文本宏<code>AUTHOR</code>和<code>DATETIME</code>。</p>
</blockquote>
<p>这时候使用Xcode创建的文本文件的头部注释如下：</p>
<p><img src="/2018/Xcode%20%E6%96%87%E6%9C%AC%E5%AE%8F%EF%BC%88Text%20Macros%EF%BC%89%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%BA%94%E7%94%A8/readme/FILEHEADER%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<blockquote>
<p>注释中的<code>dog</code>图形是使用命令行字符形状工具<a href="https://boxes.thomasjensen.com/" target="_blank" rel="noopener external nofollow noreferrer"><code>boxes</code></a>生成。</p>
<p><code>boxes</code>支持创建各种字符形状，有兴趣的童鞋不妨去探索下。</p>
</blockquote>
<h3 id="给创建的类都添加统一前缀"><a href="#给创建的类都添加统一前缀" class="headerlink" title="给创建的类都添加统一前缀"></a>给创建的类都添加统一前缀</h3><p>Xcode文件模板中，使用<code>FILEBASENAMEASIDENTIFIER</code>文本宏来展开生成类名，所以只需要在<code>IDETemplateMacros.plist</code>中重定义<code>FILEBASENAMEASIDENTIFIER</code>即可。编辑后的<code>IDETemplateMacros.plist</code>如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Apple//DTD PLIST 1.0//EN"</span> <span class="meta-string">"http://www.apple.com/DTDs/PropertyList-1.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>FILEBASENAMEASIDENTIFIER<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>YK___FILENAME:deletingPathExtension,identifier___<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这时候使用Xcode创建的一个类时，类的前缀都是以<code>YK</code>开头，如图所示：</p>
<p><img src="/2018/Xcode%20%E6%96%87%E6%9C%AC%E5%AE%8F%EF%BC%88Text%20Macros%EF%BC%89%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%BA%94%E7%94%A8/readme/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://help.apple.com/xcode/mac/9.0/index.html" target="_blank" rel="noopener external nofollow noreferrer">《Xcode Help》</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS WebView生成长截图的第三种解决方案</title>
    <url>/2018/iOS%20WebView%E7%94%9F%E6%88%90%E9%95%BF%E6%88%AA%E5%9B%BE%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于项目需要，新近实现了一个长截图库 <a href="https://github.com/YK-Unit/SnapshotKit" target="_blank" rel="noopener">SnapshotKit</a>。其中，需要支持 <code>UIWebView</code>、<code>WKWebView</code> 组件生成长截图。为了实现这个特性，查阅了很多资料，同时也做了不同的新奇思路尝试，最终实现了一个新的、取巧的技术方案。</p>
<p>以下主要总结了在“WebView生成长截图”需求方面，“网上已有方案”和“我的全新方案”的各自实现要点和优缺点。</p>
<a id="more"></a>

<h2 id="WebView生成长截图的已有方案"><a href="#WebView生成长截图的已有方案" class="headerlink" title="WebView生成长截图的已有方案"></a>WebView生成长截图的已有方案</h2><p>根据 Google 所搜索到的资料，目前iOS WebView生成长截图的方案主要有2种：</p>
<ul>
<li>方案一：修改Frame，截图组件</li>
<li>方案二：分页截图组件内容，合成长图</li>
</ul>
<p>下面将会简述方案一和方案二的具体实现。</p>
<h3 id="方案一：修改Frame，截图组件"><a href="#方案一：修改Frame，截图组件" class="headerlink" title="方案一：修改Frame，截图组件"></a>方案一：修改Frame，截图组件</h3><p>方案一的实现要点在于：修改 <code>webView.scrollView</code> 的 <code>frameSize</code>  为 <code>contentSize</code>，然后对整个 <code>webView.scrollView</code> 进行截图。</p>
<p>不过，这个方案只适用 <code>UIWebView</code> 组件，因为其是一次性加载网页所有的内容。而 <code>WKWebView</code> 组件，为了节省内存，加载网页内容时，只加载可视部分——这一点类似 <code>UITableView</code> 组件。在修改<code>webView.scrollView</code> 的 <code>frameSize</code> 后，立即执行了截图操作， 这时候，<code>WKWebView</code>由于还没把网页的内容加载出来，导致生成的长截图是空白的。</p>
<p>方案一核心代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIScrollView</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">takeSnapshotOfFullContent</span><span class="params">()</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> originalFrame = <span class="keyword">self</span>.frame</span><br><span class="line">        <span class="keyword">let</span> originalOffset = <span class="keyword">self</span>.contentOffset</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.frame = <span class="type">CGRect</span>.<span class="keyword">init</span>(origin: originalFrame.origin, size: <span class="keyword">self</span>.contentSize)</span><br><span class="line">        <span class="keyword">self</span>.contentOffset = .zero</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> backgroundColor = <span class="keyword">self</span>.backgroundColor ?? <span class="type">UIColor</span>.white</span><br><span class="line"></span><br><span class="line">        <span class="type">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.bounds.size, <span class="literal">true</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        context.setFillColor(backgroundColor.cgColor)</span><br><span class="line">        context.setStrokeColor(backgroundColor.cgColor)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.drawHierarchy(<span class="keyword">in</span>: <span class="keyword">self</span>.bounds, afterScreenUpdates: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.frame = originalFrame</span><br><span class="line">        <span class="keyword">self</span>.contentOffset = originalOffset</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example code</span></span><br><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">takeSnapshotOfUIWebView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> image = <span class="keyword">self</span>.webView.scrollView.takeSnapshotOfFullContent()</span><br><span class="line">   <span class="comment">// 处理image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方案二：分页截图组件内容，合成长图"><a href="#方案二：分页截图组件内容，合成长图" class="headerlink" title="方案二：分页截图组件内容，合成长图"></a>方案二：分页截图组件内容，合成长图</h3><p>方案二的实现要点在于：分页滚动WebView组件的内容，然后生成分页截图，最后把所有分页截图合成一张长图。</p>
<p>这个方案适用于 <code>UIWebView</code> 组件和 <code>WKWebView</code> 组件。</p>
<p>方案二核心代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIScrollView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">takeScreenshotOfFullContent</span><span class="params">(<span class="number">_</span> completion: @escaping <span class="params">(<span class="params">(UIImage?)</span></span></span></span> -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line">        <span class="comment">// 分页绘制内容到ImageContext</span></span><br><span class="line">        <span class="keyword">let</span> originalOffset = <span class="keyword">self</span>.contentOffset</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当contentSize.height&lt;bounds.height时，保证至少有1页的内容绘制</span></span><br><span class="line">        <span class="keyword">var</span> pageNum = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.contentSize.height &gt; <span class="keyword">self</span>.bounds.height &#123;</span><br><span class="line">            pageNum = <span class="type">Int</span>(floorf(<span class="type">Float</span>(<span class="keyword">self</span>.contentSize.height / <span class="keyword">self</span>.bounds.height)))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> backgroundColor = <span class="keyword">self</span>.backgroundColor ?? <span class="type">UIColor</span>.white</span><br><span class="line"></span><br><span class="line">        <span class="type">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.contentSize, <span class="literal">true</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>() <span class="keyword">else</span> &#123;</span><br><span class="line">            completion(<span class="literal">nil</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        context.setFillColor(backgroundColor.cgColor)</span><br><span class="line">        context.setStrokeColor(backgroundColor.cgColor)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.drawScreenshotOfPageContent(<span class="number">0</span>, maxIndex: pageNum) &#123;</span><br><span class="line">            <span class="keyword">let</span> image = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">            <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">            <span class="keyword">self</span>.contentOffset = originalOffset</span><br><span class="line">            completion(image)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">drawScreenshotOfPageContent</span><span class="params">(<span class="number">_</span> index: Int, maxIndex: Int, completion: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.setContentOffset(<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="type">CGFloat</span>(index) * <span class="keyword">self</span>.frame.size.height), animated: <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">let</span> pageFrame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="type">CGFloat</span>(index) * <span class="keyword">self</span>.frame.size.height, width: <span class="keyword">self</span>.bounds.size.width, height: <span class="keyword">self</span>.bounds.size.height)</span><br><span class="line"></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + <span class="number">0.3</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.drawHierarchy(<span class="keyword">in</span>: pageFrame, afterScreenUpdates: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> index &lt; maxIndex &#123;</span><br><span class="line">                <span class="keyword">self</span>.drawScreenshotOfPageContent(index + <span class="number">1</span>, maxIndex: maxIndex, completion: completion)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                completion()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example code</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">takeSnapshotOfUIWebView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.uiWebView.scrollView.takeScreenshotOfFullContent &#123; (image) <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// 处理image</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">takeSnapshotOfWKWebView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.wkWebView.scrollView.takeScreenshotOfFullContent &#123; (image) <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// 处理image</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WebView生成长截图的新方案"><a href="#WebView生成长截图的新方案" class="headerlink" title="WebView生成长截图的新方案"></a>WebView生成长截图的新方案</h2><p>除了方案一和方案二，还有新方案吗？</p>
<p>答案是肯定加确定以及一定的。</p>
<p>这个新方案的要点在于：iOS系统的WebView打印功能。</p>
<p>iOS系统支持把WebView的内容打印到PDF文件上，借助这个特性，新方案的设计如下：</p>
<ol>
<li><p>把 WebView组件的内容全部打印到一页PDF上</p>
</li>
<li><p>把PDF转换成图片</p>
</li>
</ol>
<p>新方案的核心代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> WebKit</span><br><span class="line"></span><br><span class="line"><span class="comment">/// WebViewPrintPageRenderer: use to print the full content of webview into one image</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewPrintPageRenderer</span>: <span class="title">UIPrintPageRenderer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> formatter: <span class="type">UIPrintFormatter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> contentSize: <span class="type">CGSize</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 生成PrintPageRenderer实例</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - formatter: WebView的viewPrintFormatter</span></span><br><span class="line">    <span class="comment">///   - contentSize: WebView的ContentSize</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(formatter: <span class="type">UIPrintFormatter</span>, contentSize: <span class="type">CGSize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.formatter = formatter</span><br><span class="line">        <span class="keyword">self</span>.contentSize = contentSize</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.addPrintFormatter(formatter, startingAtPageAt: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> paperRect: <span class="type">CGRect</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGRect</span>.<span class="keyword">init</span>(origin: .zero, size: contentSize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> printableRect: <span class="type">CGRect</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGRect</span>.<span class="keyword">init</span>(origin: .zero, size: contentSize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">printContentToPDFPage</span><span class="params">()</span></span> -&gt; <span class="type">CGPDFPage?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="type">NSMutableData</span>()</span><br><span class="line">        <span class="type">UIGraphicsBeginPDFContextToData</span>(data, <span class="keyword">self</span>.paperRect, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">self</span>.prepare(forDrawingPages: <span class="type">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">let</span> bounds = <span class="type">UIGraphicsGetPDFContextBounds</span>()</span><br><span class="line">        <span class="type">UIGraphicsBeginPDFPage</span>()</span><br><span class="line">        <span class="keyword">self</span>.drawPage(at: <span class="number">0</span>, <span class="keyword">in</span>: bounds)</span><br><span class="line">        <span class="type">UIGraphicsEndPDFContext</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> cfData = data <span class="keyword">as</span> <span class="type">CFData</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> provider = <span class="type">CGDataProvider</span>.<span class="keyword">init</span>(data: cfData) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> pdfDocument = <span class="type">CGPDFDocument</span>.<span class="keyword">init</span>(provider)</span><br><span class="line">        <span class="keyword">let</span> pdfPage = pdfDocument?.page(at: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pdfPage</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">covertPDFPageToImage</span><span class="params">(<span class="number">_</span> pdfPage: CGPDFPage)</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pageRect = pdfPage.getBoxRect(.trimBox)</span><br><span class="line">        <span class="keyword">let</span> contentSize = <span class="type">CGSize</span>.<span class="keyword">init</span>(width: floor(pageRect.size.width), height: floor(pageRect.size.height))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// usually you want UIGraphicsBeginImageContextWithOptions last parameter to be 0.0 as this will us the device's scale</span></span><br><span class="line">        <span class="type">UIGraphicsBeginImageContextWithOptions</span>(contentSize, <span class="literal">true</span>, <span class="number">2.0</span>)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.setFillColor(<span class="type">UIColor</span>.white.cgColor)</span><br><span class="line">        context.setStrokeColor(<span class="type">UIColor</span>.white.cgColor)</span><br><span class="line">        context.fill(pageRect)</span><br><span class="line"></span><br><span class="line">        context.saveGState()</span><br><span class="line">        context.translateBy(x: <span class="number">0</span>, y: contentSize.height)</span><br><span class="line">        context.scaleBy(x: <span class="number">1.0</span>, y: -<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">        context.interpolationQuality = .low</span><br><span class="line">        context.setRenderingIntent(.defaultIntent)</span><br><span class="line">        context.drawPDFPage(pdfPage)</span><br><span class="line">        context.restoreGState()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// print the full content of webview into one image</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Important: if the size of content is very large, then the size of image will be also very large</span></span><br><span class="line">    <span class="comment">/// - Returns: UIImage?</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">printContentToImage</span><span class="params">()</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> pdfPage = <span class="keyword">self</span>.printContentToPDFPage() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> image = <span class="keyword">self</span>.covertPDFPageToImage(pdfPage)</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIWebView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">takeScreenshotOfFullContent</span><span class="params">(<span class="number">_</span> completion: @escaping <span class="params">(<span class="params">(UIImage?)</span></span></span></span> -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line">        <span class="keyword">self</span>.scrollView.setContentOffset(<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>), animated: <span class="literal">false</span>)</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + <span class="number">0.3</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> renderer = <span class="type">WebViewPrintPageRenderer</span>.<span class="keyword">init</span>(formatter: <span class="keyword">self</span>.viewPrintFormatter(), contentSize: <span class="keyword">self</span>.scrollView.contentSize)</span><br><span class="line">            <span class="keyword">let</span> image = renderer.printContentToImage()</span><br><span class="line">            completion(image)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WKWebView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">takeScreenshotOfFullContent</span><span class="params">(<span class="number">_</span> completion: @escaping <span class="params">(<span class="params">(UIImage?)</span></span></span></span> -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line">        <span class="keyword">self</span>.scrollView.setContentOffset(<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>), animated: <span class="literal">false</span>)</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + <span class="number">0.3</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> renderer = <span class="type">WebViewPrintPageRenderer</span>.<span class="keyword">init</span>(formatter: <span class="keyword">self</span>.viewPrintFormatter(), contentSize: <span class="keyword">self</span>.scrollView.contentSize)</span><br><span class="line">            <span class="keyword">let</span> image = renderer.printContentToImage()</span><br><span class="line">            completion(image)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WebViewPrintPageRenderer</code> 是该方案的核心类，负责把 <code>WebView组件</code>内容打印到PDF，然后把PDF转换为图片。</p>
<p><code>UIWebView</code> 和 <code>WKWebView</code> 则实现对应的扩展。</p>
<p>测试代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example code</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">takeSnapshotOfUIWebView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.uiWebView.scrollView.takeScreenshotOfFullContent &#123; (image) <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// 处理image</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">takeSnapshotOfWKWebView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.wkWebView.scrollView.takeScreenshotOfFullContent &#123; (image) <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// 处理image</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三种技术方案优劣对比"><a href="#三种技术方案优劣对比" class="headerlink" title="三种技术方案优劣对比"></a>三种技术方案优劣对比</h2><p>那么，这三种技术方案各自存在什么优缺点呢，适用什么场景呢？</p>
<ul>
<li>方案一：只适用 <code>UIWebView</code>；若网页内容很多，生成长截图时，会占用过多内存。 所以，该方案只适合不需要支持 <code>WKWebView</code>， 且网页内容不会太多的场景。</li>
<li>方案二：适用 <code>UIWebView</code> 和 <code>WKWebView</code>，且特别适合 <code>WKWebView</code>。由于采用分页生成截图机制，有效减少内存占用。不过，这个方案存在一个问题：若网页存在 <code>position: fixed</code> 的元素（如网页头部固定的导航栏），该元素会重复出现在生成的长图上。</li>
<li>方案三：适用 <code>UIWebView</code> 和 <code>WKWebView</code>。其中最重要的一步——“把WebView内容打印到PDF” 是由iOS系统实现，所以该方案的性能在理论上是可以得到保障的。不过，这个方案存在一个问题：在把网页内容打印到PDF时，iOS系统获取的 <code>contentSize</code> 比WebView的实际<code>contentSize</code> 要大，从而导致生成的图片在靠近底部的内容部分和实际存在一点差异。具体可以下载运行我的长截图库 <a href="https://github.com/YK-Unit/SnapshotKit" target="_blank" rel="noopener">SnapshotKit</a> 的 Demo，通过其中的 <code>UIWebView</code> 和 <code>WKWebView</code> 截图示例查看具体截图效果。</li>
</ul>
<p>以上三个方案，总的来说，解决了部分场景的需求，但都不够完美，仍需做进一步的优化。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter：网易智造APP的JSON和模型类相互转换方案</title>
    <url>/2019/Flutter%EF%BC%9A%E7%BD%91%E6%98%93%E6%99%BA%E9%80%A0APP%E7%9A%84JSON%E5%92%8C%E6%A8%A1%E5%9E%8B%E7%B1%BB%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%A1%88/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为减少手写实现JSON和模型类相互转换的序列化、反序列化代码，我们使用了官方推荐的<a href="https://github.com/dart-lang/json_serializable" target="_blank" rel="noopener">json_serializable</a>方案。</p>
<p>同时为了解决<code>json_serializable</code>方案需要手动写为模型类写<code>from/to json</code>的代码的问题，我们引入了代码片段的解决方案。</p>
<p>下面将会对该方案进行具体描述。</p>
<blockquote>
<ul>
<li>该方案同时适用于VSCode和Android Studio；</li>
<li>下文在描述该方案时，只介绍了VSCode端的实施步骤；</li>
<li>在Android Studio落地该方案时，只需要把涉及VSCode端的实施对等转换为Android Studio端的实施即可：比如“为VSCode添加代码片段”转换为“为Android Studio添加代码片段”。</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="一、-为VSCode添加代码片段"><a href="#一、-为VSCode添加代码片段" class="headerlink" title="一、 为VSCode添加代码片段"></a>一、 为VSCode添加代码片段</h2><p>请按照以下顺序为VSCode创建代码模板<code>dart_model_class.code-snippets</code>:</p>
<ol>
<li><p>打开 File -&gt; Preferences -&gt; User Snippets ( 在macOS上 Code -&gt; Preferences -&gt; User Snippets)</p>
</li>
<li><p>选择 New Global Snippets file 选项，点击选择</p>
</li>
<li><p>在弹窗框内输入<code>dart_model_class.code-snippets</code>，然后保存</p>
</li>
<li><p>在代码编辑栏里编辑刚才创建的<code>dart_model_class.code-snippets</code>文件，输入以下内容：</p>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dmc import"</span>: &#123;</span><br><span class="line">    <span class="attr">"prefix"</span>: <span class="string">"dmc import"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"add the imports for dart model class"</span>,</span><br><span class="line">    <span class="attr">"body"</span>: [</span><br><span class="line">      <span class="string">""</span>,</span><br><span class="line">      <span class="string">"import 'package:json_annotation/json_annotation.dart';"</span>,</span><br><span class="line">      <span class="string">"part '$&#123;1:$TM_FILENAME_BASE&#125;.g.dart';"</span>,</span><br><span class="line">      <span class="string">""</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"from/to json"</span>: &#123;</span><br><span class="line">    <span class="attr">"prefix"</span>: <span class="string">"dmc class"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"generate the dart model class template code"</span>,</span><br><span class="line">    <span class="attr">"body"</span>: [</span><br><span class="line">      <span class="string">"@JsonSerializable()"</span>,</span><br><span class="line">	  <span class="string">"class $&#123;1:ClassName&#125; &#123;"</span>,</span><br><span class="line">	  <span class="string">""</span>,</span><br><span class="line">	  <span class="string">"    // deserialize json to an instance"</span>,</span><br><span class="line">	  <span class="string">"    factory $&#123;1:ClassName&#125;.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$$&#123;1:ClassName&#125;FromJson(json);"</span>,</span><br><span class="line">	  <span class="string">"    // serialize an instance to a map"</span>,</span><br><span class="line">	  <span class="string">"    Map&lt;String, dynamic&gt; toJson() =&gt; _$$&#123;1:ClassName&#125;ToJson(this);"</span>,</span><br><span class="line">	  <span class="string">""</span>,</span><br><span class="line">	  <span class="string">"    // TODO: add a member for your class"</span>,</span><br><span class="line">	  <span class="string">""</span>,</span><br><span class="line">	  <span class="string">"&#125;"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="二、为Flutter项目添加依赖"><a href="#二、为Flutter项目添加依赖" class="headerlink" title="二、为Flutter项目添加依赖"></a>二、为Flutter项目添加依赖</h2><p>在pubspec.yaml中添加如下依赖：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="comment"># Your other regular dependencies here</span></span><br><span class="line">  <span class="attr">json_annotation:</span> <span class="string">^3.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dev_dependencies:</span></span><br><span class="line">  <span class="comment"># Your other dev_dependencies here</span></span><br><span class="line">  <span class="attr">build_runner:</span> <span class="string">^1.0.0</span></span><br><span class="line">  <span class="attr">json_serializable:</span> <span class="string">^3.2.0</span></span><br></pre></td></tr></table></figure>

<h2 id="三、使用代码片段创建模型类"><a href="#三、使用代码片段创建模型类" class="headerlink" title="三、使用代码片段创建模型类"></a>三、使用代码片段创建模型类</h2><ol>
<li><p>通过代码片段<code>dmc import</code>添加依赖：</p>
 <figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">FileName: item.dart</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:json_annotation/json_annotation.dart'</span>;</span><br><span class="line"><span class="keyword">part</span> <span class="string">'item.g.dart'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过代码片段<code>dmc class</code>添加模板模型类：</p>
 <figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonSerializable</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// deserialize json to an instance</span></span><br><span class="line">   <span class="keyword">factory</span> ClassName.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; json) =&gt; _$ClassNameFromJson(json);</span><br><span class="line">   <span class="comment">// serialize an instance to a map</span></span><br><span class="line">   <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; toJson() =&gt; _$ClassNameToJson(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> add your member</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编辑模板类，把<code>ClassName</code>修改你的模型类名称，并根据JSON添加对应成员，最后如下：</p>
 <figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/// <span class="markdown">FileName: item.dart</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:json_annotation/json_annotation.dart'</span>;</span><br><span class="line"><span class="keyword">part</span> <span class="string">'item.g.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonSerializable</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// deserialize json to an instance</span></span><br><span class="line">   <span class="keyword">factory</span> Item.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; json) =&gt; _$ItemFromJson(json);</span><br><span class="line">   <span class="comment">// serialize an instance to a map</span></span><br><span class="line">   <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; toJson() =&gt; _$ItemToJson(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> add a member for your class</span></span><br><span class="line">    <span class="built_in">int</span> cout;</span><br><span class="line"></span><br><span class="line">    Item();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>完整效果可看此动图：</p>
<p><img src="/2019/Flutter%EF%BC%9A%E7%BD%91%E6%98%93%E6%99%BA%E9%80%A0APP%E7%9A%84JSON%E5%92%8C%E6%A8%A1%E5%9E%8B%E7%B1%BB%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%A1%88/readme/code-snippets-example.gif" alt="image"></p>
<h2 id="四、运行build-runner为所有模型类生成对应的JSON解析类"><a href="#四、运行build-runner为所有模型类生成对应的JSON解析类" class="headerlink" title="四、运行build_runner为所有模型类生成对应的JSON解析类"></a>四、运行<code>build_runner</code>为所有模型类生成对应的JSON解析类</h2><p>在Flutter根目录下运行<code>flutter packages pub run build_runner build</code>，为当前工程中所有所有模型类生成对应的JSON解析类。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>大前端&quot;</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>FP探索</title>
    <url>/2020/FP%E6%8E%A2%E7%B4%A2/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要是对计算机科学领域中的函数式编程（英语：Functional Programming）范式的理论、特性及特性的实现方案进行探索。</p>
<a id="more"></a>

<h2 id="如何实现-Fist-Class-Function"><a href="#如何实现-Fist-Class-Function" class="headerlink" title="如何实现 Fist-Class Function"></a>如何实现 Fist-Class Function</h2><p>函数式编程范式的核心思想是：<code>Fist-Class Function</code>，即函数作为一等公民，可以作为别的函数的参数、函数的返回值，赋值给变量或存储在数据结构中。</p>
<p>实现<code>Fist-Class Function</code>的方案主要有3种：</p>
<ul>
<li><p>指针（Pointer）</p>
<ul>
<li><p>实现：使用函数指针代替函数进行一等公民的相关操作（入参、赋值等）。</p>
</li>
<li><p>优点：实现简单。</p>
</li>
<li><p>缺点：只适合支持指针的编程语言；函数需要提前定义且无法直接访问函数外部环境（指针变量定义处的环境）的局部变量。</p>
</li>
</ul>
</li>
<li><p>函数对象（Function Object）</p>
<ul>
<li><p>实现：使用对象模拟函数，然后使用对象代替函数进行一等公民的相关操作（入参、赋值等）。</p>
</li>
<li><p>优点：实现简单；可携带状态。</p>
</li>
<li><p>缺点：函数需要提前定义且无法直接访问函数外部环境（函数对象变量定义处的环境）的局部变量（对于不支持匿名类方式的编程语言）；代码形式上和函数定义相差较多。</p>
</li>
</ul>
</li>
<li><p>闭包（Closure）</p>
<ul>
<li><p>实现：构造一个名为闭包的数据结构实体存储函数的指针和函数依赖的环境（环境的作用是为函数中的自由变量提供绑定信息），然后使用闭包代替函数进行一等公民的相关操作（入参、赋值等）。</p>
</li>
<li><p>优点：函数可以在使用时才定义；函数可直接访问函数外部环境（闭包定义处的环境）的局部变量；代码形式上和函数定义相近；闭包由编译器在词法分析阶段自动构造生成（指针和函数对象需要手动构造）</p>
</li>
<li><p>缺点：实现相对复杂，需要编程语言的编译器在词法闭包解析的操作上增加为闭包增加“捕获”变量的特性。</p>
</li>
</ul>
</li>
</ul>
<h2 id="实现方案之函数对象（Function-Object）"><a href="#实现方案之函数对象（Function-Object）" class="headerlink" title="实现方案之函数对象（Function Object）"></a>实现方案之函数对象（Function Object）</h2><p>函数对象的设计思想是：构造一个具备函数特征的对象代替普通函数，然后像调用普通函数那样调用对象。</p>
<p>而上述中所谓“函数特征”，其定义和实现由具体由语言设计者确定，一般来说，该特征表现为：（基于类的编程语言中）对象需要实现或者<code>override</code>指定的方法。</p>
<p>比如，在C++ 中，函数对象由<code>override</code>了运算符方法<code>operator()</code>的类表示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;    // std::sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;       // std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;     // std::ostream_iterator</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator predicate: returns true if a &lt; b, false otherwise</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntComparator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; items &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), IntComparator());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::copy(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">" "</span>)); <span class="comment">// -&gt; 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又比如，在Java 中，函数对象由只有一个方法的接口（比如最常见的<code>Comparator Interface</code>、<code>Callable Interface</code>和<code>Runnable Interface</code>等）表示，该接口在实现上多表现为匿名类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] array = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    Comparator&lt;Integer&gt; numComparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer num1, Integer num2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num1.compareTo(num2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Arrays.sort(array, numComparator);</span><br><span class="line">    </span><br><span class="line">    System.out.println(Arrays.toString(array)); <span class="comment">// -&gt; [1, 2, 3, 4]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Function_object" target="_blank" rel="noopener external nofollow noreferrer">WiKi-《Function object》</a></li>
</ul>
<h2 id="实现方案之闭包（Closure）"><a href="#实现方案之闭包（Closure）" class="headerlink" title="实现方案之闭包（Closure）"></a>实现方案之闭包（Closure）</h2><blockquote>
<p>下面对闭包的描述抛开了闭包的发展历史和闭包在数学领域的概念，仅仅是从计算机科学的工程角度进行描述。</p>
</blockquote>
<p>函数作为一等公民，要像整数、字符串这些普通数据一样在使用时才进行定义，就必须要解决一个问题：自由变量的绑定的问题。具体来说，就是一个函数创建后，其使用了一个定义在函数体外的变量（即自由变量），当该函数脱离当前环境后，传递到另一个环境运行时，该如何获得这个自由变量关联的数据？</p>
<blockquote>
<p>自由变量是指：函数体中的除了参数和局部变量之外的变量；简单说就是定义在函数体外的变量。</p>
<p>绑定是指：把标识符与实体（数据和/或代码）关联起来。</p>
<p>自由变量的绑定是指：把代表自由变量的标识符和数据关联起来，简单理解就是给自由变量指定值</p>
</blockquote>
<p>下面将通过一个简化的场景例子对该问题进行详细说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设存在一个支持运行下列的伪代码的计算系统</span><br><span class="line">&#x2F;&#x2F; 假设当前计算系统支持直接传递函数传递到不同作用域</span><br><span class="line">&#x2F;&#x2F; 假设当前计算系统存在有2个作用域：SCOPE-1 和 SCOPE-2</span><br><span class="line"></span><br><span class="line">+--------------------+   </span><br><span class="line">| &#x2F;&#x2F; SCOPE-1         |  </span><br><span class="line">|                    |</span><br><span class="line">| y &#x3D; 1;             |</span><br><span class="line">| f(x) &#123;             |</span><br><span class="line">|   retrun x + y;    |</span><br><span class="line">| &#125;;                 |</span><br><span class="line">|                    |</span><br><span class="line">| f(1); &#x2F;&#x2F; -&gt; 2      |</span><br><span class="line">+--------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+--------------------+   </span><br><span class="line">| &#x2F;&#x2F; SCOPE-2         |  </span><br><span class="line">|                    |</span><br><span class="line">|                    |</span><br><span class="line">|                    |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>

<p>在<code>SCOPE-1</code>中，存在一个局部变量<code>y</code>和一个函数<code>f</code>，<code>y</code>是<code>f</code>的自由变量，在离开<code>SCOPE-1</code>后，<code>y</code>就不存在了——这意味着函数<code>f</code>传递到<code>SCOPE-2</code>后，会因无法确定<code>y</code>绑定的值，从而导致运算出错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------------+   </span><br><span class="line">| &#x2F;&#x2F; SCOPE-1         |  </span><br><span class="line">|                    |</span><br><span class="line">| y &#x3D; 1;             |</span><br><span class="line">|                    |</span><br><span class="line">| +----------------+ |</span><br><span class="line">| |f(x) &#123;          | |</span><br><span class="line">| |  retrun x + y; |-|----\</span><br><span class="line">| |&#125;;              | |    |</span><br><span class="line">| +----------------+ |    |</span><br><span class="line">|                    |    |</span><br><span class="line">| f(1); &#x2F;&#x2F; -&gt; 2      |    |</span><br><span class="line">+--------------------+    |</span><br><span class="line">                          |</span><br><span class="line">                          | pass function f</span><br><span class="line">                          |</span><br><span class="line">+--------------------+    |   </span><br><span class="line">| &#x2F;&#x2F; SCOPE-2         |    |  </span><br><span class="line">|                    |&lt;---&#x2F;</span><br><span class="line">| f(1); &#x2F;&#x2F; -&gt; error  |</span><br><span class="line">|                    |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>

<p>那么该如何解决呢？把函数<code>f</code>和自由变量<code>y</code>打包一起，传递到<code>SCOPE-2</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------------+   </span><br><span class="line">| &#x2F;&#x2F; SCOPE-1         |  </span><br><span class="line">|                    |</span><br><span class="line">| +----------------+ |</span><br><span class="line">| |y &#x3D; 1;          | |</span><br><span class="line">| |f(x) &#123;          | |</span><br><span class="line">| |  retrun x + y; |-|----\</span><br><span class="line">| |&#125;;              | |    |</span><br><span class="line">| +----------------+ |    |</span><br><span class="line">|                    |    |</span><br><span class="line">| f(1); &#x2F;&#x2F; -&gt; 2      |    |</span><br><span class="line">+--------------------+    |</span><br><span class="line">                          |</span><br><span class="line">                          | pass closure &quot;f&quot;</span><br><span class="line">                          |</span><br><span class="line">+--------------------+    |   </span><br><span class="line">| &#x2F;&#x2F; SCOPE-2         |    |  </span><br><span class="line">|                    |&lt;---&#x2F;</span><br><span class="line">| f(1); &#x2F;&#x2F; -&gt; 2      |</span><br><span class="line">|                    |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>

<p>实现这种打包的技术称为闭包，而同时打包的产物也称之为闭包。</p>
<p>在具体实现上，闭包的技术方案大致如下：</p>
<ol>
<li><p>构造一个环境，存储自由变量的绑定信息——这在术语上，又称自由变量被“捕获”了；</p>
<blockquote>
<ul>
<li>绑定信息包括自由变量的符号和自由变量的值，比如<code>{y: 2}</code>；</li>
<li>存储自由变量的值的方式可以是值复制也可以是引用，具体由语言设计者确定；</li>
</ul>
</blockquote>
</li>
<li><p>构造一个数据结构实体，存储函数的指针和该环境——这个数据结构实体就是闭包；</p>
</li>
<li><p>对函数进行转换处理，包括把闭包作为其参数，以及把函数体中的自由变量转化为局部变量（局部变量的值根据自由变量的符号从环境中获得）；</p>
</li>
</ol>
<p>对于支持闭包的编程语言，以上的步骤由编译器在进行词法分析时自动完成，无需手动操作。</p>
<p>如果手动实现，怎么实现呢？下面使用C语言模拟实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">closure_f_env</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">closure_f</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *fp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">closure_f_env</span> <span class="title">env</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">f(x) &#123;</span></span><br><span class="line"><span class="comment">  return x + y;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _f_impl(struct _closure_f *cp, <span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = cp-&gt;env.y;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct _closure_f <span class="title">scope_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">closure_f_env</span> <span class="title">env</span> = &#123;</span>y&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">closure_f</span> <span class="title">f</span> = &#123;</span>&amp;_f_impl, env&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*fp)(struct _closure_f *, <span class="keyword">int</span>) = f.fp;</span><br><span class="line">    <span class="keyword">int</span> result = fp(&amp;f, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nscope_1: "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result); <span class="comment">// -&gt; 2</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scope_2</span><span class="params">(struct _closure_f f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*fp)(struct _closure_f *, <span class="keyword">int</span>) = f.fp;</span><br><span class="line">    <span class="keyword">int</span> result = fp(&amp;f, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nscope_2: "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result); <span class="comment">// -&gt; 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">closure_f</span> <span class="title">f</span> = <span class="title">scope_1</span>();</span></span><br><span class="line">    scope_2(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://www.jianshu.com/p/c22db2a91989" target="_blank" rel="noopener external nofollow noreferrer">《【闭包】你真的理解闭包和lambda表达式吗》</a></li>
<li><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" target="_blank" rel="noopener external nofollow noreferrer">《Closure (computer programming)》</a></li>
<li><a href="https://lotabout.me/2016/thoughts-of-closure/" target="_blank" rel="noopener external nofollow noreferrer">《再谈闭包》</a></li>
<li><a href="http://yungkcx.github.io/jekyll/update/2017/02/07/About-Closure.html" target="_blank" rel="noopener external nofollow noreferrer">《关于编程语言中的闭包》</a></li>
<li><a href="http://matt.might.net/articles/closure-conversion/" target="_blank" rel="noopener external nofollow noreferrer">《Closure conversion: How to compile lambda》</a></li>
<li><a href="https://www.kimsereylam.com/racket/lisp/2019/02/06/lambda-calculus-and-closure.html" target="_blank" rel="noopener external nofollow noreferrer">《Lambda Calculus And Closure》</a></li>
<li><a href="http://banjiewen.net/the-function-of-function-in-lisp.html" target="_blank" rel="noopener external nofollow noreferrer">《Paper: The Function of FUNCTION in LISP》</a></li>
<li><a href="https://www.cs.utexas.edu/ftp/garbage/cs345/schintro-v14/schintro_64.html" target="_blank" rel="noopener external nofollow noreferrer">《Lambda and Lexical Scope (Hunk M)》</a></li>
<li><a href="https://personal.utdallas.edu/~gupta/courses/apl/lambda.pdf" target="_blank" rel="noopener external nofollow noreferrer">《A Tutorial Introduction to the Lambda Calculus》</a></li>
<li><a href="http://www.cs.cornell.edu/courses/cs611/2000fa/slides/lec07.pdf" target="_blank" rel="noopener external nofollow noreferrer">《CS 611<br>Advanced Programming Languages: Lecture 7: Lambda calculus（PPT）》</a></li>
<li><a href="https://liujiacai.net/blog/2014/10/12/lambda-calculus-introduction/" target="_blank" rel="noopener external nofollow noreferrer">《编程语言的基石——Lambda calculus》</a></li>
</ul>
<h3 id="lambda-与-closure-的区别"><a href="#lambda-与-closure-的区别" class="headerlink" title="lambda 与 closure 的区别"></a>lambda 与 closure 的区别</h3><p>在编程语言领域，从底层实现层面上看：</p>
<ul>
<li><p>lambda等同匿名函数</p>
<blockquote>
<p>对于支持lambda的编程语言来讲，lambda第一语义是：支持使用lambda表达式生成匿名函数，lambda第二语义是：使用lambda代称匿名函数</p>
</blockquote>
</li>
<li><p>closure是由函数和其运行环境构成的实体</p>
</li>
</ul>
<p>在编程语言领域，从应用层面上看，由于支持closure的编程语言一般也支持lambda，创建closure时多使用lambda的方式，所以在这二者经常一起出现的情况下，为了简化概念，把closure等同lambda，未尝不可。</p>
<h3 id="柯里化（Currying）"><a href="#柯里化（Currying）" class="headerlink" title="柯里化（Currying）"></a>柯里化（Currying）</h3><p>在数学角度，柯里化就是一个逐次消元的过程。当把函数的元全消掉，就得到了值。值就是零元函数，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二元函数：</span><br><span class="line">f(x,y)&#x3D;x+y</span><br><span class="line"></span><br><span class="line">在x&#x3D;1时，带入得：</span><br><span class="line">g(y)&#x3D;f(1,y)&#x3D;1+y</span><br></pre></td></tr></table></figure>

<p>在编程角度，柯里化可用于把一个多参函数转换为由多个单参函数组成的连锁函数，比如在JavaScript中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f(x, y) = x + y</span></span><br><span class="line"><span class="keyword">var</span> fxy = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"f(1,2) = "</span>, fxy(<span class="number">1</span>)(<span class="number">2</span>)); <span class="comment">// -&gt; f(1,2) = 3</span></span><br></pre></td></tr></table></figure>

<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://www.zhihu.com/question/30097211" target="_blank" rel="noopener external nofollow noreferrer">《如何理解functional programming里的currying与partial application?》</a></li>
<li><a href="https://zh.wikipedia.org/wiki/柯里化" target="_blank" rel="noopener external nofollow noreferrer">WiKi-《柯里化》</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>2020</tag>
        <tag>基础理论</tag>
        <tag>Review</tag>
        <tag>非终稿</tag>
      </tags>
  </entry>
  <entry>
    <title>git submodule版本检测工具：git_submodule_version_checker</title>
    <url>/2019/git%20submodule%E7%89%88%E6%9C%AC%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%EF%BC%9Agit_submodule_version_checker/readme/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近项目由于一些特殊需要，使用了git的submodules工具来引入一个子项目到主项目中。然而考虑submodules工具在团队协作开发的过程中，容易出现子项目版本不一致的问题，于是研发了<a href="https://github.com/YK-Unit/git_submodule_version_checker" target="_blank" rel="noopener">git_submodule_version_checker</a>这款工具来解决。</p>
<blockquote>
<p>1、关于git的submodules工具的介绍可以点击阅读<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener external nofollow noreferrer">《Git 工具 - 子模块》</a>。</p>
<p>2、关于git的submodules工具的优缺点，有兴趣的请直接Google吧，目前网上已经很多资料了。总得来说，其最大的（可能也是唯一的）优点是：允许开发者将一个子项目的git仓库作为主项目git 仓库的子目录，并让子项目保持提交的独立；而其突出的缺点主要有以下几个：</p>
<ul>
<li><p>主项目仓库不记录子项目仓库的文件变动，只记录子项目仓库的commitId，在这个背景下，团队协作开发过程中容易产生子项目版本不一致的问题，具体表现如下：</p>
<ul>
<li>团队协作开发时，若有成员更新了子项目，但是你<code>git pull</code>后，却没有运行<code>git submodule update --remote</code>更新子项目本地仓库，那么你极有可能再次把旧的子项目版本信息（子项目仓库依然指向一个旧的commitId）提交至主项目</li>
<li>团队协作开发时，若你在本地改动了子项目，并在主项目中提交并推送了子项目版本信息，但却没有推送子项目仓库上的改动，这时其他成员在拉取更新后，运行<code>git submodule update</code>时，会遇到“找不到所引用的子模块提交”的错误提示<ul>
<li>每次更新子项目仓库，子项目仓库都会回到游离状态，在这个背景下， 会产生的问题有：</li>
</ul>
</li>
<li>若你已经切换到指定分支，在更新后，需要手动切换分支；</li>
<li>若你对子项目做了修改，但是忘记了提交，这时候执行更新，会导致修改被丢失；</li>
</ul>
</li>
<li><p>子项目仓库总是需要手动更新（不过可以通过自动化工具编写帮助解决此问题）</p>
</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="git-submodule-version-checker"><a href="#git-submodule-version-checker" class="headerlink" title="git_submodule_version_checker"></a>git_submodule_version_checker</h2><p><a href="https://github.com/YK-Unit/git_submodule_version_checker" target="_blank" rel="noopener">git_submodule_version_checker</a>工具使用shell编写，其检测判断一个子项目的版本是否一致的思路如下：</p>
<ol>
<li><p>获取当前子项目的本地仓库当前指向的commitId：<code>submodules_head_commit_id</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule status `&#123;pwd&#125;`/SUBMODULE_PATH | awk '&#123;print $1&#125;'</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取主项目记录的当前子项目的版本commitId：<code>submodules_associated_commit_id</code></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git ls-tree master `&#123;pwd&#125;`/SUBMODULE_PATH | awk '&#123;print $3&#125;'</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断<code>submodules_associated_commit_id</code>是否为空，若为空，说明当前子项目为新增子模块，需要提示开发者在主项目中进行提交；若不为空，则将2个commitId进行比较，若二者一致，则说明当前子项目的版本是一致的</p>
</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh  </span></span><br><span class="line"></span><br><span class="line">function check_submodules_version()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">	#</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">"\033[字背景颜色;字体颜色m 字符串 \033[0m"</span></span></span><br><span class="line">	color_prefix_red="\033[0;31m"</span><br><span class="line">	color_suffix="\033[0m"</span><br><span class="line"></span><br><span class="line">	project_dir=$1</span><br><span class="line">	cd $project_dir</span><br><span class="line">	color_project_dir=$color_prefix_red$project_dir$color_suffix</span><br><span class="line">	echo "cd to repo '$color_project_dir' done"</span><br><span class="line"></span><br><span class="line">	echo "check the version of submodules now ..."</span><br><span class="line"></span><br><span class="line">	cur_branch=$(git symbolic-ref --short -q HEAD)</span><br><span class="line"><span class="meta">	#</span><span class="bash"><span class="built_in">echo</span> <span class="string">"current branch: <span class="variable">$cur_branch</span>"</span></span></span><br><span class="line"></span><br><span class="line">	temp_has_bad_submodule="$project_dir/.temp_has_bad_submodule"</span><br><span class="line">	rm -f temp_has_bad_submodule</span><br><span class="line">	touch temp_has_bad_submodule</span><br><span class="line"></span><br><span class="line">	echo "Here is the all submodules:"</span><br><span class="line"></span><br><span class="line">	git submodule status | while read -r line</span><br><span class="line">	do </span><br><span class="line"><span class="meta">		#</span><span class="bash"> 1. 获取当前子项目的本地仓库当前指向的commitId：submodules_head_commit_id</span></span><br><span class="line">		eval `echo $line | awk '&#123;</span><br><span class="line">	    	printf("submodules_head_commit_id=%s; submodule_name=%s", $1, $2)</span><br><span class="line">		&#125;'`</span><br><span class="line"><span class="meta">		#</span><span class="bash"><span class="built_in">echo</span> <span class="string">"<span class="variable">$submodule_name</span>: <span class="variable">$submodules_head_commit_id</span>"</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">		#</span><span class="bash"> gradle 执行 <span class="string">'git submodule status'</span> 时，submodule_name 前面带有 <span class="string">'../'</span>，非常奇怪</span></span><br><span class="line"><span class="meta">		#</span><span class="bash"> 这个正是用于删除 <span class="string">'../'</span></span></span><br><span class="line">		if [[ $submodule_name == ../* ]]</span><br><span class="line">		then</span><br><span class="line">			submodule_name=$&#123;submodule_name:3&#125;</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line"><span class="meta">		#</span><span class="bash"> 2. 获取主项目记录的当前子项目的版本commitId：submodules_associated_commit_id</span></span><br><span class="line">		submodule_path="$project_dir/$submodule_name"</span><br><span class="line">		eval `git ls-tree $cur_branch $submodule_path  | awk '&#123;</span><br><span class="line">	    	printf("submodules_associated_commit_id=%s", $3)</span><br><span class="line">		&#125;'`</span><br><span class="line"></span><br><span class="line">		color_submodules_associated_commit_id=$color_prefix_red$submodules_associated_commit_id$color_suffix</span><br><span class="line">		color_submodules_head_commit_id=$color_prefix_red$submodules_head_commit_id$color_suffix</span><br><span class="line"></span><br><span class="line">		color_tips=$color_prefix_red"[★]"$color_suffix</span><br><span class="line">		color_right=$color_prefix_red"[✓]"$color_suffix</span><br><span class="line">		color_wrong=$color_prefix_red"[✗]"$color_suffix</span><br><span class="line"></span><br><span class="line"><span class="meta">		#</span><span class="bash"> 3. 判断`submodules_associated_commit_id`是否为空，若为空，说明当前子项目为新增子模块，需要提示开发者在主项目中进行提交；</span></span><br><span class="line"><span class="meta">		#</span><span class="bash">    若不为空，则将2个commitId进行比较，若二者一致，则说明当前子项目的版本是一致的</span></span><br><span class="line">		if [ -z "$submodules_associated_commit_id" ]</span><br><span class="line">		then</span><br><span class="line">			echo "$color_tips $submodule_name: a new submodule, and is waiting to be committed"</span><br><span class="line">		else</span><br><span class="line">			if [ $submodules_associated_commit_id = $submodules_head_commit_id ]</span><br><span class="line">			then </span><br><span class="line">				echo "$color_right $submodule_name: associatedCommitId($color_submodules_associated_commit_id) == headCommitId($color_submodules_head_commit_id)"</span><br><span class="line">			else </span><br><span class="line">				echo "$color_wrong $submodule_name: associatedCommitId($color_submodules_associated_commit_id) != headCommitId($color_submodules_head_commit_id)"</span><br><span class="line">				echo true &gt; temp_has_bad_submodule</span><br><span class="line">			fi</span><br><span class="line">		fi</span><br><span class="line"></span><br><span class="line">	done</span><br><span class="line"></span><br><span class="line">	read has_bad_submodule &lt; temp_has_bad_submodule</span><br><span class="line">	rm -f temp_has_bad_submodule</span><br><span class="line"></span><br><span class="line">	echo "check the version of submodules done !!!"</span><br><span class="line"></span><br><span class="line">	if [ "$has_bad_submodule" = true ]</span><br><span class="line">	then</span><br><span class="line">		fix_cmd="git submodule update --init --recursive"</span><br><span class="line">		color_fix_cmd=$color_prefix_red$fix_cmd$color_suffix</span><br><span class="line">		color_sad=$color_prefix_red"(ToT)"$color_suffix</span><br><span class="line">		echo "$color_sad This main repo has bad submodules, please run this command to fix it: $color_fix_cmd"</span><br><span class="line"><span class="meta">		#</span><span class="bash"> 1 = <span class="literal">false</span></span></span><br><span class="line">    	return 1</span><br><span class="line">	else</span><br><span class="line">		color_happy=$color_prefix_red"(^_^)"$color_suffix</span><br><span class="line">		echo "$color_happy This main repo has good submodules, you can have a joy now..."</span><br><span class="line">    	# 0 = true</span><br><span class="line">    	return 0</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">test</span>: 假设git_submodule_version_checker.sh脚本放置在主工程git仓库根目录下的一个文件夹，如./script/git_submodule_version_checker.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">project_dir=$(<span class="built_in">cd</span> `dirname <span class="variable">$0</span>`; <span class="built_in">cd</span> ..; <span class="built_in">pwd</span>)</span></span><br><span class="line">if [ -n "$1" ]</span><br><span class="line">then</span><br><span class="line">    project_dir=$1</span><br><span class="line">else</span><br><span class="line">	echo "usage: sh PATH_TO/git_submodule_version_checker.sh PATH_TO_MAIN_GIT_REPO "</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">check_submodules_version $project_dir</span><br></pre></td></tr></table></figure>

<h2 id="如何接入到移动端项目"><a href="#如何接入到移动端项目" class="headerlink" title="如何接入到移动端项目"></a>如何接入到移动端项目</h2><p>下面将会通过iOS端和Android端的示例工程，演示如何接入<code>git_submodule_version_checker</code>到移动端主项目工程中。</p>
<h3 id="关于检测工具的运行时机"><a href="#关于检测工具的运行时机" class="headerlink" title="关于检测工具的运行时机"></a>关于检测工具的运行时机</h3><p>在iOS端和Android端项目的示例工程中，<code>git_submodule_version_checker</code>的运行时机都设置在工程编译前，你也可以根据自己需要调整你喜欢的运行时机。</p>
<p>在iOS端和Android端项目的示例工程中，每次对工程进行编译前，都会调用<code>git_submodule_version_checker</code>对子项目的版本进行检查，若当前主项目存在版本不一致的子项目，则编译会以失败结束。</p>
<h3 id="iOS端示例"><a href="#iOS端示例" class="headerlink" title="iOS端示例"></a>iOS端示例</h3><p>iOS端主项目工程接入步骤如下：</p>
<ol>
<li><p>下载<a href="https://github.com/YK-Unit/git_submodule_version_checker/archive/master.zip" target="_blank" rel="noopener">git_submodule_version_checker</a>，放置到主工程根目录，如图：</p>
<p> <img src="/2019/git%20submodule%E7%89%88%E6%9C%AC%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%EF%BC%9Agit_submodule_version_checker/readme/iOS-Project-Root-Dir.png" alt=""></p>
</li>
<li><p>用Xcode打开主工程的，选择<code>主工程Target &gt; Build Phase &gt; +</code>，如图所示新建一个名为<code>[CP] Check Git Submodule Version</code>的<code>Run Script Phase</code>：</p>
<p> <img src="/2019/git%20submodule%E7%89%88%E6%9C%AC%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%EF%BC%9Agit_submodule_version_checker/readme/Run-Script-Phase.png" alt=""></p>
</li>
</ol>
<ul>
<li><p><code>Run Script Phase</code>代码：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root_dir=$SRCROOT</span><br><span class="line">sh $root_dir/git_submodule_version_checker/git_submodule_version_checker.sh $root_dir</span><br><span class="line">if [ $? != 0 ]</span><br><span class="line">then </span><br><span class="line">echo "error: This main repo has bad submodules, please run 'git submodule update --init --recursive' to fix it" &gt;&amp;2</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line">echo "SUCCESS"</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意和红框一样，反选<code>Show environment variables in build log</code>和<code>Run script only when installing</code></p>
</li>
</ul>
<h3 id="Android端示例"><a href="#Android端示例" class="headerlink" title="Android端示例"></a>Android端示例</h3><p>Android端主项目工程接入步骤如下：</p>
<ol>
<li><p>下载<a href="https://github.com/YK-Unit/git_submodule_version_checker/archive/master.zip" target="_blank" rel="noopener">git_submodule_version_checker</a>，放置到主工程根目录，如图：</p>
<p> <img src="/2019/git%20submodule%E7%89%88%E6%9C%AC%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%EF%BC%9Agit_submodule_version_checker/readme/Android-Project-Root-Dir.png" alt=""></p>
</li>
</ol>
<ol start="2">
<li><p>用Android Studio 打开主工程，选择<code>主工程 &gt; app &gt; build.gradle</code>，如图所示添加名为<code>check_git_submodule_version</code>的<code>task</code>，并为<code>preBuild</code>这个task设置依赖：</p>
<p> <img src="/2019/git%20submodule%E7%89%88%E6%9C%AC%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%EF%BC%9Agit_submodule_version_checker/readme/build.gradle.png" alt=""></p>
<p>上述添加的完整代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task check_git_submodule_version(<span class="string">type:</span> Exec) &#123;</span><br><span class="line">    <span class="keyword">def</span> root_dir = getRootDir()</span><br><span class="line">    executable <span class="string">"sh"</span></span><br><span class="line">    args <span class="string">"$root_dir/git_submodule_version_checker/git_submodule_version_checker.sh"</span>, <span class="string">"$root_dir"</span></span><br><span class="line"></span><br><span class="line">    ignoreExitValue <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    doLast &#123;</span><br><span class="line">        logger.lifecycle(<span class="string">"check result: $execResult"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(execResult.exitValue == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.lifecycle(<span class="string">'SUCCESS'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">"This main repo has bad submodules, please run \'git submodule update --init --recursive\' to fix it."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preBuild.dependsOn check_git_submodule_version</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="示例链接"><a href="#示例链接" class="headerlink" title="示例链接"></a>示例链接</h3><ul>
<li><a href="https://github.com/YK-Unit/git_submodule_version_checker_example_iOS" target="_blank" rel="noopener">iOS Example</a></li>
<li><a href="https://github.com/YK-Unit/git_submodule_version_checker_example_Android" target="_blank" rel="noopener">Android Example</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://stackoverflow.com/questions/3983829/how-can-i-get-a-git-submodules-associated-commit-id-from-a-past-commit-in-the-p?noredirect=1&lq=1" target="_blank" rel="noopener">《How can I get a git submodule’s associated commit ID from a past commit in the parent clone?》</a></li>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener external nofollow noreferrer">《Git 工具 - 子模块》</a></li>
<li><a href="https://blog.devtang.com/2013/05/08/git-submodule-issues/" target="_blank" rel="noopener external nofollow noreferrer">《Git submodule的坑》</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>大前端</tag>
        <tag>2019</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Flr的产品观和开发观</title>
    <url>/2020/Flr%E7%9A%84%E4%BA%A7%E5%93%81%E8%A7%82%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%82/readme/</url>
    <content><![CDATA[<p><img src="/2020/Flr%E7%9A%84%E4%BA%A7%E5%93%81%E8%A7%82%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%82/readme/flr.png" alt="Flr"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://blog.yorkfish.me/2020/Flr%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%87%BA%E8%89%B2%E7%9A%84Flutter%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B/2020/Flr%E7%9A%84%E4%BA%A7%E5%93%81%E8%A7%82%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%82/readme/">Flr</a> 是我主导的和组织团队对外开源的第一款作品——一个用于帮助管理Flutter资源的开发工具系列产品，包括： </p>
<ul>
<li><a href="https://github.com/Fly-Mix/flr-as-plugin" target="_blank" rel="noopener">flr-as-plugin</a>：<code>Flr</code>的Android Studio插件版本</li>
<li><a href="https://github.com/Fly-Mix/flr-vscode-extension" target="_blank" rel="noopener">flr-vscode-extension</a>：<code>Flr</code>的VSCode插件版本</li>
<li><a href="https://github.com/Fly-Mix/flr-cli" target="_blank" rel="noopener">flr-cli</a>：<code>Flr</code>的命令行版本</li>
</ul>
<p>在这里，主要分享一下<code>Flr</code>背后的产品观和开发观。</p>
<a id="more"></a>

<h2 id="Flr的产品观"><a href="#Flr的产品观" class="headerlink" title="Flr的产品观"></a>Flr的产品观</h2><p><code>Flr</code>的产品观主要体现在“产品矩阵策略”和“产品运营策略”这2点上，下面对这2点分别做具体的分享。</p>
<h3 id="产品矩阵策略"><a href="#产品矩阵策略" class="headerlink" title="产品矩阵策略"></a>产品矩阵策略</h3><p><code>Flr</code>的产品矩阵组成如下：</p>
<ul>
<li><a href="https://github.com/Fly-Mix/flr-as-plugin" target="_blank" rel="noopener">flr-as-plugin</a>：<code>Flr</code>的Android Studio插件版本</li>
<li><a href="https://github.com/Fly-Mix/flr-vscode-extension" target="_blank" rel="noopener">flr-vscode-extension</a>：<code>Flr</code>的VSCode插件版本</li>
<li><a href="https://github.com/Fly-Mix/flr-cli" target="_blank" rel="noopener">flr-cli</a>：<code>Flr</code>的命令行版本</li>
</ul>
<p><code>Flr</code>的产品矩阵策略主要是2点：</p>
<ul>
<li>构建开发场景支持全面的产品矩阵</li>
<li>构建具备容灾能力的产品的矩阵</li>
</ul>
<h4 id="构建开发场景支持全面的产品矩阵"><a href="#构建开发场景支持全面的产品矩阵" class="headerlink" title="构建开发场景支持全面的产品矩阵"></a>构建开发场景支持全面的产品矩阵</h4><p>Flutter的开发场景主要有：</p>
<ol>
<li><p>使用Android Studio进行Flutter开发</p>
</li>
<li><p>使用VSCode进行Flutter开发</p>
</li>
<li><p>使用其他文本编辑工具（如Emacs）进行Flutter开发</p>
</li>
<li><p>使用CI工具对Flutter工程进行自动构建</p>
</li>
</ol>
<blockquote>
<p>Flutter官方推荐的IDE主要有Android Studio和VSCode两种。</p>
<p>详细可见<a href="https://flutter.cn/docs/get-started/editor" target="_blank" rel="noopener external nofollow noreferrer">《Flutter编辑工具设定》</a></p>
</blockquote>
<p> 对应上述产品矩阵：</p>
<ol>
<li><p><code>flr-as-plugin</code>用于满足开发场景一</p>
</li>
<li><p><code>flr-vscode-extension</code>用于满足开发场景二</p>
</li>
<li><p><code>flr-cli</code>主要用于满足开发场景三和开发场景四 </p>
</li>
</ol>
<p>通过实施这个策略，<code>Flr</code>将能获得以下好处：</p>
<ul>
<li>支持全面，有助全面占领市场（此处的市场特指Flutter资源管理开发工具这个垂直领域市场）</li>
<li>形成宣传亮点，有助宣传推广产品</li>
<li>形成护城河，直接提升后来挑战者的竞争门槛</li>
</ul>
<h4 id="构建具备容灾能力的产品的矩阵"><a href="#构建具备容灾能力的产品的矩阵" class="headerlink" title="构建具备容灾能力的产品的矩阵"></a>构建具备容灾能力的产品的矩阵</h4><p>   此处所述的“灾难”，主要是指Android Studio或者VSCode进行了breaking式的版本升级后，插件因为兼容性问题导致运行失败或者运行异常。<br>   当发生此种“灾难”后，上述产品矩阵中的<code>flr-cli</code>可以作为<code>flr-as-plugin</code>和<code>flr-vscode-extension</code>的“备胎”，帮助开发者正常完成开发任务，顺利过渡到插件新版本的发布。</p>
<h3 id="产品运营策略"><a href="#产品运营策略" class="headerlink" title="产品运营策略"></a>产品运营策略</h3><p><code>Flr</code>的产品运营策略主要是2点：</p>
<ul>
<li><p>突出<code>Flr</code>的全平台支持特性，强调支持“Android Studio”、“VSCode”、“命令行”</p>
<p> 注意，此处使用“平台”代替上述的“场景”，一是因为<code>Flr</code>的目标用户是开发者，相比“场景”，“平台”与“开发者”具有更深的“亲缘性”，简单来说就是“全平台”比“全场景”更容易获得目标用户的理解；二是因为在字眼上，“平台”这个词比“场景”更有“震撼力”，简单来说就是显得“更牛逼”。</p>
</li>
<li><p>突出<code>Flr</code>的健壮性，强调支持各种异常场景</p>
<p> 不过，这一点主要体现在<code>Flr</code>相关产品的特性说明上，而不是在日常宣传上，因为“事实胜于雄辩”——在目标用户头脑埋下这个种子后，等目标用户在事实中进行发现和获得证明即可。</p>
</li>
<li><p>对外输出Flr的标准，比如推荐的资源组织结构</p>
</li>
</ul>
<h2 id="Flr的开发观"><a href="#Flr的开发观" class="headerlink" title="Flr的开发观"></a>Flr的开发观</h2><p>Flr的开发观主要体现在其所采用的开发策略上：</p>
<ul>
<li><p>构建<code>Flr</code>核心逻辑项目——<a href="https://github.com/Fly-Mix/flr-core" target="_blank" rel="noopener">flr-core</a>，以保证<code>flr-as-plugin</code>、<code>flr-vscode-extension</code>、<code>flr-cli</code>在核心逻辑上保持一致，在输出产物上保持一致</p>
<blockquote>
<ul>
<li>“输出产物”包括：文件输出、日志输出、交互输出</li>
<li>现阶段，保证“文件输出”一致是第一要求</li>
</ul>
</blockquote>
</li>
<li><p>构建测试用例文档（详细见<code>flr-core</code>各分支版本下的<code>CLD/assets/flr-use-case.xmind</code>），以保证<code>flr-as-plugin</code>、<code>flr-vscode-extension</code>、<code>flr-cli</code>的健壮性</p>
</li>
<li><p>以<code>flr-cli</code>的“文件输出”作为测试结果基准，以提升<code>flr-as-plugin</code>、<code>flr-vscode-extension</code>的测试速度和进一步提升这二者的健壮性</p>
</li>
<li><p><code>flr-cli</code>作为新特性的实验田，在论证新特性的可行性后，再引进到<code>flr-as-plugin</code>、<code>flr-vscode-extension</code></p>
<blockquote>
<p><code>flr-cli</code>采用<code>Ruby</code>开发，可快速实现新特性，以察看特性效果</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>人文</tag>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>Flr：一个出色的Flutter资源管理工具</title>
    <url>/2020/Flr%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%87%BA%E8%89%B2%E7%9A%84Flutter%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/readme/</url>
    <content><![CDATA[<p><img src="/2020/Flr%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%87%BA%E8%89%B2%E7%9A%84Flutter%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/readme/flr.png" alt="Flr"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一名Flutter开发者，如果你正在烦恼如何简单快捷地在<code>pubspec.yaml</code>中为多张图片、文本、字体资源添加声明，如果你正在烦恼如何简单安全地在代码中引用资源，那么现在你可以很简单地解决这些问题了——只要你使用了<code>Flr</code>。</p>
<h2 id="Flr简介"><a href="#Flr简介" class="headerlink" title="Flr简介"></a>Flr简介</h2><p><code>Flr</code>，读作<code>Flutter-R</code>，是一个由网易严选智造团队研发的，用于管理Flutter资源的开发工具。</p>
<p><code>Flr</code>可以帮助Flutter开发者在修改项目资源后，自动为资源添加声明到<code>pubspec.yaml</code>以及生成<code>r.g.dart</code>文件。借助<code>r.g.dart</code>，Flutter开发者可以在代码中通过资源ID函数的方式应用资源，例如：</p>
<a id="more"></a>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_r_demo/r.g.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test_sameName.png</span></span><br><span class="line"><span class="keyword">var</span> normalImageWidget = Image(</span><br><span class="line">  width: <span class="number">200</span>,</span><br><span class="line">  height: <span class="number">120</span>,</span><br><span class="line">  image: R.image.test_sameName(),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test_sameName.gif</span></span><br><span class="line"><span class="keyword">var</span> gifImageWidget = Image(</span><br><span class="line">  image: R.mage.test_sameName_gif(),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.svg</span></span><br><span class="line"><span class="keyword">var</span> svgImageWidget = Image(</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  height: <span class="number">100</span>,</span><br><span class="line">  image: R.svg.test(width: <span class="number">100</span>, height: <span class="number">100</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.json</span></span><br><span class="line"><span class="keyword">var</span> jsonString = <span class="keyword">await</span> R.text.test_json();</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.yaml</span></span><br><span class="line"><span class="keyword">var</span> yamlString = <span class="keyword">await</span> R.text.test_yaml();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Amiri Font Style</span></span><br><span class="line"><span class="keyword">var</span> amiriTextStyle = TextStyle(fontFamily: R.fontFamily.amiri);</span><br></pre></td></tr></table></figure>

<h2 id="Flr特性"><a href="#Flr特性" class="headerlink" title="Flr特性"></a>Flr特性</h2><p>截止到目前，<code>Flr</code>已经支持以下特性：</p>
<ul>
<li>支持“自动添加资源声明到 <code>pubspec.yaml</code> 和自动生成<code>r.g.dart</code>文件”的自动化服务，该服务可以通过手动触发，也可以通过监控资源变化触发</li>
<li>支持<code>R.x</code>（如 <code>R.image.test()</code>，<code>R.svg.test(width: 100, height: 100)</code>，<code>R.txt.test_json()</code>）的代码结构</li>
<li>支持处理图片资源（ <code>.png</code>、 <code>.jpg</code>、 <code>.jpeg</code>、<code>.gif</code>、 <code>.webp</code>、<code>.icon</code>、<code>.bmp</code>、<code>.wbmp</code>、<code>.svg</code> ）</li>
<li>支持处理文本资源（<code>.txt</code>、<code>.json</code>、<code>.yaml</code>、<code>.xml</code>）</li>
<li>支持处理字体资源（<code>.ttf</code>、<code>.otf</code>、<code>.ttc</code>）</li>
<li>支持处理<a href="https://flutter.dev/docs/development/ui/assets-and-images#asset-variants" target="_blank" rel="noopener external nofollow noreferrer">图片资源变体</a></li>
<li>支持处理带有坏味道的文件名的资源：<ul>
<li>文件名带有非法字符，如空格、<code>~</code>、<code>#</code> 等（非法字符是指不在合法字符集合内的字符；合法字符集合的字符有：<code>0-9</code>、<code>A-Z</code>、 <code>a-z</code>、 <code>_</code>、<code>+</code>、<code>-</code>、<code>.</code>、<code>·</code>、 <code>!</code>、 <code>@</code>、 <code>&amp;</code>、<code>$</code>、<code>￥</code>）</li>
<li>文件名以数字或者<code>_</code>或者<code>$</code>字符开头</li>
</ul>
</li>
<li>支持处理文件名相同但路径不同的资源</li>
</ul>
<h2 id="Flr工具"><a href="#Flr工具" class="headerlink" title="Flr工具"></a>Flr工具</h2><p>为了更好地满足Flutter开发者的使用需求，我们提供了以下3个版本的<code>Flr</code>工具：</p>
<ol>
<li><p><strong>Flr Android Studio Plugin</strong> 版本</p>
<ul>
<li><p>GitHub:  <a href="https://github.com/Fly-Mix/flr-as-plugin" target="_blank" rel="noopener">https://github.com/Fly-Mix/flr-as-plugin</a></p>
</li>
<li><p>Plugin Homepage: <a href="https://plugins.jetbrains.com/plugin/13789-flr" target="_blank" rel="noopener external nofollow noreferrer">https://plugins.jetbrains.com/plugin/13789-flr</a></p>
</li>
<li><p>flr-as-plugin Usage Example Gif: </p>
<p><img src="/2020/Flr%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%87%BA%E8%89%B2%E7%9A%84Flutter%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/readme/flr_as_plugin-usage-example.gif" alt="flr_as_plugin-usage-example"></p>
</li>
</ul>
</li>
<li><p><strong>Flr CLI</strong> 版本</p>
<ul>
<li><p>GitHub: <a href="https://github.com/Fly-Mix/flr-cli" target="_blank" rel="noopener">https://github.com/Fly-Mix/flr-cli</a></p>
</li>
<li><p>CLI Homepage: <a href="https://rubygems.org/gems/flr" target="_blank" rel="noopener external nofollow noreferrer">https://rubygems.org/gems/flr</a></p>
</li>
<li><p>flr-cli Usage Example Gif:</p>
<p><img src="/2020/Flr%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%87%BA%E8%89%B2%E7%9A%84Flutter%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/readme/flr_cli-usage-example.gif" alt="flr_cli-usage-example"></p>
</li>
</ul>
</li>
<li><p><strong>Flr VSCode Extension</strong> 版本</p>
<ul>
<li><p>GitHub: <a href="https://github.com/Fly-Mix/flr-vscode-extension" target="_blank" rel="noopener">https://github.com/Fly-Mix/flr-vscode-extension</a></p>
</li>
<li><p>Extension Homepage: <a href="https://marketplace.visualstudio.com/items?itemName=LincolnLaw.flr" target="_blank" rel="noopener external nofollow noreferrer">https://marketplace.visualstudio.com/items?itemName=LincolnLaw.flr</a></p>
</li>
<li><p>flr-vscode-extension Usage Example:</p>
<p><img src="/2020/Flr%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%87%BA%E8%89%B2%E7%9A%84Flutter%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/readme/flr_vscode_extension-usage.jpg" alt="flr_vscode_extension-usage"></p>
</li>
</ul>
</li>
</ol>
<p>最后，希望该工具可以帮助各个Flutter开发者提升Flutter的开发效率。使用过程中有任何疑问，欢迎通过GitHub或者邮件反馈给我们。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>大前端</tag>
        <tag>Flutter</tag>
        <tag>2020</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Future和Promise的区别</title>
    <url>/2020/Future%E5%92%8CPromise%E7%9A%84%E5%8C%BA%E5%88%AB/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Future模型和Promise模型是并发编程领域中的两种相近的异步编程模型，Future和Promise则是并发编程语言分别对Future模型和Promise模型进行实现后的产物。</p>
<p>Future和Promise之间，既有相同之处，也有不同之处。</p>
<a id="more"></a>

<h2 id="Future和Promise的相同点"><a href="#Future和Promise的相同点" class="headerlink" title="Future和Promise的相同点"></a>Future和Promise的相同点</h2><p>Future和Promise的设计理念是一致的：作为一个异步任务的运行结果的占位符对象供开发者使用。</p>
<blockquote>
<p>A future or promise represents the future value of an asynchronous task.</p>
</blockquote>
<p>Future和Promise给开发者带来的好处是相同的：</p>
<ul>
<li><p>简化了异步编程，让开发者“摆脱”对线程的依赖和关注，只专注于异步任务（异步业务代码）的编码即可</p>
<blockquote>
<ul>
<li>【让开发者“摆脱”对线程的依赖和关注】这个是相对传统的“多线程模型”而言。在传统的“多线程模型”中，编写异步业务代码，开发者需要手动创建线程，若需要高效的并发性能，则还需要开发者通过线程池等手段手动管理线程</li>
<li>事实上，进行了高级抽象的异步编程模型都有这种好处，比如Objective-C中的GCD、NSOperation。</li>
</ul>
</blockquote>
</li>
<li><p>提供了更优雅、好用的异步编程，比如：异步代码同步化，链式调用，任务组合，摆脱回调地狱等</p>
</li>
</ul>
<h2 id="Future和Promise的不同点"><a href="#Future和Promise的不同点" class="headerlink" title="Future和Promise的不同点"></a>Future和Promise的不同点</h2><p>Future和Promise的区别是：</p>
<ul>
<li><p>状态不一样</p>
<p>  Future的状态有2种：</p>
<ul>
<li><p>uncompleted：未完成状态，Future的初始化状态</p>
</li>
<li><p>completed：完成状态，有可能操作成功也可能操作失败</p>
<blockquote>
<p>其中，completed根据结果又分为2种：</p>
<ul>
<li>completing with a value</li>
<li>completing with an error</li>
</ul>
</blockquote>
<p>Promise的状态有3种：</p>
</li>
<li><p>pending：待定状态，Promise的初始化状态</p>
</li>
<li><p>fulfilled：满足状态，意味着操作成功</p>
</li>
<li><p>rejected：拒绝状态，意味着操作失败</p>
</li>
</ul>
</li>
<li><p>状态修改机制不一样</p>
<ul>
<li><p>Future的状态由内部自行管理：当异步任务执行完成或者执行过程中抛出错误，一个Future就自动从uncompleted状态变为completed状态</p>
</li>
<li><p>Promise的状态由外部开发者手动管理：开发者根据控制流逻辑，调用指定函数（<code>fulfill</code>、<code>reject</code>）来显式修改的一个Promise的状态</p>
<blockquote>
<ul>
<li><code>fulfill</code>函数的作用是：修改Promise的状态为fulfilled，同时返回结果值</li>
<li><code>reject</code>函数的作用是：修改Promise的状态为rejected，同时返回错误信息<br>在支持Promise的不同编程语言中，<code>fulfill</code>、<code>reject</code>函数可能有其他名称，比如在JavaScript中，二者对应叫<code>resolve</code>和<code>reject</code></li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>结果返回机制不一样</p>
<ul>
<li><p>Future通过return方式返回结果</p>
</li>
<li><p>Promise通过指定函数（<code>fulfill</code>、<code>reject</code>接口）返回</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>从状态修改机制和结果返回机制这2点来说，可以认为Future和Promise之间还有一个区别：读写权限不一样——Future只读，Promise可写。具体地说，相对Future，Promise允许用户修改状态和返回结果。</p>
</blockquote>
<h2 id="Future和Promise的示例"><a href="#Future和Promise的示例" class="headerlink" title="Future和Promise的示例"></a>Future和Promise的示例</h2><p>下面提供了Future示例和Promise示例，帮助理解上述所讲的二者的不同点：</p>
<blockquote>
<ul>
<li>Future示例使用Dart编写</li>
<li>Promise示例使用JavaScript编写</li>
<li>在线运行示例代码：<a href="https://repl.it" target="_blank" rel="noopener external nofollow noreferrer">https://repl.it</a>（<code>repl.it</code>是一个为各种编程语言提供线上编程环境的网站）</li>
</ul>
</blockquote>
<ul>
<li><p>Future示例（by Dart）</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; sendEcho(text) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () &#123;</span><br><span class="line">    <span class="keyword">if</span> (text == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// the Future becomes completed status after throw(error)</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="string">"text can't be null"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (text == <span class="string">""</span>) &#123;</span><br><span class="line">      <span class="comment">// the Future becomes completed status after return</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Future.error(<span class="string">"text can't be empty string"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the Future becomes completed status after return</span></span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo(text) &#123;</span><br><span class="line">  sendEcho(text).then((value) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"get echo: <span class="subst">$value</span>"</span>);</span><br><span class="line">  &#125;).catchError((error) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"get error: <span class="subst">$error</span>"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"echo now ..."</span>);</span><br><span class="line">  echo(<span class="string">"hello"</span>);</span><br><span class="line">  echo(<span class="string">""</span>);</span><br><span class="line">  echo(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo now ...</span><br><span class="line">get echo: hello</span><br><span class="line">get error: text can&#39;t be empty string</span><br><span class="line">get error: text can&#39;t be null</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Promise示例（by JavaScript）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendEcho</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (text == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// the Promise is still pending status after throw(error)</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"text can't be null"</span>);</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (text == <span class="string">""</span>) &#123;</span><br><span class="line">        <span class="comment">// the Promise becomes rejected status after reject(reason)</span></span><br><span class="line">        reject(<span class="string">"text can't be empty string"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// the Promise becomes fulfilled status after resolve(value)</span></span><br><span class="line">      resolve(text)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">echo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  sendEcho(text).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"get echo: "</span>, value)</span><br><span class="line">  &#125;).catch(</span><br><span class="line">    (reason) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"get error: "</span>, reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"echo now ..."</span>)</span><br><span class="line">echo(<span class="string">"hello"</span>)</span><br><span class="line">echo(<span class="string">""</span>)</span><br><span class="line">echo(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo now ...</span><br><span class="line">get echo: hello</span><br><span class="line">get error: text can&#39;t be empty string</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Futures_and_promises" target="_blank" rel="noopener external nofollow noreferrer">WiKi-《Futures and promises》</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1135972" target="_blank" rel="noopener external nofollow noreferrer">《漫谈并发编程：Future模型（Java、Clojure、Scala多语言角度分析）》</a></li>
<li><a href="http://dist-prog-book.com/chapter/2/futures.html" target="_blank" rel="noopener external nofollow noreferrer">《Futures and Promises》</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener external nofollow noreferrer">《MDN web docs: Promise》</a></li>
<li><a href="https://blog.makeex.com/2016/04/30/best-romantic-abstract-promise-and-future/" target="_blank" rel="noopener external nofollow noreferrer">《最浪漫的抽象 Promise &amp; Future》</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>2020</tag>
        <tag>基础理论</tag>
      </tags>
  </entry>
  <entry>
    <title>OOP：方法（method）和函数（function）的区别</title>
    <url>/2020/OOP%EF%BC%9A%E6%96%B9%E6%B3%95%EF%BC%88method%EF%BC%89%E5%92%8C%E5%87%BD%E6%95%B0%EF%BC%88function%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在面向对象领域中，方法（method）和函数（function）有什么区别和关联呢？</p>
<h2 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h2><p>在面向对象领域中，方法和函数的区别是：</p>
<ol>
<li><p>定义不一样</p>
<ul>
<li>函数是指一段可以直接被其名称调用的代码块</li>
<li>方法指的是一段被它关联的对象通过它的名字调用的代码块</li>
</ul>
</li>
<li><p>与对象的关系不一样</p>
<ul>
<li>函数独立于对象</li>
<li>方法依附在对象之上，可以在代码块内直接处理对象上的成员数据</li>
</ul>
</li>
<li><p>传递的数据（比如参数）不一样</p>
<ul>
<li>传递给函数的数据都是明文明确的</li>
<li>传递给方法的数据有部分是隐式的，其中隐式部分的数据主要是调用该方法的对象实例</li>
</ul>
</li>
<li><p>可访问范围不一样</p>
<ul>
<li>一般来说（在不考虑module、package等作用域的设计情况下），函数的可访问范围是全局性的，即可以在代码的任何地方访问到</li>
<li>方法的可访问范围由其访问修饰符决定，基本上其范围都局限在所依赖的对象内</li>
</ul>
</li>
</ol>
<a id="more"></a>

<h2 id="方法和函数的关联"><a href="#方法和函数的关联" class="headerlink" title="方法和函数的关联"></a>方法和函数的关联</h2><p>在面向对象领域中，方法和函数的关联是：在概念上，方法可简单视作函数的特例——方法就是对象的函数。</p>
<h2 id="C-标准为何没有使用“方法”而是使用“成员函数”"><a href="#C-标准为何没有使用“方法”而是使用“成员函数”" class="headerlink" title="C++标准为何没有使用“方法”而是使用“成员函数”"></a>C++标准为何没有使用“方法”而是使用“成员函数”</h2><p>C++标准为何没有使用“方法”这个术语而是选择使用了“成员函数”这个术语呢？</p>
<p>这个问题没有正式的、官方的答案。我的个人理解则是：</p>
<ul>
<li><p>这可能和编程语言设计观相关：对于C++<br>作者来说，采用“成员函数”可以减少一个术语概念，降低复杂性</p>
</li>
<li><p>这也可能和编程语言的底层实现的设计相关：C++ 的一个关键目标是尽量地节省额外开销，特别是内存的开销，为此，在 C++ 代码和硬件之间，C++ 没有做额外的抽象、虚拟或者其他的数学模型，而是直接把基本类型（char, int, double 等）映射到内存中的实体——比如字节（Byte）、字（Word），把有类型的对象映射到内存中一块连续空间内。在处理类的方法（此处使用面向对象术语）时，并没有做额外抽象，而是和处理普通函数一样：做直接的内存映射（在内存上都是一段连续的指令）。那么，在底层实现这个层面上，以及没有做额外的抽象、虚拟的情况下，类的方法和普通函数没有本质区别，使用“成员函数”的术语似乎优于“方法”这个术语了。</p>
<blockquote>
<p>关于C++ 的类的一个微妙问题：</p>
<p>一个常见的混淆其实只是一个微妙的术语问题：由于它的演化来自C，在C++ 中的术语对象和C语言一样是意味着存储器区域，而不是类的实体，在其它绝大多数的面向对象语言也是如此。举例来说，在C和C++中，语句int i;定义一个int类型的对象，这就是变量的值i将在指派时，所存入的存储器区域。</p>
<p>源自：<a href="https://zh.wikipedia.org/wiki/C%2B%2B#C++中的特色" target="_blank" rel="noopener external nofollow noreferrer">维基 -《C++》</a></p>
</blockquote>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://stackoverflow.com/questions/155609/whats-the-difference-between-a-method-and-a-function?page=1&tab=votes#tab-top" target="_blank" rel="noopener">stackoverflow -《What’s the difference between a method and a function?》</a></li>
<li><a href="https://blog.csdn.net/notsaltedfish/article/details/75174556" target="_blank" rel="noopener external nofollow noreferrer">《方法和函数的区别》</a></li>
<li><a href="https://www.cnblogs.com/wancy86/p/7271850.html" target="_blank" rel="noopener external nofollow noreferrer">《方法（method）和函数（function）有什么区别？》</a></li>
<li><a href="https://zh.wikipedia.org/wiki/C%2B%2B#C++中的特色" target="_blank" rel="noopener external nofollow noreferrer">维基 -《C++》</a></li>
<li><a href="https://liam.page/2017/04/09/Foundations-of-Cpp/" target="_blank" rel="noopener external nofollow noreferrer">《C++ 的几个基本原理和技术》</a></li>
<li><a href="http://cs.ioc.ee/etaps12/invited/stroustrup-slides.pdf" target="_blank" rel="noopener external nofollow noreferrer">《Foundations of C++（PPT版本）》</a></li>
<li><a href="http://www.stroustrup.com/ETAPS-corrected-draft.pdf" target="_blank" rel="noopener external nofollow noreferrer">《Foundations of C++（论文版本）》</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>2020</tag>
        <tag>基础理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C的一道题：[self class] 与 [super class]</title>
    <url>/2020/Objective-C%E7%9A%84%E4%B8%80%E9%81%93%E9%A2%98%EF%BC%9A%5Bself%20class%5D%20%E4%B8%8E%20%5Bsuper%20class%5D/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一道从此篇博客<a href="https://halfrost.com/objc_runtime_isa_class/" target="_blank" rel="noopener external nofollow noreferrer">《神经病院 Objective-C Runtime 入院第一天—— isa 和 Class》</a>看到的题目：</p>
<blockquote>
<p>问：下面代码输出什么?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Son : Father</span><br><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</span><br><span class="line">    &#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</blockquote>
<p>答案是： 输出的都是<code>Son</code>。</p>
<p>对此，博客作者给出的理由是：</p>
<blockquote>
<p>self和super的区别：</p>
<p>self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。</p>
<p>super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用方法时，去调用父类的方法，而不是本类中的方法。</p>
<p>在调用[super class]的时候，runtime会去调用objc_msgSendSuper方法，而不是objc_msgSend</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OBJC_EXPORT void objc_msgSendSuper(void &#x2F;* struct objc_super *super, SEL op, ... *&#x2F; )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Specifies the superclass of an instance. </span><br><span class="line">struct objc_super &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained id receiver;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies the particular superclass of the instance to message. </span><br><span class="line">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span><br><span class="line">    &#x2F;* For compatibility with old objc-runtime.h header *&#x2F;</span><br><span class="line">    __unsafe_unretained Class class;</span><br><span class="line">#else</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;* super_class is the first class to search *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在objc_msgSendSuper方法中，第一个参数是一个objc_super的结构体，这个结构体里面有两个变量，一个是接收消息的receiver，一个是<br>当前类的父类super_class。</p>
<p>入院考试第一题错误的原因就在这里，误认为[super class]是调用的[super_class class]。</p>
<p>objc_msgSendSuper的工作原理应该是这样的:<br>从objc_super结构体指向的superClass父类的方法列表开始查找selector，找到后以objc-&gt;receiver去调用父类的这个selector。注意，最后的调用者是objc-&gt;receiver，而不是super_class！</p>
<p>那么objc_msgSendSuper最后就转变成</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这里是从父类开始msgSend，而不是从本类开始，谢谢@Josscii 和他同事共同指点出此处描述的不妥。</span></span><br><span class="line">objc_msgSend(objc_super-&gt;receiver, <span class="keyword">@selector</span>(<span class="keyword">class</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Specifies an instance of a class.  这是类的一个实例</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> receiver;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于是实例调用，所以是减号方法</span></span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于找到了父类NSObject里面的class方法的IMP，又因为传入的入参objc_super-&gt;receiver = self。self就是son，调用class，所以父类的方法class执行IMP之后，输出还是son，最后输出两个都一样，都是输出son。</p>
</blockquote>
<p>其实，上述的解答只答对了一大半，还有一小半没正确。没正确的部分主要在于对<code>objc_msgSend</code>和<code>objc_msgSendSuper</code>的工作原理理解错误，以及对方法实现的函数原型的忽略。</p>
<p>下面将会对此进行重新解答。</p>
<a id="more"></a>

<h2 id="新解"><a href="#新解" class="headerlink" title="新解"></a>新解</h2><p>Objective-C 是一门基于消息转发机制的动态编程语言，所有的方法调用都会转换为消息发送。所以，<code>[self class]</code>和<code>[super class]</code>会被编译器分别转换为<code>objc_msgSend(self, @selector(class))</code>和<code>objc_msgSendSuper(objc_super, @selector(class))</code>。</p>
<blockquote>
<p>具体地是转换为以下的C++ 代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [self class]</span></span><br><span class="line">((Class (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)self, sel_registerName(<span class="string">"class"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [super class]</span></span><br><span class="line">((Class (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Son"</span>))&#125;, sel_registerName(<span class="string">"class"</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行<code>clang -rewrite-objc xx.m -o xx.cpp</code>即可转换。</p>
</blockquote>
</blockquote>
<p><code>objc_msgSend</code>会根据<code>SEL</code>从当前对象开始查找对应的方法实现，查找到方法实现后，就会直接跳转到方法实现。</p>
<p><code>objc_msgSendSuper</code>会根据<code>SEL</code>从当前对象的父类开始查找对应的方法实现，查找到方法实现后，就会直接跳转到方法实现。</p>
<blockquote>
<p><code>objc_msgSend</code>的具体工作原理请看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;********************************************************************</span><br><span class="line"> *</span><br><span class="line"> * id objc_msgSend(id self, SEL _cmd, ...);</span><br><span class="line"> * IMP objc_msgLookup(id self, SEL _cmd, ...);</span><br><span class="line"> * </span><br><span class="line"> * objc_msgLookup ABI:</span><br><span class="line"> * IMP returned in r12</span><br><span class="line"> * Forwarding returned in Z flag</span><br><span class="line"> * r9 reserved for our use but not used</span><br><span class="line"> *</span><br><span class="line"> ********************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	</span><br><span class="line">	cbz	r0, LNilReceiver_f</span><br><span class="line"></span><br><span class="line">	ldr	r9, [r0]		&#x2F;&#x2F; r9 &#x3D; self-&gt;isa</span><br><span class="line">	GetClassFromIsa			&#x2F;&#x2F; r9 &#x3D; class</span><br><span class="line">	CacheLookup NORMAL, _objc_msgSend</span><br><span class="line">	&#x2F;&#x2F; cache hit, IMP in r12, eq already set for nonstret forwarding</span><br><span class="line">	bx	r12			&#x2F;&#x2F; call imp</span><br><span class="line"></span><br><span class="line">	CacheLookup2 NORMAL, _objc_msgSend</span><br><span class="line">	&#x2F;&#x2F; cache miss</span><br><span class="line">	ldr	r9, [r0]		&#x2F;&#x2F; r9 &#x3D; self-&gt;isa</span><br><span class="line">	GetClassFromIsa			&#x2F;&#x2F; r9 &#x3D; class</span><br><span class="line">	b	__objc_msgSend_uncached</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>objc_msgSendSuper</code>的具体工作原理请看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;********************************************************************</span><br><span class="line"> * id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</span><br><span class="line"> *</span><br><span class="line"> * struct objc_super &#123;</span><br><span class="line"> *     id receiver;</span><br><span class="line"> *     Class cls;	&#x2F;&#x2F; the class to search</span><br><span class="line"> * &#125;</span><br><span class="line"> ********************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">	ENTRY _objc_msgSendSuper</span><br><span class="line">	</span><br><span class="line">	ldr	r9, [r0, #CLASS]	&#x2F;&#x2F; r9 &#x3D; struct super-&gt;class</span><br><span class="line">	CacheLookup NORMAL, _objc_msgSendSuper</span><br><span class="line">	&#x2F;&#x2F; cache hit, IMP in r12, eq already set for nonstret forwarding</span><br><span class="line">	ldr	r0, [r0, #RECEIVER]	&#x2F;&#x2F; load real receiver</span><br><span class="line">	bx	r12			&#x2F;&#x2F; call imp</span><br><span class="line"></span><br><span class="line">	CacheLookup2 NORMAL, _objc_msgSendSuper</span><br><span class="line">	&#x2F;&#x2F; cache miss</span><br><span class="line">	ldr	r9, [r0, #CLASS]	&#x2F;&#x2F; r9 &#x3D; struct super-&gt;class</span><br><span class="line">	ldr	r0, [r0, #RECEIVER]	&#x2F;&#x2F; load real receiver</span><br><span class="line">	b	__objc_msgSend_uncached</span><br><span class="line">	</span><br><span class="line">	END_ENTRY _objc_msgSendSuper</span><br></pre></td></tr></table></figure>

<p>需要注意的是，Objective-C根据方法的调用者和方法的返回结果，提供了不同的消息发送函数，具体如下：</p>
<ul>
<li>调用者是对象的父类（an object’s superclass, using the super keyword），返回结果类型为结构体数据类型（ data structures return types）的消息使用<code>objc_msgSendSuper_stret</code>发送</li>
<li>调用者是对象的父类（an object’s superclass, using the super keyword）的消息使用<code>objc_msgSendSuper</code>发送</li>
<li>调用者是对象的（an object），返回结果类型为结构体数据类型（ data structures return types）的消息使用<code>objc_msgSend_stret</code>发送</li>
<li>调用者是对象的（an object），返回结果类型为浮点数类型（ some float return types）的消息使用<code>objc_msgSend_fpret</code>发送</li>
<li>调用者是对象的（an object），返回结果为复杂浮点数类型（some complex float return types）的消息使用<code>objc_msgSend_fp2ret</code>发送</li>
<li>剩余消息使用<code>objc_msgSend</code>发送</li>
</ul>
<p>其中，关于<code>objc_msgSend_fpret</code>和<code>objc_msgSend_fp2ret</code>的更多细节，请看下面引自源代码中的注释：</p>
<blockquote>
<p> Floating-point-returning Messaging Primitives</p>
<p> Use these functions to call methods that return floating-point values<br> on the stack.<br> Consult your local function call ABI documentation for details.</p>
<p> arm:    objc_msgSend_fpret not used<br> i386:   objc_msgSend_fpret used for <code>float</code>, <code>double</code>, <code>long double</code>.<br> x86-64: objc_msgSend_fpret used for <code>long double</code>.</p>
<p> arm:    objc_msgSend_fp2ret not used<br> i386:   objc_msgSend_fp2ret not used<br> x86-64: objc_msgSend_fp2ret used for <code>_Complex long double</code>.</p>
<p> These functions must be cast to an appropriate function pointer type<br> before being called. </p>
</blockquote>
</blockquote>
<p>由于<code>class</code>方法在<code>NSObject</code>处，最终<code>objc_msgSend(self, @selector(class))</code>和<code>objc_msgSendSuper(objc_super, @selector(class))</code>查找到是同一个方法实现。</p>
<p>在Objective-C 中，方法实现的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>IMP</code>为方法实现的函数原型，其有2个固定的参数：<code>id</code>和<code>SEL</code>，其中<code>id</code>是运行时接收消息（即进行方法调用）的对象实例。</p>
<p><code>objc_msgSend(self, @selector(class))</code>和<code>objc_msgSendSuper(objc_super, @selector(class))</code>传递给<code>class</code>这个方法的<code>IMP</code>的参数<code>id</code>都是同一个对象实例，所以最终二者的输出是相同的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/0xxd0/objc4" target="_blank" rel="noopener">objc-runtime源码</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>2020</tag>
        <tag>基础理论</tag>
      </tags>
  </entry>
  <entry>
    <title>Why has Class-MetaClass design in Objective-C？</title>
    <url>/2020/Why%20has%20Class-MetaClass%20design%20in%20Objective-C%EF%BC%9F/readme/</url>
    <content><![CDATA[<p>为什么Objective-C中有Class和MetaClass这种设计？</p>
<p>这个问题某日在<a href="https://juejin.im/entry/59bb8b895188257e70531bf9" target="_blank" rel="noopener">掘金</a>上看到的。我认为这不是一个技术领域的问题，而是编程语言的设计选择领域的问题。</p>
<p>在Objective-C编程语言的设计中，类（Class）既是一个用于描述对象实例（object）的属性和行为的工具，也是一个对象（Object），有自身的属性和行为；那类（Class）的属性和行为使用什么来描述呢？答案就是：元类（MetaClass）。只不过元类（MetaClass）处于编程语言的实现底层，对开发者是透明的。</p>
<p>那取消掉元类（MetaClass）可以吗？</p>
<p>答案是：可以。但是这需要从该编程语言的设计上做根本的调整：取消掉“类（Class）也是对象（Object）”的设计，把类（Class）同时当作描述对象实例（object）和类（Class）自身的属性和行为的工具。采用与此类似的设计的编程语言也存在，比如C++。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>2020</tag>
        <tag>基础理论</tag>
      </tags>
  </entry>
  <entry>
    <title>为何重启个人博客？</title>
    <url>/2020/%E4%B8%BA%E4%BD%95%E9%87%8D%E5%90%AF%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%9F/readme/</url>
    <content><![CDATA[<p>为何重启个人博客？</p>
<p>这个问题很早就想发文表达了，如今时机终于到了——在这个人博客重建完毕的时候，可以好好的来对此说说了。</p>
<p>重启个人博客的念头源自18年8月简书创作平台发的一则公告：</p>
<p><img src="/2020/%E4%B8%BA%E4%BD%95%E9%87%8D%E5%90%AF%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%9F/readme/%E7%AE%80%E4%B9%A6%E5%85%AC%E5%91%8A.png" alt="简书公告"></p>
<p>翻阅《网络安全法》，并没有出现要求绑定“微信”的明文要求，而行业内，“网络运营者”（使用国法里的称法）的常规做法也只是要求用户绑定手机号即可——很明显地，简书这是在假借国法，浑水摸鱼，愚弄用户。</p>
<p>坦白而言，简书是我很喜欢的一个写作平台，它的优秀写作体验，甚至让我做了停止搭建个人博客，专注于写作本身的决定——这在当时的简书个人介绍上可见一斑：</p>
<p><img src="/2020/%E4%B8%BA%E4%BD%95%E9%87%8D%E5%90%AF%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%9F/readme/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D.png" alt="简书个人介绍"></p>
<p>然而，甚是没想到简书对用户如此毫无尊重和敬畏，所以在那之后，决定了迁移到<a href="https://juejin.im/user/569db819816dfa005959d881" target="_blank" rel="noopener">掘金</a>上进行写作。</p>
<p>那，既然已经有另一个平台供写作了，为何还是要重启个人博客呢？</p>
<p>为何“要”呢？</p>
<p>人生来之时是善还是恶，这无法定论。但是，人生来之后，却无法保证自身不作恶。平台是人搭建的，自是平台也无法保证自身不作恶。所以必须重启个人博客，对自己的文章进行备份，以在所寄身的写作平台在作恶之时，有路可退。</p>
]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows与Unix/Linux的区别</title>
    <url>/2020/Windows%E4%B8%8EUnix:Linux%E7%9A%84%E5%8C%BA%E5%88%AB/readme/</url>
    <content><![CDATA[<h2 id="在产品层面，Windows与Unix-Linux的区别"><a href="#在产品层面，Windows与Unix-Linux的区别" class="headerlink" title="在产品层面，Windows与Unix/Linux的区别"></a>在产品层面，Windows与Unix/Linux的区别</h2><p>在产品层面上，Windows与Unix/Linux的区别主要体现在二者服务的对象和应用场景上：</p>
<ul>
<li>Windows系统的服务对象主要是（或者说优先是）个人计算机用户，主要用于为个人计算机用户提供办公（如文档编写、画图）、娱乐（上网浏览、视频播放）、沟通（IM聊天）等服务。</li>
<li>Unix/Linux系统服务对象主要是（或者说优先是）企业用户，主要为企业用户提供计算任务的服务，如网络访问服务、数据生成、数据存储等。</li>
</ul>
<p>在人机关联层面上，，Windows与Unix/Linux的区别主要体现在二者与人和机器的关联程度上：</p>
<ul>
<li>Windows系统更靠近人这一端，其优先考虑人的操作行为，并在系统设计上优先考虑适应人的操作行为，从而为人操作机器时提供良好的短时延服务</li>
<li>Unix/Linux系统更靠近机器这一端，其优先考虑的是多个计算任务的运行，然后在系统设计上优先考虑CPU运行多个计算任务的高效性，从而为客户端提供最大的数据吞吐</li>
</ul>
<p>在桌面系统层面上，Windows是一个桌面系统，Unix/Linux则不是一个桌面系统。</p>
<p><img src="/2020/Windows%E4%B8%8EUnix:Linux%E7%9A%84%E5%8C%BA%E5%88%AB/readme/Linux-VS-Windows.png" alt="Linux-VS-Windows"></p>
<a id="more"></a>

<h2 id="为什么在GUI场景中，Windows比Unix-Linux操作流畅"><a href="#为什么在GUI场景中，Windows比Unix-Linux操作流畅" class="headerlink" title="为什么在GUI场景中，Windows比Unix/Linux操作流畅"></a>为什么在GUI场景中，Windows比Unix/Linux操作流畅</h2><p>产品理念的不同，导致Windows系统和Unix/Linux系统在进行GUI设计和进程调度设计时，采取了不同的设计方案，而方案的不同，导致了在GUI场景下Windows比Unix/Linux操作流畅的结果。</p>
<p>在GUI设计方面：</p>
<ul>
<li>Windows系统：GUI程序是一个系统级别的“应用程序”，其是直接集成在系统层面，属于系统的一部分。</li>
<li>Unix/Linux系统：GUI程序是一个应用层级别的独立的程序。</li>
</ul>
<p>在进程调度设计方面：</p>
<ul>
<li>Windows系统的进程调度设计优先考虑了用户的操作行为，把进程的动态优先级和交互事件做了强关联。</li>
<li>Unix/Linux系统在进程调度设计上，把进程的动态优先级和交互事件做的是弱关联，即交互事件对进程的优先级提高的影响占比很低。</li>
</ul>
<p>简单来说，相比Unix/Linux系统，Windows系统优先响应交互事件。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/dog250/article/details/96362789" target="_blank" rel="noopener external nofollow noreferrer">《为什么Windows/iOS操作很流畅而Linux/Android却很卡顿呢》</a></li>
<li><a href="https://blog.csdn.net/dog250/article/details/96500186" target="_blank" rel="noopener external nofollow noreferrer">《Linux桌面GUI系统的调度器应该怎么做才不卡顿呢？》</a></li>
</ul>
]]></content>
      <categories>
        <category>人文</category>
      </categories>
      <tags>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>当用户第一次点击App（App启动流程）</title>
    <url>/2020/%E5%BD%93%E7%94%A8%E6%88%B7%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%82%B9%E5%87%BBApp%EF%BC%88App%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%89/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当用户第一次点击iPhone手机屏幕上的一个App 图标时，该APP将会被iOS加载启动起来。</p>
<p>下面将会讲述这加载启动背后的相关知识点，比如：</p>
<ul>
<li>App的启动类型</li>
<li>App冷启动的完整过程</li>
<li>App的冷启动优化手段</li>
<li>可执行文件的介绍</li>
</ul>
<p><img src="/2020/%E5%BD%93%E7%94%A8%E6%88%B7%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%82%B9%E5%87%BBApp%EF%BC%88App%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%89/readme/iOS-App-Launch.svg" alt="image"></p>
]]></content>
      <categories>
        <category>知识复盘</category>
      </categories>
      <tags>
        <tag>2020</tag>
        <tag>EveryThingFromTheFirstClick(iOS Version)</tag>
      </tags>
  </entry>
  <entry>
    <title>同步(synchronous)/异步(asynchronous)调用和阻塞(blocking)/非阻塞(non-blocking)调用</title>
    <url>/2020/%E5%90%8C%E6%AD%A5(synchronous):%E5%BC%82%E6%AD%A5(asynchronous)%E8%B0%83%E7%94%A8%E5%92%8C%E9%98%BB%E5%A1%9E(blocking):%E9%9D%9E%E9%98%BB%E5%A1%9E(non-blocking)%E8%B0%83%E7%94%A8/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要介绍同步(synchronous)/异步(asynchronous)调用和阻塞(blocking)/非阻塞(non-blocking)调用的概念以及在现实中会出现的组合场景。</p>
<a id="more"></a>

<h2 id="同步-synchronous-异步-asynchronous-调用"><a href="#同步-synchronous-异步-asynchronous-调用" class="headerlink" title="同步(synchronous)/异步(asynchronous)调用"></a>同步(synchronous)/异步(asynchronous)调用</h2><p>进程/线程在执行过程中，产生一个外部调用，若需要等待该调用返回才能继续往下执行，则称之为同步调用；若不需要等待该调用返回，就可以继续往下执行，则称之为异步调用</p>
<h2 id="阻塞-blocking-非阻塞-non-blocking-调用"><a href="#阻塞-blocking-非阻塞-non-blocking-调用" class="headerlink" title="阻塞(blocking)/非阻塞(non-blocking)调用"></a>阻塞(blocking)/非阻塞(non-blocking)调用</h2><p>进程/线程在执行过程中，产生一个外部调用，若该调用导致当前进程/线程阻塞，则称之为阻塞调用，否则称之为非阻塞调用。</p>
<blockquote>
<p>阻塞：源自操作系统对进程/线程状态的描述概念，其定义为：操作系统把进程/线程从“运行（running）状态”挂起为“阻塞（blocked）状态”（又称“等待（waiting）状态”）。当进程/线程处于阻塞状态，则意味着其处于暂停运行状态，暂时不会被CPU调度执行。</p>
<p>注意：在操作系统领域，“阻塞（blocked）”和“等待（waiting）”的语义相同，但是在其他领域，比如JVM，二者的语义是不一样的。另外，在理解“阻塞”和“非阻塞”时，不能简单地从其字面意思来理解，而是从操作系统对其的基本定义来理解</p>
<p>Q：进程/线程什么时候会发生阻塞？</p>
<p>A：进程/线程主动调用 <code>wait()</code> 或 <code>sleep()</code> 等挂起自己的操作， 或者调用 <code>System Call</code>操作（<code>System Call</code> 因为涉及到了 I/O 操作， 不能立即完成）</p>
<p>PS：此处参考自<a href="https://www.zhihu.com/question/19732473/answer/241673170" target="_blank" rel="noopener external nofollow noreferrer">《怎样理解阻塞非阻塞与同步异步的区别？ - 萧萧的回答》</a></p>
</blockquote>
<h2 id="同步-synchronous-异步-asynchronous-和阻塞-blocking-非阻塞-non-blocking-的组合"><a href="#同步-synchronous-异步-asynchronous-和阻塞-blocking-非阻塞-non-blocking-的组合" class="headerlink" title="同步(synchronous)/异步(asynchronous)和阻塞(blocking)/非阻塞(non-blocking)的组合"></a>同步(synchronous)/异步(asynchronous)和阻塞(blocking)/非阻塞(non-blocking)的组合</h2><p>在进程/线程在执行过程中，产生一个外部调用时，有时候会产生同步(synchronous)/异步(asynchronous)和阻塞(blocking)/非阻塞(non-blocking)的组合场景。</p>
<h3 id="异步进程-线程调用"><a href="#异步进程-线程调用" class="headerlink" title="异步进程/线程调用"></a>异步进程/线程调用</h3><p>常见情况下，当这个外部调用是一个<strong>外部进程/线程调用</strong>时，最容易出现以下组合场景：</p>
<ul>
<li><p>同步阻塞调用：当前进程/线程在等待调用返回，被调用方进程/线程处于阻塞状态</p>
<p>  如在JS中使用<code>async/await</code>机制，调用方同步调用一个读取磁盘文件的异步线程</p>
</li>
</ul>
<ul>
<li><p>同步非阻塞调用：当前进程/线程在等待调用返回，被调用方进程/线程处于非阻塞状态</p>
<p>  如在JS中使用<code>async/await</code>机制，调用方同步调用一个计算哈希值的异步线程</p>
</li>
<li><p>异步阻塞调用：当前进程/线程不等待调用返回，被调用方进程/线程处于阻塞状态</p>
<p>  如调用方异步调用一个读取磁盘文件的异步线程</p>
</li>
<li><p>异步非阻塞调用：当前进程/线程不等待调用返回，被调用方进程/线程处于非阻塞状态</p>
<p>  如调用方异步调用一个发送http请求的异步线程</p>
</li>
</ul>
<h3 id="挂起操作调用和System-Call操作调用"><a href="#挂起操作调用和System-Call操作调用" class="headerlink" title="挂起操作调用和System Call操作调用"></a>挂起操作调用和<code>System Call</code>操作调用</h3><blockquote>
<ul>
<li><p>挂起操作调用：是指会导致当前进程/线程挂起的调用，如<code>wait()</code> 或 <code>sleep()</code></p>
</li>
<li><p><code>System Call</code>操作调用：是指系统级别的调用，如中断类函数</p>
</li>
</ul>
</blockquote>
<p>常见情况下，当这个外部调用是一个<strong>外部进程/线程调用</strong>时，最容易出现以下组合场景：</p>
<ul>
<li><p>同步阻塞调用：当前进程/线程在等待调用返回，并且处于阻塞状态</p>
<p>  如调用方调用<code>sleep(5)</code></p>
</li>
</ul>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul>
<li><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener external nofollow noreferrer">《怎样理解阻塞非阻塞与同步异步的区别？》</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1005527" target="_blank" rel="noopener external nofollow noreferrer">《一种理解同步/异步，阻塞/非阻塞，Linux IO 模型，select /poll /epoll 的方法》</a></li>
<li><a href="https://juejin.im/entry/58ae4636b123db0052b1caf8" target="_blank" rel="noopener">《深入理解并发 / 并行，阻塞 / 非阻塞，同步 / 异步》</a></li>
<li><a href="https://github.com/calidion/calidion.github.io/issues/40" target="_blank" rel="noopener">《同步，异步，阻塞，非阻塞等关系轻松理解》</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>2020</tag>
        <tag>基础理论</tag>
      </tags>
  </entry>
  <entry>
    <title>当用户第一次点击UIView（关于iOS硬件事件的那些事）</title>
    <url>/2020/%E5%BD%93%E7%94%A8%E6%88%B7%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%82%B9%E5%87%BBUIView%EF%BC%88%E5%85%B3%E4%BA%8EiOS%E7%A1%AC%E4%BB%B6%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%89/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当App启动后，用户第一次点击App内的一个视图，这时候将会产生一个点击事件。</p>
<p>下面将会讲述这点击事件背后的相关知识点，比如：</p>
<ul>
<li>点击事件如何从硬件层传递到App</li>
<li>App如何查找到最佳响应者（hit-tested view）</li>
<li>App查找到最佳响应者（hit-tested view）后，如何把点击事件传递给最佳响应者（hit-tested view）</li>
<li>最佳响应者（hit-tested view）作为第一响应者（first responder），如何对事件进行响应和传递？</li>
<li>异常场景的冲突解决<ul>
<li>手势与点击冲突</li>
<li>多个手势冲突</li>
<li>让多个UIView响应同一个点击事件</li>
</ul>
</li>
</ul>
<h2 id="iOS设备事件的类型"><a href="#iOS设备事件的类型" class="headerlink" title="iOS设备事件的类型"></a>iOS设备事件的类型</h2><ul>
<li>Touch Events(触摸事件)</li>
<li>Motion Events(运动事件，比如重力感应和摇一摇等)</li>
<li>Remote Events(远程事件，比如用耳机上得按键来控制手机)</li>
</ul>
<h2 id="可以处理触摸事件的类有哪些"><a href="#可以处理触摸事件的类有哪些" class="headerlink" title="可以处理触摸事件的类有哪些"></a>可以处理触摸事件的类有哪些</h2><ul>
<li>UIResponder的子类（UIApplication，UIWindow，UIViewController和UIView）</li>
<li>UIGestureRecognizer的子类</li>
<li>UIControl的子类（UIButton，UISegmentedControl，UISwitch）</li>
</ul>
<blockquote>
<ul>
<li>UIResponder是iOS中用于处理用户事件的API，可以处理触摸事件、按压事件(3D touch)、远程控制事件、硬件运动事件。 可以通过touchesBegan、pressesBegan、motionBegan、remoteControlReceivedWithEvent等方法，获取到对应的回调消息。UIResponder不只用来接收事件，还可以处理和传递对应的事件，如果当前响应者不能处理，则转发给其他合适的响应者处理。</li>
<li>UIConotrol是UIView（UIResponder）的子类，相比于UIResponder，其增加了target-action的特别设计。</li>
</ul>
</blockquote>
<h2 id="UIConotrol、UIGestureRecognizer、-UIResponder的触摸事件响应优先级排名"><a href="#UIConotrol、UIGestureRecognizer、-UIResponder的触摸事件响应优先级排名" class="headerlink" title="UIConotrol、UIGestureRecognizer、 UIResponder的触摸事件响应优先级排名"></a>UIConotrol、UIGestureRecognizer、 UIResponder的触摸事件响应优先级排名</h2><ul>
<li>UIResponder优先级最低</li>
<li>UIConotrol的优先级大于其父视图上UIGestureRecognizer，小于添加在其自身上的UIGestureRecognizer</li>
</ul>
<h2 id="触摸事件如何从硬件层转发到App"><a href="#触摸事件如何从硬件层转发到App" class="headerlink" title="触摸事件如何从硬件层转发到App"></a>触摸事件如何从硬件层转发到App</h2><ol>
<li><p>触摸发生时，系统内核生成触摸事件，然后交由给IOKit进程</p>
</li>
<li><p>IOKit进程把触摸事件封装成IOHIDEvent对象，通过IPC（mach port）发送给SpringBoard进程。</p>
</li>
<li><p>SpringBoard进程通过IPC（mach port）发送IOHIDEvent对象给当前App进程。</p>
<blockquote>
<p>需要注意的是，若当前前台无App运行，则SpringBoard进程会把该IOHIDEvent对象发送给桌面系统处理。</p>
</blockquote>
</li>
<li><p>App进程的mach port收到IOHIDEvent后，会唤醒主线程的runloop，触发source1回调；source1回调又触发一个source0回调，将接收到的IOHIDEvent对象封装成UIEvent对象，发送给App进程的UIApplication对象处理。</p>
</li>
</ol>
<h2 id="UIApplication收到触摸事件（UIEvent）后的处理流程"><a href="#UIApplication收到触摸事件（UIEvent）后的处理流程" class="headerlink" title="UIApplication收到触摸事件（UIEvent）后的处理流程"></a>UIApplication收到触摸事件（UIEvent）后的处理流程</h2><ol>
<li><p>UIApplication对象通过 <code>hit-tesing</code> 机制查找最佳响应视图（<code>hit-tested view</code>）。</p>
</li>
<li><p>确定触摸事件的第一响应者（first-responder）——一般情况下，最佳响应视图（hit-tested view）将会是触摸事件的第一响应者（first-responder）。</p>
<p> 具体地，根据最佳响应视图（<code>hit-tested view</code>）的类型和既定的UIConotrol、UIGestureRecognizer、 UIResponder的触摸事件响应优先级排名 ，确定第一响应者（first-responder）：</p>
<ul>
<li><p><code>hit-tested view</code>是UIControl类型，<code>hit-tested view</code>自身没有UIGestureRecognizer，则第一响应者是<code>hit-tested view</code></p>
</li>
<li><p><code>hit-tested view</code>是UIControl类型，<code>hit-tested view</code>自身有UIGestureRecognizer，则第一响应者是<code>hit-tested view</code>上的UIGestureRecognizer，第二响应者是<code>hit-tested view</code></p>
</li>
<li><p><code>hit-tested view</code>是UIResponder类型，<code>hit-tested view</code>自身和其后面的响应者视图上都没有UIGestureRecognizer，则第一响应者是<code>hit-tested view</code></p>
</li>
<li><p><code>hit-tested view</code>是UIResponder类型，<code>hit-tested view</code>自身或者和其后面的响应者视图上有UIGestureRecognizer，则第一响应者是<code>hit-tested view</code>上或者和其后面的响应者视图上的UIGestureRecognizer，第二响应者是<code>hit-tested view</code></p>
<blockquote>
<p>在进行<code>hit-tesing</code>过程中，<code>UIEvent</code>会收集这过程发现的<code>UIGestureRecognizer</code>到它的<code>_allTouchesMutable-_gestureRecognizers</code>中</p>
<p><img src="/2020/%E5%BD%93%E7%94%A8%E6%88%B7%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%82%B9%E5%87%BBUIView%EF%BC%88%E5%85%B3%E4%BA%8EiOS%E7%A1%AC%E4%BB%B6%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%89/readme/_allTouchesMutable-_gestureRecognizers.png" alt="image"></p>
</blockquote>
</li>
</ul>
</li>
<li><p>UIApplication对象通过<code>sendEvent:</code>把触摸事件（UIEvent）发送给第一响应者（first-responder）或者最佳响应视图（hit-tested view）；最佳响应视图（hit-tested view）收到事件后会沿着其响应链决策处理该触摸事件（UIEvent）。</p>
<p> 具体地，UIApplication对象将事件通过<code>sendEvent:</code> 传递给事件所属的UIWindow对象，UIWindow对象根据第一响应者的类型，采用不同的逻辑使用 <code>sendEvent:</code>把触摸事件分发给发送给第一响应者（first-responder）或者最佳响应视图（hit-tested view）：</p>
<ul>
<li><p>若第一响应者（first-responder）是最佳响应视图（hit-tested view），则事件直接发送给最佳响应视图（hit-tested view）</p>
</li>
<li><p>若第一响应者（first-responder）UIGestureRecognizer，则最佳响应视图（hit-tested view）是第二响应者，然后事件会先发给UIGestureRecognizer，再发给最佳响应视图（hit-tested view）；UIGestureRecognizer收到事件后，会开始对事件进行识别，识别过程中，事件会继续分发给最佳响应视图（hit-tested view）；当UIGestureRecognizer识别出事件为其对应的手势后会触发<code>target-action</code>调用，并且事件将停止分发给最佳响应视图（hit-tested view）</p>
<blockquote>
<p>手势识别过程中或者识别成功后，可分别通过设置UIGestureRecognizer的<code>delaysTouchesBegan</code>属性和<code>cancelsTouchesInView</code>属性来控制是否分发事件给最佳响应视图（hit-tested view）</p>
</blockquote>
<p><img src="/2020/%E5%BD%93%E7%94%A8%E6%88%B7%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%82%B9%E5%87%BBUIView%EF%BC%88%E5%85%B3%E4%BA%8EiOS%E7%A1%AC%E4%BB%B6%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%89/readme/sendEvent.png" alt="image"></p>
</li>
</ul>
</li>
</ol>
<h2 id="hit-tesing-机制是什么"><a href="#hit-tesing-机制是什么" class="headerlink" title="hit-tesing 机制是什么"></a><code>hit-tesing</code> 机制是什么</h2><p><img src="/2020/%E5%BD%93%E7%94%A8%E6%88%B7%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%82%B9%E5%87%BBUIView%EF%BC%88%E5%85%B3%E4%BA%8EiOS%E7%A1%AC%E4%BB%B6%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%89/readme/hit-tesing.png" alt="image"></p>
<ol>
<li><p>当手指接触屏幕，UIApplication接收到手指的触摸事件之后，就会去调用UIWindow的<code>hitTest: withEvent:</code>方法</p>
<blockquote>
<p>如果存在多个UIWindow，则从KeyWindow开始遍历UIWindow数组</p>
</blockquote>
</li>
<li><p>在<code>hitTest: withEvent:</code>方法中会调用<code>pointInside: withEvent:</code>去判断当前点击的point是否属于UIWindow范围内，如果是，就会以倒序的方式遍历它的子视图，即越后添加的视图，越先遍历</p>
</li>
<li><p>子视图也调用自身的<code>hitTest: withEvent:</code>方法，来查找最佳响应视图，若某个子视图就是最佳响应视图，则返回该子视图；若最终没有任何一个子视图是最佳响应视图，就返回nil</p>
</li>
</ol>
<h2 id="hitTest-withEvent-方法的内部逻辑"><a href="#hitTest-withEvent-方法的内部逻辑" class="headerlink" title="hitTest: withEvent:方法的内部逻辑"></a><code>hitTest: withEvent:</code>方法的内部逻辑</h2><ol>
<li><p>判断当前视图是否满足响应条件：</p>
<ul>
<li>可交互： <code>userInteractionEnabled = YES</code></li>
<li>非隐藏：<code>hidden = NO</code></li>
<li>透明度大于0：<code>alpha &gt; 0.01</code></li>
<li>触摸点的位置在视图范围内：通过<code>pointInside: withEvent:</code>方法判断触摸点是否在视图的坐标范围内</li>
</ul>
</li>
<li><p>若满足响应条件，则倒序遍历其子视图查找最佳响应视图，若存在更何时的子视图，就返回子视图，否则返回自身</p>
</li>
</ol>
<p>具体代码逻辑如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">//3种状态无法响应事件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.isUserInteractionEnabled || <span class="keyword">self</span>.isHidden || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//触摸点若不在当前视图上则无法响应事件</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> pointInside:point withEvent:event]) &#123;</span><br><span class="line">         <span class="comment">//从后往前遍历子视图数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">UIView</span> *subView <span class="keyword">in</span> [<span class="keyword">self</span>.subviews reverseObjectEnumerator]) &#123;</span><br><span class="line">            <span class="comment">// 坐标系的转换,把触摸点在当前视图上坐标转换为在子视图上的坐标</span></span><br><span class="line">            <span class="built_in">CGPoint</span> convertedPoint = [subView convertPoint:point fromView:<span class="keyword">self</span>];</span><br><span class="line">             <span class="comment">//询问子视图层级中的最佳响应视图</span></span><br><span class="line">            <span class="built_in">UIView</span> *hitTestView = [subView hitTest:convertedPoint withEvent:event];</span><br><span class="line">            <span class="keyword">if</span> (hitTestView) &#123;</span><br><span class="line">                 <span class="comment">//如果子视图中有更合适的就返回</span></span><br><span class="line">                <span class="keyword">return</span> hitTestView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//没有在子视图中找到更合适的响应视图，那么自身就是最合适的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应链是什么"><a href="#响应链是什么" class="headerlink" title="响应链是什么"></a>响应链是什么</h2><p>响应链是一个以第一响应者对象为起点，以AppDelegate对象为终点，以响应者对象（UIResponder对象）的<code>nextResponder</code>属性作为连接上一个和下一个响应者对象工具的，一个单向的，响应者对象链条。</p>
<blockquote>
<p>每一个响应者对象（UIResponder对象）都有一个<code>nextResponder</code>属性，用于获取响应链中当前对象的下一个响应者。因此，一旦事件的最佳响应者确定了，这个事件所处的响应链就确定了。</p>
</blockquote>
<h2 id="响应者对象的nextResponder是什么"><a href="#响应者对象的nextResponder是什么" class="headerlink" title="响应者对象的nextResponder是什么"></a>响应者对象的<code>nextResponder</code>是什么</h2><p>不同响应者对象（<code>UIView</code>、<code>UIViewController</code>、<code>UIWindow</code>、<code>UIApplication</code>），其默认的<code>nextResponder</code>实现如下：</p>
<ul>
<li><p>UIView</p>
<p>  若视图是控制器的根视图，则其<code>nextResponder</code>为控制器对象；否则，其<code>nextResponder</code>为父视图。</p>
</li>
<li><p>UIViewController</p>
<p>  若控制器的视图是window的根视图，则其<code>nextResponder</code>为窗口对象；若控制器是从别的控制器present出来的，则其<code>nextResponder</code>为presenting view controller。</p>
</li>
<li><p>UIWindow</p>
<p>  <code>nextResponder</code>为UIApplication对象。</p>
</li>
<li><p>UIApplication</p>
<p>  若当前应用的app delegate是一个UIResponder对象，且不是UIView、UIViewController或app本身，则UIApplication的nextResponder为app delegate。</p>
</li>
</ul>
<p>官网对于响应链的示例展示:</p>
<p><img src="/2020/%E5%BD%93%E7%94%A8%E6%88%B7%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%82%B9%E5%87%BBUIView%EF%BC%88%E5%85%B3%E4%BA%8EiOS%E7%A1%AC%E4%BB%B6%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%89/readme/nextResponder.png" alt="image"></p>
<h2 id="UIResponder类型响应者如何处理触摸事件？"><a href="#UIResponder类型响应者如何处理触摸事件？" class="headerlink" title="UIResponder类型响应者如何处理触摸事件？"></a>UIResponder类型响应者如何处理触摸事件？</h2><p>UIResponder类型响应者对于接收到的事件有3种操作：</p>
<ul>
<li>不拦截，默认操作：事件会自动沿着默认的响应链往下传递</li>
<li>拦截，不再往下分发事件：重写 <code>touchesBegan:withEvent:</code> 进行事件处理，不调用父类的 <code>touchesBegan:withEvent:</code></li>
<li>拦截，继续往下分发事件：重写 <code>touchesBegan:withEvent:</code> 进行事件处理，同时调用父类的 <code>touchesBegan:withEvent:</code> 将事件往下传递</li>
</ul>
<h2 id="UIControl类型响应者如何处理触摸事件？"><a href="#UIControl类型响应者如何处理触摸事件？" class="headerlink" title="UIControl类型响应者如何处理触摸事件？"></a>UIControl类型响应者如何处理触摸事件？</h2><p>UIControl是UIResponder的子类，其内部重写了touch相关的方法，当其收到触摸事件后，会对事件进行识别，若符合响应条件，会触发target-action进行响应：</p>
<p>当UIControl监听到需要处理的交互事件时，会调用<code>sendAction:to:forEvent:</code> 将target、action以及event对象发送给全局应用，Application对象再通过 <code>sendAction:to:from:forEvent:</code> 向target发送action。</p>
<blockquote>
<p>注意：</p>
<p>UIControl对象执行<code>addTarget:action:forControlEvents:</code> 时，若target传空，那么当事件发生时，UIApplication对象从<code>hited-view</code>开始沿着响应链从上往下寻找能响应action的对象。</p>
</blockquote>
<p><img src="/2020/%E5%BD%93%E7%94%A8%E6%88%B7%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%82%B9%E5%87%BBUIView%EF%BC%88%E5%85%B3%E4%BA%8EiOS%E7%A1%AC%E4%BB%B6%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%89/readme/sendAction.png" alt="image"></p>
<h2 id="如何手动控制触摸事件的流向"><a href="#如何手动控制触摸事件的流向" class="headerlink" title="如何手动控制触摸事件的流向"></a>如何手动控制触摸事件的流向</h2><p>一般有2个方案：</p>
<ol>
<li>重写（Override）<code>hit-testing</code>的逻辑，具体地就是重写<code>UIResponder</code>子类的<code>hitTest: withEvent:</code>方法或者<code>pointInside: withEvent:</code>方法，控制返回的最佳响应视图</li>
<li>重写（Override）触摸事件在响应链的传递逻辑，控制触摸事件的分发，具体地就是重写<code>UIResponder</code>子类的<code>touchesBegan:withEvent:</code>方法，根据业务需求增加响应逻辑和调用父类的<code>touchesBegan:withEvent:</code>方法，以控制是否把事件传递给<code>nextResponder</code></li>
</ol>
<blockquote>
<p>题目变形：如何让多个视图响应触摸事件</p>
</blockquote>
<h2 id="如何扩大视图的点击范围"><a href="#如何扩大视图的点击范围" class="headerlink" title="如何扩大视图的点击范围"></a>如何扩大视图的点击范围</h2><p>重载视图的<code>hitTest: withEvent:</code>方法或者<code>pointInside: withEvent:</code>方法</p>
<h2 id="如何让多个手势识别器并存"><a href="#如何让多个手势识别器并存" class="headerlink" title="如何让多个手势识别器并存"></a>如何让多个手势识别器并存</h2><p>重载手势识别器的UIGestureRecognizerDelegate的<code>gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:</code>方法</p>
<blockquote>
<p>题目变形：解决右滑返回手势和UIScrollView中的手势冲突</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://juejin.im/entry/59a7b6e4f265da246f381d37" target="_blank" rel="noopener">《iOS触摸事件全家桶》</a></li>
<li><a href="https://juejin.im/post/5d0e1e236fb9a07ee16931aa" target="_blank" rel="noopener">《iOS事件处理，看我就够了~》</a></li>
<li><a href="https://juejin.im/post/6844903952773808136" target="_blank" rel="noopener">《【iOS面试粮食】UI视图—iOS事件的传递机制》</a></li>
</ul>
]]></content>
      <categories>
        <category>知识复盘</category>
      </categories>
      <tags>
        <tag>2020</tag>
        <tag>EveryThingFromTheFirstClick(iOS Version)</tag>
      </tags>
  </entry>
  <entry>
    <title>当第一张图片加载渲染时（渲染原理+图片解码）</title>
    <url>/2020/%E5%BD%93%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%B8%B2%E6%9F%93%E6%97%B6%EF%BC%88%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86+%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%EF%BC%89/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="UIImage和UIImageView"><a href="#UIImage和UIImageView" class="headerlink" title="UIImage和UIImageView"></a>UIImage和UIImageView</h2><p>UIImage 和 UIImageView 的角色类似于 MVC 架构模式中的数据和视图，如下图所示。</p>
<p><img src="/2020/%E5%BD%93%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%B8%B2%E6%9F%93%E6%97%B6%EF%BC%88%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86+%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%EF%BC%89/readme/UIIamgeView-Model.png" alt="image"></p>
<p>UIImage 是 iOS 中处理图像的高级类。创建一个 UIImage 实例只会加载 Data Buffer，将图像显示到屏幕上才会触发解码，也就是 Data Buffer 解码为 Image Buffer。Image Buffer 也关联在 UIImage 上。</p>
<blockquote>
<ul>
<li><p>Data Buffer 是存储在内存中的原始数据，图像可以使用不同的格式保存，如 jpg、png。Data Buffer 的信息不能用来描述图像的像素信息。</p>
</li>
<li><p>Image Buffer 是图像在内存中的存在方式，其中每个元素描述了一个像素点。Image Buffer 的大小和图像的大小成正比。</p>
</li>
</ul>
</blockquote>
<p>参考资料：</p>
<ul>
<li><a href="https://blog.jamchenjun.com/2018/08/22/image-and-graphics-best-practices.html" target="_blank" rel="noopener external nofollow noreferrer">《iOS 图像解码和最佳实践》</a></li>
</ul>
<h2 id="UIImage解码"><a href="#UIImage解码" class="headerlink" title="UIImage解码"></a>UIImage解码</h2><p>在iOS中，UIImage解码分为2种：</p>
<ul>
<li><p>隐式解码</p>
<p>  将图像显示到屏幕上会触发隐式解码。（必须同时满足图像被设置到 UIImageView 中、UIImageView 添加到视图，才会触发图像解码。)</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:imageView];</span><br><span class="line">[imageView setImage:image];</span><br></pre></td></tr></table></figure>
</li>
<li><p>手动解码</p>
<p>  使用iOS提供的图形框架（UIKit、Core Graphics、Image I/O等）提供的API进行手动解码</p>
</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="https://www.jianshu.com/p/de7b6aede888" target="_blank" rel="noopener external nofollow noreferrer">《iOS的5种图片缩略技术以及性能探讨》</a><h2 id="UIImage优化实践"><a href="#UIImage优化实践" class="headerlink" title="UIImage优化实践"></a>UIImage优化实践</h2></li>
</ul>
<ol>
<li><p>减少内存占用</p>
<p> 当实际显示的图片尺寸小于图片真实大小时，对图片进行向下采样，生成缩略图供UI层使用。</p>
</li>
<li><p>优化 CPU 使用</p>
<p> 建立后台线程，在CPU空闲阶段（监听Runloop状态，进入休眠状态时，主线程变空闲）对图片进行提前解码。</p>
</li>
</ol>
<h2 id="UIView的渲染"><a href="#UIView的渲染" class="headerlink" title="UIView的渲染"></a>UIView的渲染</h2><p>基于Core Animation的视图渲染流水线</p>
<p><img src="/2020/%E5%BD%93%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%B8%B2%E6%9F%93%E6%97%B6%EF%BC%88%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86+%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%EF%BC%89/readme/UIView-Render.png" alt="image"></p>
<ol>
<li><p>Commit Transaction</p>
<ul>
<li><p>Layout（布局）：Set up the views</p>
<p>  执行细节：调用<code>layoutSubviews</code>（若重写了）；创建View和执行<code>addSubview:</code>；填充内容和数据查找；一般会造成CPU和 I/O瓶颈</p>
<p>  可优化手段：简化view的布局和层级；减少使用xib、storyboard等</p>
</li>
<li><p>Display（显示）：Draw the views</p>
<p>  执行细节： 调用 <code>drawRect:</code>（若重写了）；绘制字符串；一般会造成CPU和 内存瓶颈</p>
<p>  可优化手段：减少自定义绘制（<code>drawRect:</code>），或者在自定义绘制中减少字符串、圆角layer等图层绘制</p>
</li>
<li><p>Prepare（准备）：Additional Core Animation work</p>
<p>  执行细节：图片解码；图片格式转换（转换GPU不支持的图片）；一般会造成CPU和 内存瓶颈</p>
<p>  可优化手段：异步线程解码图片；对大图进行向下采样显示；使用GPU支持的图片</p>
</li>
<li><p>Commit（提交）：Package up layers and send them to render server</p>
<p>  执行细节：递归处理Layer-Tree：打包Layer信息并通过IPC发送到Render Server进程；如果图层树太复杂会消耗很大，对性能有很大的影响</p>
<p>  可优化手段：简化图层树（如果图层树太复杂会消耗很大，对性能有很大的影响）</p>
</li>
</ul>
</li>
<li><p>Decode</p>
</li>
<li><p>DrawCalls</p>
</li>
<li><p>Render</p>
</li>
<li><p>Display</p>
</li>
</ol>
<h2 id="Core-Animation-性能优化"><a href="#Core-Animation-性能优化" class="headerlink" title="Core Animation 性能优化"></a>Core Animation 性能优化</h2><ul>
<li><a href="http://zxfcumtcs.github.io/2015/03/21/CoreAnimation/" target="_blank" rel="noopener external nofollow noreferrer">《Core Animation 性能优化》</a></li>
</ul>
<h2 id="Core-Animation执行动画时涉及的图层树类型有几种"><a href="#Core-Animation执行动画时涉及的图层树类型有几种" class="headerlink" title="Core Animation执行动画时涉及的图层树类型有几种"></a>Core Animation执行动画时涉及的图层树类型有几种</h2><p><img src="/2020/%E5%BD%93%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%B8%B2%E6%9F%93%E6%97%B6%EF%BC%88%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86+%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%EF%BC%89/readme/layer-tree.png" alt="image"></p>
<ul>
<li><p>model layer tree (or simply “layer tree”) </p>
<p>  模型层树的对象（<code>modelLayer</code>）用于存放动画的目标值（比如起始值和结束值）。</p>
</li>
<li><p>presentation tree</p>
<p>  表示层树的对象（<code>presentationLayer</code>）用于给上层访问动画过程中的实时值。</p>
</li>
<li><p>render tree</p>
<p>  渲染树的对象（<code>renderLayer</code>）用于存放动画的绘制数据，供图形系统绘制动画使用，对上层屏蔽。</p>
<p>  render tree 在系统的Render Server进程中，是真正处理动画的地方。而且线程的优先级也比我们主线程优先级高。所以有时候即使我们的App主线程busy，依然不会影响到手机屏幕的绘制工作</p>
</li>
</ul>
<blockquote>
<ul>
<li><code>model layer tree</code>其实就是我们口中常说的图层树（<code>layer tree</code>）</li>
<li>通过<code>layer.modelLayer</code>可以获得一个layer对象的<code>model layer object</code>；而事实上<code>layer.modelLayer</code>就是Layer对象本身，即<code>layer == layer.modelLayer</code></li>
<li>通过<code>layer.presentationLayer</code>可以获得一个layer对象的<code>presentation layer object</code>的副本</li>
</ul>
</blockquote>
<h2 id="iOS-渲染框架"><a href="#iOS-渲染框架" class="headerlink" title="iOS 渲染框架"></a>iOS 渲染框架</h2><ul>
<li><p>UIKit Framework</p>
<ul>
<li>正如Apple官方文档对UIKit Framework的介绍，它主要提供了：界面呈现能力、事件响应能力、驱动RunLoop运行和与系统内核通信的数据。简单来说就是：主要负责界面展示、事件响应以及是RunLoop的需求方。UIView当然是属于UIKit Framework。</li>
</ul>
</li>
<li><p>QuartzCore Framework(CoreAnimation)</p>
<ul>
<li>正如Apple官方文档对Quarz Core Framework的介绍，它提供了图形处理和视频图像处理的能力。简单来说就是：QuartzCore Framework负责把图形图像最终显示到屏幕上，这里我觉得应该是特指CoreAnimation。不要从字面上去理解CoreAnimation的职责，因为它的核心工作不单是负责动画的创建和执行，它还负责把我们用代码构建的界面显示到屏幕上，实际上是CoreAnimation通过OpenGLES做的。（别急，虽然这里面的机理很复杂，但是在后面会提到）。CALayer是属于QuarzCore Framework下的CoreAnimation</li>
</ul>
</li>
<li><p>CoreGraphics Framework</p>
<ul>
<li>如Apple官方文档对Core Graphics Framework的介绍。CoreGraphics Framework一个基于C库函数的高级绘画引擎，它提供了非常强大的轻量级2D渲染能力。可以使用CoreGraphics处理基于path的绘图工作(如，CGPath)、变形操作(如，CGAffineTransform)、颜色管理(如，CGColor)、离屏渲染(如，CGBitmapContextCreateImage)、渲染模式(patterns)、渐变(gradients)、阴影效果、图形数据管理、图形创建、蒙版以及PDF文档的创建、显示和解析。 千万别和QuartzCore混淆，CoreGraphics负责创建显示到屏幕上的数据模型，QuartzCore(CoreAnimation –&gt; OpenGLES)负责把CoreGraphics创建的数据模型真正显示到屏幕上。 CG打头的类都是属于CoreGraphics Framework</li>
<li>当开发者需要在 运行时创建图像 时，可以使用 Core Graphics 去绘制。与之相对的是 运行前创建图像，例如用 Photoshop 提前做好图片素材直接导入应用。相比之下，我们更需要 Core Graphics 去在运行时实时计算、绘制一系列图像帧来实现动画。</li>
</ul>
</li>
<li><p>Core Image</p>
<ul>
<li>Core Image 与 Core Graphics 恰恰相反，Core Graphics 用于在 运行时创建图像，而 Core Image 是用来处理 运行前创建的图像 的。Core Image 框架拥有一系列现成的图像过滤器，能对已存在的图像进行高效的处理。</li>
<li>大部分情况下，Core Image 会在 GPU 中完成工作，但如果 GPU 忙，会使用 CPU 进行处理。</li>
</ul>
</li>
<li><p>OpenGL ES</p>
<ul>
<li>OpenGL ES（OpenGL for Embedded Systems，简称 GLES），是 OpenGL 的子集。在前面的 图形渲染原理综述 一文中提到过 OpenGL 是一套第三方标准，函数的内部实现由对应的 GPU 厂商开发实现。</li>
</ul>
</li>
<li><p>Metal</p>
<ul>
<li>Metal 类似于 OpenGL ES，也是一套第三方标准，具体实现由苹果实现。大多数开发者都没有直接使用过 Metal，但其实所有开发者都在间接地使用 Metal。Core Animation、Core Image、SceneKit、SpriteKit 等等渲染框架都是构建于 Metal 之上的。</li>
<li>当在真机上调试 OpenGL 程序时，控制台会打印出启用 Metal 的日志。根据这一点可以猜测，Apple 已经实现了一套机制将 OpenGL 命令无缝桥接到 Metal 上，由 Metal 担任真正于硬件交互的工作。</li>
</ul>
</li>
</ul>
<h2 id="UIKit-Framework、QuartzCore-Framework-CoreAnimation-、CoreGraphics-Framework-三者的关系"><a href="#UIKit-Framework、QuartzCore-Framework-CoreAnimation-、CoreGraphics-Framework-三者的关系" class="headerlink" title="UIKit Framework、QuartzCore Framework(CoreAnimation)、CoreGraphics Framework 三者的关系"></a>UIKit Framework、QuartzCore Framework(CoreAnimation)、CoreGraphics Framework 三者的关系</h2><p><img src="/2020/%E5%BD%93%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%B8%B2%E6%9F%93%E6%97%B6%EF%BC%88%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86+%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%EF%BC%89/readme/UIKit.png" alt="image"></p>
<p>UIKit 建立在 Core Animation 基础之上，在 Core Animation 之下是 OpenGL ES 和 Core Graphics，分别对应 GPU 和 CPU。Core Animation 本身并不做渲染工作，而是将这些工作转交给 Graphics Hardware(GPU)处理。</p>
]]></content>
      <categories>
        <category>知识复盘</category>
      </categories>
      <tags>
        <tag>2020</tag>
        <tag>EveryThingFromTheFirstClick(iOS Version)</tag>
      </tags>
  </entry>
  <entry>
    <title>手Y工程实践之Podfile.lock管理新方案</title>
    <url>/2021/%E6%89%8BY%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8BPodfile.lock%E7%AE%A1%E7%90%86%E6%96%B0%E6%96%B9%E6%A1%88/readme/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在iOS工程接入<code>CocoaPods</code>做依赖管理后，开发者对<code>Podfile.lock</code>的管理主要有以下两种方案：</p>
<ol>
<li>不把<code>Podfile.lock</code>纳入版本管理</li>
<li>把<code>Podfile.lock</code>纳入版本管理</li>
</ol>
<p>这两种方案各有优劣和各有适用场景：</p>
<ol>
<li>第1种方案不强制团队成员使用统一版本的<code>CocoaPods</code>，对团队成员较为友好，但是无法保证团队成员在本地安装的依赖是一致的；其适合个人或者前期对规范不作要求、规模很小的团队</li>
<li>第2种方案能保证团队成员在本地安装的依赖是一致的，但是却要强制团队成员使用统一版本的<code>CocoaPods</code>；其适合对规范有要求的团队</li>
</ol>
<p>在我加入手Y团队之前，手Y团队选用的是第1种方案。基于第1种方案的选择，为了能保证团队成员在本地安装的依赖是一致的，手Y团队又做了以下的解决措施：</p>
<blockquote>
<p>Podfile里的每个库都声明一个具名的固定版本号，如<code>pod &#39;yyabtestsdk&#39;, &#39;2.1.0-dev.2&#39;</code>、<code>pod &#39;yybaseapisdk&#39;, :git=&gt;&#39;https://xxx/yybaseapisdk-ios.git&#39;, :tag =&gt; &#39;7.46.0-dev.8&#39;</code>。</p>
</blockquote>
<p>随着团队的变大（现在iOS业务端已有40+人），这种方案的弊端逐渐暴露：</p>
<ul>
<li><p>无法百分百确保编译运行阶段，团队成员的本地安装的依赖是一致的</p>
<p>这个弊端对应的场景是：有人更新了<code>Podfile</code>，安装了<code>非BreakingChanges</code>的、新版本的依赖库，并进行了代码推送；其他人拉取代码后，若不手动执行一次<code>Pod install/update</code>，其本地安装的依赖是落后的，并且在编译运行阶段，由于代码兼容，若非出现严重bug，其不会发现其本地依赖需要更新。</p>
</li>
<li><p>因本地依赖的版本不正确导致编译失败的时机延迟发生到了编译中后期</p>
<p>这个弊端对应的场景是：有人更新了<code>Podfile</code>，安装了<code>BreakingChanges</code>的、新版本的依赖库，并进行了代码推送；其他人拉取代码后，若不手动执行一次<code>Pod install/update</code>，其本地安装的依赖是落后的，然后其进行编译时，由于代码不兼容，会发现编译失败了——但是这时候编译失败的时机常常是发生在编译中后期——在让开发者至少等待了十几分钟后才抛出编译失败的错误——这相当影响开发者的心情和工作效率。</p>
<blockquote>
<p>对于<code>BreakingChanges</code>的疑问可看下文的《Q&amp;A》</p>
</blockquote>
</li>
</ul>
<p>为了解决这些弊端，有必要考虑重新把<code>Podfile.lock</code>纳入版本管理。那有没有一种方案，能同时获得上述第1种方案和第2种方案的收益呢？具体是，希望有一种方案能满足以下的需求：</p>
<ol>
<li>保证团队成员本地安装的依赖是一致的</li>
<li>允许团队成员不使用统一版本的<code>CocoaPods</code></li>
<li>把因本地依赖的版本不正确导致编译失败的时机从编译中后期提前到编译前，帮助提升开发效率</li>
<li>新方案对当前团队成员是零负担（不强制团队成员做不必要的事、不耗费团队成员不必要的注意力和精力）</li>
</ol>
<p>为此，我制定了一个新的<code>Podfile.lock</code>管理方案，下面将会做具体的介绍。</p>
<a id="more"></a>

<h2 id="手Y工程的Podfile-lock管理新方案"><a href="#手Y工程的Podfile-lock管理新方案" class="headerlink" title="手Y工程的Podfile.lock管理新方案"></a>手Y工程的Podfile.lock管理新方案</h2><p><code>Podfile.lock</code>管理新方案是：使用 Podfile.lock 文件副本 Podfile.lock.dump（相比原件，不记录 CocoaPods 版本信息）代替 Podfile.lock 文件纳入版本管理以保证团队各成员本地安装的依赖是一致的，并修改 CocoaPods 中和 Podfile.lock 文件相关的逻辑，包括 Podfile.lock 文件的读写逻辑和 Manifest.lock 的检测逻辑（Manifest.lock 检测脚本《Xcode Run Script Phase - [CP] Check Pods Manifest.lock》）。相关逻辑的修改借助<code>Ruby</code>强大的<code>Method Swizzling</code>能力实现，整体技术方案如下：</p>
<ol>
<li><p>hook <code>CocoaPods</code> 的读取<code>Podfile.lock</code>信息的方法<code>lockfile</code>（<code>Pod::Config.lockfile</code>），变更逻辑为：从 <code>Podfile.lock.dump</code>读取依赖库信息，从<code>Podfile.lock</code>读取<code>CocoaPods</code>版本信息，以及把<code>Podfile.lock.dump</code>记录的依赖库信同步到<code>Podfile.lock</code>；</p>
</li>
<li><p>hook <code>CocoaPods</code>的创建<code>Podfile.lock</code>的方法<code>write_lockfiles</code>（<code>Pod::Installer.write_lockfiles</code>），将其逻辑变更为：创建<code>Podfile.lock</code>后，再基于<code>Podfile.lock</code>创建一个移除了<code>CocoaPods</code>版本信息的副本<code>Podfile.lock.dump</code>；然后人为把<code>Podfile.lock.dump</code>纳入版本管理</p>
<blockquote>
<p>上述2个操作是为了满足需求1和需求2。对于此举的疑问可看下文的《Q&amp;A》。</p>
</blockquote>
</li>
<li><p>hook <code>CocoaPods</code>的创建<code>Manifest.lock</code>检测脚本的方法<code>add_check_manifest_lock_script_phase</code>（<code>Pod::Installer::UserProjectIntegrator::TargetIntegrator.add_check_manifest_lock_script_phase</code>），将其逻辑变更为：基于本地的<code>Manifest.lock</code>创建副本<code>Manifest.lock.dump</code>，并比较<code>Manifest.lock.dump</code>是否和<code>Podfile.lock.dump</code>一致；若不一致，就使用<code>Podfile.lock.dump</code>更新本地的 <code>Podfile.lock</code>，并抛出错误信息和中断编译</p>
<blockquote>
<p>此举是为了满足需求3。</p>
</blockquote>
</li>
<li><p>在执行<code>pod install/update</code>时，完成上述的hook</p>
</li>
</ol>
<p>为了同时满足需求1和需求2，新方案采取的措施是：基于<code>Podfile.lock</code>生成一个不记录<code>CocoaPods</code>版本信息的副本<code>Podfile.lock.dump</code>，并使用<code>Podfile.lock.dump</code>代替<code>Podfile.lock</code>纳入版本管理。</p>
<p>技术方案实施如下：</p>
<ol>
<li>在工程根目录创建hook <code>CocoaPods</code>的代码<code>PodilePatch_HookPod.rb</code>：</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pod::Lockfile</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Update internal cocoapods version.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update_internal_cocoapods_version</span><span class="params">(version)</span></span></span><br><span class="line">    internal_data[<span class="string">'COCOAPODS'</span>] = version</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pod::Config</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># <span class="doctag">@return</span> [Lockfile] The Local Lockfile to use for the current execution.</span></span><br><span class="line">  <span class="comment"># <span class="doctag">@return</span> [Nil] If no Lockfile is available.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">local_lockfile</span></span></span><br><span class="line">    @local_lockfile <span class="params">||</span>= Pod::Lockfile.from_file(lockfile_path) <span class="keyword">if</span> lockfile_path</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Returns the path of the Lockfile.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># <span class="doctag">@note</span> The Lockfile is named `Podfile.lock.dump`.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">team_lockfile_path</span></span></span><br><span class="line">    @team_lockfile_path <span class="params">||</span>= installation_root + <span class="string">'Podfile.lock.dump'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># <span class="doctag">@return</span> [Lockfile] The Team Lockfile to use for the current execution.</span></span><br><span class="line">  <span class="comment"># <span class="doctag">@return</span> [Nil] If no Lockfile is available.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">team_lockfile</span></span></span><br><span class="line">    @team_lockfile <span class="params">||</span>= Pod::Lockfile.from_file(team_lockfile_path) <span class="keyword">if</span> team_lockfile_path</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># <span class="doctag">@return</span> [bool] If yes The Local Lockfile is did be updated with The Team Lockfile</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:did_update_local_lockfile</span></span><br><span class="line">  did_update_local_lockfile = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 用户拉取代码后，立即执行 pod install，若本地的 Podfile.lock 非最新，这时候会导致安装的依赖是旧的，并且导致 Podfile.lock.dump 也变成旧的</span></span><br><span class="line">  <span class="comment"># 为了解决此问题，针对此种场景，hook Pod::Config.lockfile 方法，在用户执行 pod install/update 时，从 Podfile.lock.dump 读取依赖库信息，从 Podfile.lock 读取 CocoaPods 版本信息，以及把 Podfile.lock.dump 记录的依赖库信同步到 Podfile.lock</span></span><br><span class="line">  <span class="comment"># modify lockfile method</span></span><br><span class="line">  define_method(<span class="symbol">:lockfile</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 使用 Podfile.lock.dump（依赖库信息） 和 Podfile.lock （CocoaPods版本信息）生成 Lockfile</span></span><br><span class="line">    <span class="comment"># 以及同步 Podfile.lock.dump（依赖库信息）到 Podfile.lock</span></span><br><span class="line">    <span class="keyword">if</span> team_lockfile <span class="keyword">and</span> local_lockfile <span class="keyword">and</span> (did_update_local_lockfile == <span class="literal">false</span>)</span><br><span class="line">      puts <span class="string">"read Lockinfo from <span class="subst">#&#123;team_lockfile_path&#125;</span> and <span class="subst">#&#123;lockfile_path&#125;</span>"</span></span><br><span class="line">      <span class="comment"># puts "Generated Lockfile Instances: team_lockfile(#&#123;team_lockfile&#125;) and local_lockfile(#&#123;local_lockfile&#125;)"</span></span><br><span class="line"></span><br><span class="line">      cocoapods_version_str = <span class="string">"<span class="subst">#&#123;local_lockfile.cocoapods_version&#125;</span>"</span></span><br><span class="line">      team_lockfile.update_internal_cocoapods_version(cocoapods_version_str)</span><br><span class="line">      puts <span class="string">"team_lockfile.cocoapods_version: <span class="subst">#&#123;cocoapods_version_str&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">      update_cmd = <span class="string">"cp Podfile.lock.dump Podfile.lock &amp;&amp; echo \"COCOAPODS: <span class="subst">#&#123;cocoapods_version_str&#125;</span>\"&gt;&gt; Podfile.lock"</span></span><br><span class="line">      puts <span class="string">"<span class="subst">#&#123;update_cmd&#125;</span>"</span></span><br><span class="line">      system update_cmd</span><br><span class="line"></span><br><span class="line">      did_update_local_lockfile = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    @lockfile <span class="params">||</span>= team_lockfile</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pod::Installer</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dump_podfile_lock</span><span class="params">()</span></span></span><br><span class="line">    puts <span class="string">"dump Podfile.lock now ..."</span></span><br><span class="line"></span><br><span class="line">    system <span class="string">'cp Podfile.lock Podfile.lock.dump &amp;&amp; sed -i "" "/^COCOAPODS:/"d Podfile.lock.dump'</span></span><br><span class="line">    </span><br><span class="line">    puts <span class="string">"dump Podfile.lock at path(./Podfile.lock.dump) done!!!"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 将来若团队的CocoaPods都升级到v1.10+后，可在新特性 post_integrate hook中执行 dump_podfile_lock</span></span><br><span class="line">  <span class="comment"># modify write_lockfiles method</span></span><br><span class="line">  old_write_lockfiles = instance_method(<span class="symbol">:write_lockfiles</span>)</span><br><span class="line">  define_method(<span class="symbol">:write_lockfiles</span>) <span class="keyword">do</span></span><br><span class="line">    old_write_lockfiles.bind(<span class="keyword">self</span>).()</span><br><span class="line">    dump_podfile_lock()</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">UserProjectIntegrator::TargetIntegrator</span></span></span><br><span class="line">    <span class="comment"># modify add_check_manifest_lock_script_phase method</span></span><br><span class="line">    define_method(<span class="symbol">:add_check_manifest_lock_script_phase</span>) <span class="keyword">do</span></span><br><span class="line">        phase_name = CHECK_MANIFEST_PHASE_NAME</span><br><span class="line">        native_targets.each <span class="keyword">do</span> <span class="params">|native_target|</span></span><br><span class="line">          phase = UserProjectIntegrator::TargetIntegrator.create_or_update_shell_script_build_phase(native_target, BUILD_PHASE_PREFIX + phase_name)</span><br><span class="line">          native_target.build_phases.unshift(phase).uniq! <span class="keyword">unless</span> native_target.build_phases.first == phase</span><br><span class="line">          phase.shell_script = &lt;&lt;-SH.strip_heredoc</span><br><span class="line">            export LANG=en_US.UTF-<span class="number">8</span></span><br><span class="line">            </span><br><span class="line">            Podfile_lock_dump_file=<span class="string">"$&#123;PODS_PODFILE_DIR_PATH&#125;/Podfile.lock.dump"</span></span><br><span class="line">            <span class="keyword">if</span> [ ! -f $&#123;Podfile_lock_dump_file&#125; ]; <span class="keyword">then</span></span><br><span class="line">                echo <span class="string">"$&#123;Podfile_lock_dump_file&#125; not found"</span> &gt;&amp;<span class="number">2</span></span><br><span class="line">                exit <span class="number">0</span></span><br><span class="line">            fi</span><br><span class="line"></span><br><span class="line">            Manifest_lock_dump_file=<span class="string">"$&#123;PODS_ROOT&#125;/Manifest.lock.dump"</span></span><br><span class="line">            cp <span class="string">"$&#123;PODS_ROOT&#125;/Manifest.lock"</span> $&#123;Manifest_lock_dump_file&#125; &amp;&amp; sed -i <span class="string">""</span> <span class="string">"/^COCOAPODS:/"</span>d $&#123;Manifest_lock_dump_file&#125;</span><br><span class="line">            <span class="keyword">if</span> [ ! -f $&#123;Manifest_lock_dump_file&#125; ]; <span class="keyword">then</span></span><br><span class="line">                echo <span class="string">"$&#123;Manifest_lock_dump_file&#125; not found"</span> &gt;&amp;<span class="number">2</span></span><br><span class="line">                exit <span class="number">0</span></span><br><span class="line">            fi</span><br><span class="line"></span><br><span class="line">            diff $&#123;Podfile_lock_dump_file&#125; $&#123;Manifest_lock_dump_file&#125; &gt; <span class="regexp">/dev/null</span></span><br><span class="line">            <span class="keyword">if</span> [ $? != <span class="number">0</span> ] ; <span class="keyword">then</span></span><br><span class="line">                <span class="comment"># 使用 Podfile.lock.dump 覆盖本地的 Podfile.lock</span></span><br><span class="line">                cp $&#123;Podfile_lock_dump_file&#125; <span class="string">"$&#123;PODS_PODFILE_DIR_PATH&#125;/Podfile.lock"</span> &amp;&amp; echo <span class="string">"COCOAPODS: $(pod --version)"</span>&gt;&gt; <span class="string">"$&#123;PODS_PODFILE_DIR_PATH&#125;/Podfile.lock"</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 抛出错误，提醒开发者</span></span><br><span class="line">                echo <span class="string">"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\n(错误: 本地安装的Pod库依赖非最新。请执行 'pod install' 或者更新你的 CocoaPods 版本。)"</span> &gt;&amp;<span class="number">2</span></span><br><span class="line"></span><br><span class="line">                exit <span class="number">1</span></span><br><span class="line">            fi</span><br><span class="line">            <span class="comment"># This output is used by Xcode 'outputs' to avoid re-running this script phase.</span></span><br><span class="line">            echo <span class="string">"SUCCESS"</span> &gt; <span class="string">"$&#123;SCRIPT_OUTPUT_FILE_0&#125;"</span></span><br><span class="line">          SH</span><br><span class="line">          phase.input_paths = <span class="string">%w($&#123;PODS_PODFILE_DIR_PATH&#125;/Podfile.lock $&#123;PODS_ROOT&#125;/Manifest.lock)</span></span><br><span class="line">          phase.output_paths = [target.check_manifest_lock_script_output_file_path]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在工程的<code>Podfile</code>中引入hook的代码：</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hook pod</span></span><br><span class="line">require_relative <span class="string">'PodilePatch_HookPod'</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'Demo'</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">'AFNetworking'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>技术方案实施完毕后，按照业界以往把<code>Podfile.lock</code>纳入版本管理后的方式做工程开发即可：<code>pod install</code> first always。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="何为BreakingChanges版本的依赖库？"><a href="#何为BreakingChanges版本的依赖库？" class="headerlink" title="何为BreakingChanges版本的依赖库？"></a>何为<code>BreakingChanges</code>版本的依赖库？</h3><p><code>BreakingChanges</code>版本的依赖库，其代码是不兼容的，其常见的一个特征就是：API不兼容，比如旧版本的API<code>f(a,b)</code>在新版本变成了<code>f(a,b,c)</code>。</p>
<h3 id="为什么不直接把Podfile-lock纳入版本管理，而是使用其副本Pofile-lock-dump？"><a href="#为什么不直接把Podfile-lock纳入版本管理，而是使用其副本Pofile-lock-dump？" class="headerlink" title="为什么不直接把Podfile.lock纳入版本管理，而是使用其副本Pofile.lock.dump？"></a>为什么不直接把Podfile.lock纳入版本管理，而是使用其副本Pofile.lock.dump？</h3><p><code>Podfile.lock</code>纳入版本管理后，若团队成员安装的<code>CocoaPods</code>版本不一致，那么这个文件会由于记录的<code>CocoaPods</code>版本信息不一致，常常引起版本冲突——这导致团队成员每次更新依赖时都可能要解决一次这种冲突，耗费团队成员不必要的精力。</p>
<p>那是否可以在生成<code>Podfile.lock</code>时，移除<code>CocoaPods</code>版本信息呢？</p>
<p>在表面上，这能满足我们的需求，但是实际上，这样做，会导致在执行<code>pod install</code>时，即使本地的依赖已经是最新的，由于<code>CocoaPods</code>版本信息缺失，<code>CocoaPods</code>都会为重新安装一次所有的依赖，浪费了团队成员的时间。</p>
<h3 id="除了上述方案，是否还有其他管理方案吗？"><a href="#除了上述方案，是否还有其他管理方案吗？" class="headerlink" title="除了上述方案，是否还有其他管理方案吗？"></a>除了上述方案，是否还有其他管理方案吗？</h3><p>答案是肯定的。这里分享另外两种技术方案。</p>
<p>第1种技术方案：使用<a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener external nofollow noreferrer">Git Attributes</a>，自定义<code>smudge</code>和<code>clean</code>子过滤器，让<code>git</code>“忽略”<code>Podfile.lock</code>中记录<code>CocoaPods版本信息</code>的文本行。具体如下：</p>
<ol>
<li><p>工程根目录创建<code>.gitattributes</code>，并添加自定义过滤器执行规则：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "Podfile.lock filter=ignorePodVersion" &gt; .gitattributes</span><br></pre></td></tr></table></figure>
</li>
<li><p>为<code>ignorePodVersion</code>过滤器分别设置<code>smudge</code>和<code>clean</code>子过滤器：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --local filter.ignorePodVersion.smudge 'sed -i "" "/^COCOAPODS:/"d Podfile.lock &amp;&amp; echo "COCOAPODS: $(pod --version)" &gt;&gt; Podfile.lock'</span><br><span class="line"></span><br><span class="line">git config --local filter.ignorePodVersion.clean 'sed -i "" "/^COCOAPODS:/"d Podfile.lock</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p><code>smudge</code>子过滤器会在文件被检出时触发<br><img src="https://git-scm.com/book/en/v2/images/smudge.png" alt=" “smudge”过滤器会在文件被检出时触发"></p>
</li>
<li><p><code>clean</code>子过滤器会在文件被暂存时触发<br>  <img src="https://git-scm.com/book/en/v2/images/clean.png" alt="“clean”过滤器会在文件被暂存时触发"></p>
</li>
</ul>
</blockquote>
</li>
</ol>
<p>但是这种方案，会耗费团队成员不必要的注意力：每次<code>checkout</code>代码时，<code>Podfile.lock</code>都被<code>git</code>标记为<code>modified</code>，团队成员在终端或者SourceTree提交代码时，由于这个变更不是出自团队成员自身操作导致的，团队成员难免疑惑，继而耗费一些注意力和精力去理解这个事情——而这正是我努力去避免给团队成员的负担之一。</p>
<p>第2种技术方案：使用<code>bundler</code>和<code>Gemfile</code>。<code>bundler</code>相当于<code>CocoaPods</code>，<code>Gemfile</code>相当于<code>Podfile</code>，这2个是<code>Ruby</code>开发中用于管理依赖的工具——我们可借助它们帮助统一管理当前项目的<code>Ruby</code>工具链版本，从而满足上述的需求1、2、3。具体实施如下：</p>
<ol>
<li><p>安装<code>bundler</code>，并在工程根目录下创建<code>Gemfile</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gem install bundler</span><br><span class="line">cd path/to/project_root_dir</span><br><span class="line"><span class="meta">#</span><span class="bash"> create Gemfile</span></span><br><span class="line">bundle init</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑<code>Gemfile</code>，并添加项目所需的<code>Ruby</code>工具链版本信息：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frozen_string_literal: true</span></span><br><span class="line"></span><br><span class="line">source <span class="string">"https://rubygems.org"</span></span><br><span class="line"></span><br><span class="line">git_source(<span class="symbol">:github</span>) &#123;<span class="params">|repo_name|</span> <span class="string">"https://github.com/<span class="subst">#&#123;repo_name&#125;</span>"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所需的 Ruby工具链</span></span><br><span class="line">gem <span class="string">'cocoapods'</span>, <span class="string">"1.10.1"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>工程根目录执行<code>sudo bundle install</code>，安装项目所需的<code>Ruby</code>工具链，并按需把生成的<code>Gemfile.lock</code>纳入版本管理</p>
<blockquote>
<p>注意：每次更新了所需的<code>Ruby</code>工具链版本，都需要执行一次<code>sudo bundle install</code></p>
</blockquote>
</li>
<li><p>安装成功后，开发过程中使用<code>bundle exec pod install/update</code>代替<code>pod install/update</code>为工程安装<code>pod</code>依赖</p>
</li>
</ol>
<p>由于需要引入<code>bundler</code>和<code>Gemfile</code>，以及使用<code>bundler exec pod install/update</code>代替<code>pod install/update</code>，这斜在我看来不符合我的需求4，故没有采取此方案。</p>
<blockquote>
<p>注意：一般来说，工具链版本比较稳定，其变更频率远远低于工程代码依赖的版本变化。其他团队在评估引入<code>bundler</code>和<code>Gemfile</code>给团队成员带来的负担时，应根据自己当前团队的情况（比如人数、技术栈等）进行评估。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>教程</tag>
        <tag>2021</tag>
        <tag>工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>手Y开发规范化建设一：Commit Message 规范建设</title>
    <url>/2021/%E6%89%8BY%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%8C%96%E5%BB%BA%E8%AE%BE%E4%B8%80%EF%BC%9ACommit%20Message%20%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%BE/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我于2020年年中加入了手机YY iOS团队，那时发现团队成员在特性阶段所写的<code>Commit Message</code>比较随意；在集成阶段，则比较统一：</p>
<p><img src="/2021/%E6%89%8BY%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%8C%96%E5%BB%BA%E8%AE%BE%E4%B8%80%EF%BC%9ACommit%20Message%20%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%BE/readme/old-commit-msgs.awebp" alt="image.png"></p>
<blockquote>
<p>这里简要介绍一下手Y团队采用的<code>Git</code>分支管理模型和<code>YY GitLab Server</code>端对<code>maint</code>分支实施的<code>Commit Message</code>规范。</p>
<p>手Y团队采用的<code>Git</code>分支管理模型是一种基于主干的分支模型：<code>master-maint-feature</code>，其中：</p>
<ul>
<li><code>master</code>分支是主干分支，用于存放对外发布的版本，永久存在，属于长生命周期</li>
<li><code>maint</code>分支是集成分支，从<code>master</code>分支拉出，用于集成特性和发布版本，存在于集成阶段（在此阶段，团队成员都往该分支提交和只提交修复代码），属于中生命周期（版本发布后，合并回<code>master</code>分支，这之后一般还会存在一段时间）</li>
<li><code>feature</code>分支是特性分支，从<code>master</code>分支拉出，用于开发特性，存在于特性阶段（在此阶段，团队成员都往该分支提交特性代码、修复代码等），属于短生命周期（特性集成之日，合并回<code>master</code>分支，然后被删除）</li>
</ul>
<p><code>YY GitLab Server</code>端对<code>maint</code>分支实施的<code>Commit Message</code>规范是，要求提交格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[bug id &lt;bugId&gt;] &lt;subject&gt; review by [&lt;reviewer&gt;]</span><br></pre></td></tr></table></figure>

</blockquote>
<p>为了使得手Y工程的<code>Commit Message</code>规范变得完整（任意阶段都有规范）和完善，从而帮助团队更好地发展和更好地维护工程，我根据团队实际情况和需求，制定和落地了一套合适手Y的新的<code>Commit Message</code>规范。截止到目前，该规范已经运行快一年，给团队和工程带来了显著的收益：</p>
<ul>
<li>帮助团队成员建立更好的规范意识</li>
<li>帮助团队新成员更好地理解<code>Commit</code>和<code>历史代码</code></li>
<li>帮助团队成员更快地对当前<code>Commit</code>进行<code>Code Review</code></li>
<li>让工程变得更好维护</li>
<li>其他等等</li>
</ul>
<p>新<code>Commit Message</code>规范在经过实践的验收后，作为一个负责的开发团队，我们觉得可以对外分享我们的这个新的<code>Commit Message</code>规范，以及分享我们如何去保障新<code>Commit Message</code>规范的实施。</p>
<a id="more"></a>

<h2 id="新-Commit-Message-规范"><a href="#新-Commit-Message-规范" class="headerlink" title="新 Commit Message 规范"></a>新 Commit Message 规范</h2><p>依据手Y的工作流和既存的<code>Commit Message</code>规范，新的<code>Commit Message</code>规范按照集成时间点前后分为2个版本：</p>
<ul>
<li><code>Feature Commit Message</code>规范：应用于<code>feature</code>分支（比如<code>yymobile_7.41_composite_feature</code>分支），功能特性研发阶段</li>
<li><code>Maint  Commit Message</code>规范：应用于<code>maint</code>分支（比如<code>yymobile_7.41_maint</code>分支），功能特性集成阶段</li>
</ul>
<p>下面将会对这2个版本<code>Commit Message</code>规范进行详细的介绍。</p>
<h3 id="Feature-Commit-Message-规范"><a href="#Feature-Commit-Message-规范" class="headerlink" title="Feature Commit Message 规范"></a>Feature Commit Message 规范</h3><p>在功能特性研发阶段，<code>Commit Message</code>由三部分组成：</p>
<ol>
<li><code>header</code>：必填；由<code>type</code>、<code>scope</code>、<code>subject</code>组成；用于描述<code>Commit</code>的简介内容（类型、来源或影响范围、概要）</li>
<li><code>body</code>：选填；用于描述<code>Commit</code>的细节内容</li>
<li><code>footer</code>：选填；用于描述<code>Commit</code>的补充内容</li>
</ol>
<p>具体格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>备注</strong>：header 中涉及到的括号<code>()</code>和冒号<code>:</code>均使用英文标点符号。</p>
</blockquote>
<p>下面将会对<code>Commit Message</code>中每个组成部分进行详细介绍。</p>
<h4 id="type（必填）"><a href="#type（必填）" class="headerlink" title="type（必填）"></a>type（必填）</h4><p><code>type</code>用于描述<code>Commit</code>的类型，目前可选类型有以下几种：</p>
<ul>
<li><code>feat</code>：新特性开发；业务逻辑修改</li>
<li><code>fix</code>：bug修复</li>
<li><code>refactor</code>: 代码重构（不涉及业务逻辑）</li>
<li><code>test</code>：测试相关的变动（比如新增测试用例）</li>
<li><code>chore</code>：构建工具或者辅助工具升级；源自构建工具或者辅助工具的变动</li>
<li><code>revert</code>：回滚操作</li>
</ul>
<p>开发者需要根据实际场景选择合适的<code>type</code>。</p>
<blockquote>
<p><strong>备注</strong>：每个类型的<code>Commit Message</code>示例请看下面的《Feature Commit Message 规范示例》</p>
</blockquote>
<h4 id="scope（必填）"><a href="#scope（必填）" class="headerlink" title="scope（必填）"></a>scope（必填）</h4><p><code>scope</code>用于描述<code>Commit</code>的来源或者影响范围。<code>scope</code>的描述格式建议为：</p>
<ul>
<li><code>&lt;需求名&gt;</code>：例如<code>【刘露】基础频道二期优化</code>；常用于<code>feat</code>场景</li>
<li><code>&lt;bugId&gt;</code>：例如<code>IOSYY-38403</code>；常用于<code>fix</code>场景 </li>
<li><code>&lt;模块名&gt;-&lt;页面名&gt;</code>：例如<code>关注tab-直播页</code>；常用于<code>feat/fix/refactor</code>场景</li>
<li><code>&lt;工程相关&gt;</code>：例如<code>Fastlane</code>；常用于<code>chore</code>场景</li>
</ul>
<blockquote>
<p><strong>提示</strong>：请根据<code>type</code>和实际场景选择合适的描述格式</p>
</blockquote>
<h4 id="subject（必填）"><a href="#subject（必填）" class="headerlink" title="subject（必填）"></a>subject（必填）</h4><p><code>subject</code>用于描述<code>Commit</code>的概要，具体要求如下：</p>
<ul>
<li>简要准确地描述本次提交的变动，<strong>字符数量不要超过 80</strong></li>
<li><code>type</code>和<code>subject</code>之间以英文冒号<code>:</code>分隔</li>
<li>不以标点结尾</li>
</ul>
<h4 id="body（选填）"><a href="#body（选填）" class="headerlink" title="body（选填）"></a>body（选填）</h4><p><code>subject</code>用于描述<code>Commit</code>的细节内容，具体要求如下：</p>
<ul>
<li>详细有条理地描述本次提交的变动，例如具体的逻辑变更、直接影响的范围、潜在的影响范围等</li>
<li>可写多行，每行不超过72个中文字符，整体建议不要超过200个中文字符</li>
</ul>
<h4 id="footer（选填）"><a href="#footer（选填）" class="headerlink" title="footer（选填）"></a>footer（选填）</h4><p><code>footer</code>用于描述<code>Commit</code>的补充内容，例如关掉的<code>Issue</code>关联的<code>Isuue URL</code>、<code>Report ID</code>、<code>Crash ID</code>等信息，修复的<code>bug</code>关联的<code>Bug ID</code>、<code>Bug URL</code>、<code>备注 URL</code>等信息。</p>
<h3 id="Feature-Commit-Message-规范示例"><a href="#Feature-Commit-Message-规范示例" class="headerlink" title="Feature Commit Message 规范示例"></a>Feature Commit Message 规范示例</h3><h4 id="feat-类日志示例"><a href="#feat-类日志示例" class="headerlink" title="feat 类日志示例"></a>feat 类日志示例</h4><ol>
<li><p>示例一</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">feat(【刘露】基础频道二期优化): 【发现tab-发现页】新增开黑聊天专区入口模块</span><br><span class="line"> </span><br><span class="line">PM：刘露</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例二</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">feat(【刘露】基础频道二期优化): 【发现tab-发现页】修改显示开黑聊天专区入口的逻辑</span><br><span class="line"></span><br><span class="line">命中实验：yy_ios_741_jcpdyh 或者命中实验：yy_ios_741_jcpdyh_entrance 的时候都显示入口</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例三</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">feat(内存监控): MemoryDetector-YY SDK 由 v0.3.6 升级至 v0.3.7</span><br></pre></td></tr></table></figure>
<h4 id="fix-类日志示例"><a href="#fix-类日志示例" class="headerlink" title="fix 类日志示例"></a>fix 类日志示例</h4></li>
<li><p>示例一</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fix(IOSYY-38403): 【猜你喜欢新增标签】进入搜索界面时，猜你喜欢闪动了一下</span><br><span class="line"></span><br><span class="line">问题原因：子模块请求数据队列异步请求数据过程中，YYNewSearchDisplayViewController-viewWillAppear处让【热词】子模块请求数据并刷新TableView，导致部分提前收到数据的子模块（比如【猜你喜欢】子模块）提前渲染出UI来</span><br><span class="line">解决方案：子模块请求数据队列异步请求数据完毕后，YYNewSearchDisplayViewController-viewWillAppear处才允许让【热词】子模块请求数据</span><br><span class="line">影响范围：【搜索预览页】</span><br><span class="line">潜在影响范围：无</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例二</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fix(IOSYY-38411): #41712 问题复现 页面滑动时标签改变，不显示省略号</span><br><span class="line"></span><br><span class="line">问题原因：[label sizeToFit]在一些iOS版本上会破坏label实例的constraints（约束），导致显示异常</span><br><span class="line">解决方案：不要使用sizeToFit；另外，sizeToFit适用于没有使用约束的场景下，其和约束属于两种布局方案，前者是Frame布局，后者是约束布局</span><br><span class="line">影响范围：【关注tab-直播页-猜你喜欢新增标签】【搜索预览页-猜你喜欢模块-猜你喜欢新增标签】</span><br><span class="line">潜在影响范围：无</span><br><span class="line"></span><br><span class="line">更多Bug详情见 IOSYY-38411 下的备注：http://project.sysop.duowan.com/browse/IOSYY-38411?focusedCommentId=710520</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例三</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fix(YYMobileTarget): 修复工程的Signing配置</span><br><span class="line"></span><br><span class="line">发现工程的Signing配置被改为了Auto方式，现在修改为Manual方式</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="refactor-类日志示例"><a href="#refactor-类日志示例" class="headerlink" title="refactor 类日志示例"></a>refactor 类日志示例</h4><ol>
<li><p>示例一</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">refactor(配置中心-直播间): 删除无用配置</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例二</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">refactor(礼物-付费礼物广播): 抽出礼物广播通用 GiftBroadcastModel</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="test-类日志示例"><a href="#test-类日志示例" class="headerlink" title="test 类日志示例"></a>test 类日志示例</h4><ol>
<li><p>示例一</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test(UseCases): 新增使用错误密码登录的测试用例</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="chore-类日志示例"><a href="#chore-类日志示例" class="headerlink" title="chore 类日志示例"></a>chore 类日志示例</h4><ol>
<li><p>示例一</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chore(CocoaPods): cocoapods-binary 由 v0.4.3 升级至 v0.4.4</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例二</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chore(Fastlane): 优化构建脚本</span><br></pre></td></tr></table></figure>
<h4 id="revert-类日志示例"><a href="#revert-类日志示例" class="headerlink" title="revert 类日志示例"></a>revert 类日志示例</h4></li>
<li><p>示例一</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">revert(YYProject): 回滚主工程移除 YYWidgetExtension Target 的操作</span><br><span class="line"> </span><br><span class="line">Revert "fix(YYProject): 暂时从主工程移除 YYWidgetExtension Target，以等待企业证书部署完毕，避免期间 CI 构建失败" </span><br><span class="line"> </span><br><span class="line">This reverts commit 22fd6f31.</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="Maint-Commit-Message-规范"><a href="#Maint-Commit-Message-规范" class="headerlink" title="Maint Commit Message 规范"></a>Maint Commit Message 规范</h3><p>在功能特性集成阶段，<code>Commit Message</code>兼容既定规范（部署在<code>YY GitLab Server</code>端对<code>maint</code>分支实施的<code>Commit Message</code>规范），其由三部分组成：</p>
<ol>
<li><code>header</code>：必填；由<code>bugId</code>、<code>subject</code>、<code>reviewer</code>组成；用于描述<code>Commit</code>的简介内容（类型、影响范围、概要）</li>
<li><code>body</code>：选填；用于描述<code>Commit</code>的细节内容</li>
<li><code>footer</code>：选填；用于描述<code>Commit</code>的补充内容</li>
</ol>
<blockquote>
<p>手Y团队规定，集成测试期间，原则上只修复Bug，禁止提交优化、重构功能。</p>
</blockquote>
<p>具体格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[bug id &lt;bugId&gt;] &lt;subject&gt; review by [&lt;reviewer&gt;]</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>bugId</code>：必填；用于描述<code>Commit</code>关联的 Bug ID</li>
<li><code>subject</code>：必填；用于描述 Bug 的原因概要；<strong>字符数量不要超过 80</strong></li>
<li><code>reviewer</code>：必填；用于描述帮你 Code Review 的同事的邮箱用户名</li>
<li><code>body</code>：选填；定义和要求与《Feature Commit Message 规范》中的保持一致</li>
<li><code>footer</code>：选填；定义和要求与《Feature Commit Message 规范》中的保持一致</li>
</ul>
<h3 id="Maint-Commit-Message-规范示例"><a href="#Maint-Commit-Message-规范示例" class="headerlink" title="Maint Commit Message 规范示例"></a>Maint Commit Message 规范示例</h3><ol>
<li><p>示例一</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[bug id IOSYY-38898] 14系统手机热搜榜页面不显示顶部banner图片 review by [chenzhiying]</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例二</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[bug id IOSYY-32551] 【崩溃系统提单_首报7.24.0-develop】 review by [chenjianfeng3] </span><br><span class="line">  </span><br><span class="line">This reverts commit e4fe6fb1.</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="新-Commit-Message-规范实施和保障"><a href="#新-Commit-Message-规范实施和保障" class="headerlink" title="新 Commit Message 规范实施和保障"></a>新 Commit Message 规范实施和保障</h2><p>新的<code>Commit Message</code>规范制定后，为了检验和保障实施的的效果，我们决定先在手Y工程上实施：通过以点带面，逐步帮助手Y团队成员建立<code>Commit Message</code>规范规范意识。</p>
<p>为了保障实施的的效果，我同步研发了配套工具<code>YYCommitMessageLint</code>。为了保障实施落地时阻力达到最小，<code>YYCommitMessageLint</code>建立了一个目标：不对除手Y工程之外的项目造成约束影响，以及最大限度地方便手Y团队成员方便安装该工具。</p>
<p>为了达到上述目标，<code>YYCommitMessageLint</code>设计成了一个<code>Pod</code>库，通过<code>CocoaPods</code>接入到手Y工程项目中。下图是<code>YYCommitMessageLint</code>接入iOS项目的流程图：</p>
<p><img src="/2021/%E6%89%8BY%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%8C%96%E5%BB%BA%E8%AE%BE%E4%B8%80%EF%BC%9ACommit%20Message%20%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%BE/readme/YYCommitMessageLint%E6%8E%A5%E5%85%A5iOS%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E5%9B%BE.awebp" alt="YYCommitMessageLint接入iOS项目流程图.png"></p>
<p><code>YYCommitMessageLint</code>接入iOS项目的具体步骤如下：</p>
<ol>
<li><p>编辑<code>Podfile</code>，添加<code>YYCommitMessageLint</code>的依赖声明代码</p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"> <span class="comment">## 这是一个虚拟target，专门用于安装通过CocoaPods方式接入工程的构建工具、辅助工具</span></span><br><span class="line">abstract_target <span class="string">'YYChoreBox'</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">'YYCommitMessageLint'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑<code>Podfile</code>，添加同步<code>YYCommitMessageLint</code>的函数定义</p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">syncCommitMessageLint</span><span class="params">()</span></span></span><br><span class="line">  src_root = Dir.pwd</span><br><span class="line">  pods_root = <span class="string">"<span class="subst">#&#123;src_root&#125;</span>/Pods"</span></span><br><span class="line">  lint_dir = <span class="string">"<span class="subst">#&#123;pods_root&#125;</span>/YYCommitMessageLint"</span></span><br><span class="line">  <span class="keyword">if</span> Dir.exists?(lint_dir)</span><br><span class="line">    cmd = <span class="string">"cd <span class="subst">#&#123;lint_dir&#125;</span>/tools/ &amp;&amp; sh <span class="subst">#&#123;lint_dir&#125;</span>/tools/setup_single.sh <span class="subst">#&#123;src_root&#125;</span>"</span></span><br><span class="line">    system(cmd)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑<code>Podfile</code>，在<code>Pod</code>的<code>pre_install</code>回调函数中执行<code>syncCommitMessageLint</code></p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pre_install <span class="keyword">do</span> <span class="params">|installer|</span></span><br><span class="line">   syncCommitMessageLint()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="YYCommitMessageLint的局限性"><a href="#YYCommitMessageLint的局限性" class="headerlink" title="YYCommitMessageLint的局限性"></a><code>YYCommitMessageLint</code>的局限性</h3><p><code>YYCommitMessageLint</code>适合应用于单个工程场景——这是它的优点也是它的缺点。因此，若你期望它的作用范围由“点”扩展到“面”时，就需要另外的改造方案了——今年开春以来，手Y开始着手业务组件化，我们希望那些业务组件工程也被纳入新<code>Commit Message</code>规范的约束范围内（事实上除了<code>Commit Message</code>规范，还新增了其他规范），为此，我开始设计实现了新的方案——这个方案将会在下一期进行分享，敬请期待。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>教程</tag>
        <tag>2021</tag>
        <tag>工程实践</tag>
      </tags>
  </entry>
  <entry>
    <title>手Y开发规范化建设二：手Y业务工程规范建设</title>
    <url>/2021/%E6%89%8BY%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%8C%96%E5%BB%BA%E8%AE%BE%E4%BA%8C%EF%BC%9A%E6%89%8BY%E4%B8%9A%E5%8A%A1%E5%B7%A5%E7%A8%8B%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%BE/readme/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章既是对上篇<a href="https://juejin.cn/post/6980910026151952391" target="_blank" rel="noopener external nofollow noreferrer">《手Y开发规范化建设一：Commit Message 规范建设》</a>在文章结尾抛出的问题的解答，也是对外分享已经在手Y业务团队落地实施5个月（自2021年8月初开始）了的《手Y业务工程规范》的建设经验。</p>
<h2 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h2><p>截止到目前，手Y业务组件数量已经达到30+。伴随着业务的进一步复杂化，团队中出现了不少有碍代码质量、影响效率的问题，比如：</p>
<ul>
<li>部分手Y业务组件随便引入体积超标图片资源，引起手Y和联运SDK体积劣化</li>
<li>部分已做二进制化的手Y业务组件不正确设置代码文件的<code>Target Membership</code>，导致构建的二进制产物丢失头文件或者符号，阻塞了手Y的正常开发和构建</li>
<li>部分手Y业务组件不规范使用<code>API</code>，导致手Y运行时异常</li>
<li>手Y业务组件提交的 commit 日志格式各异</li>
</ul>
<p>为进一步提升手Y的代码质量，提高团队的协作开发效率，我制定了《手Y业务工程规范》来引导团队成员规范开发。</p>
<a id="more"></a>

<h2 id="手Y业务工程规范简介"><a href="#手Y业务工程规范简介" class="headerlink" title="手Y业务工程规范简介"></a>手Y业务工程规范简介</h2><p>《手Y业务工程规范》是由一系列的满足业务和团队特定需要的规则组成。截止到目前，《手Y业务工程规范》包含了以下规则：</p>
<ul>
<li>no_fat_resource_files</li>
<li>no_unreferenced_code_files</li>
<li>no_conflicting_files</li>
<li>yy_commit_msg_convention</li>
<li>yy_assert_api_first</li>
<li>yy_color_api_first</li>
<li>yy_http_api_first</li>
<li>yy_userdefaults_api_first</li>
<li>yy_dispatch_task_block_api_first</li>
</ul>
<blockquote>
<p>后面随着团队和业务的需要，规则会有增删改。</p>
</blockquote>
<p>下面将会对以上规则进行一一介绍，分享这些规则的承载目的和内容。</p>
<h3 id="no-fat-resource-files"><a href="#no-fat-resource-files" class="headerlink" title="no_fat_resource_files"></a>no_fat_resource_files</h3><ul>
<li>规则目的：限制工程随意引入体积超标的资源文件，防止手Y和联运SDK体积劣化</li>
<li>规则简介：工程引入的图片的体积不能超过4kb（直播间业务工程引入的图片体积不能超过2.5kb）</li>
</ul>
<blockquote>
<p>该规则规定了工程引入的图片体积不能超过4kb，而由于百度App对联运SDK体积有更严苛的要求，该规则要求直播间业务工程引入的图片体积不能超过2.5kb。随着业务的变化，未来这2个数字有可能是会变化的。</p>
</blockquote>
<h3 id="no-unreferenced-code-files"><a href="#no-unreferenced-code-files" class="headerlink" title="no_unreferenced_code_files"></a>no_unreferenced_code_files</h3><ul>
<li>规则目的：防止残留无用代码文件，以及预防业务组件工程的二进制产物缺失头文件或者符号，阻塞手Y的正常开发和构建</li>
<li>规则简介：工程目录中的代码文件（包括有：头文件、实现文件、库文件、xib文件、storyboard文件）需要保证设置了有效的<code>Target Membership</code></li>
</ul>
<blockquote>
<p>在手Y业务团队中，导致【业务组件工程的二进制产物缺失头文件或者符号】问题产生的原因是：<br>每个业务组件工程在实施二进制化后，都有单独的二进制产物构建工程；而大多数同学在做业务组件开发时，都是使用<code>Development Pods</code>方式接入到手Y宿主工程进行开发，在开发过程中新增的代码文件都没有同步回二进制产物构建工程，从而导致了业务组件二进制产物缺失头文件或者符号的问题。</p>
<p>那么对这个问题的解决，除了是选择在提交代码时，做<code>no_unreferenced_code_files</code>规则的检测，还有其他代替方案吗？</p>
<p>答案是：有的。这个代替方案就是做【去工程化】。所谓的【去工程化】，就是基于项目的文件夹结构，使用工程自述文件（<code>project spec file</code>）生成 Xcode 工程文件：</p>
<p><img src="/2021/%E6%89%8BY%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%8C%96%E5%BB%BA%E8%AE%BE%E4%BA%8C%EF%BC%9A%E6%89%8BY%E4%B8%9A%E5%8A%A1%E5%B7%A5%E7%A8%8B%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%BE/readme/%E5%8E%BB%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%96.webp" alt="去工程文件化"></p>
<blockquote>
<p>目前业内提供实现【去工程化】的工具有：</p>
<ul>
<li><a href="https://github.com/yonaskolb/XcodeGen" target="_blank" rel="noopener">XcodeGen</a></li>
<li><a href="https://github.com/lyptt/struct" target="_blank" rel="noopener">struct</a></li>
</ul>
</blockquote>
<p>基于这个方案，我们可以选择在构建二进制产物时，根据工程自述文件生成等价于开发时用到的 <code>Development Pods</code>工程，从而解决掉上述问题。目前手Y已经在部分业务组件上实施该方案。</p>
</blockquote>
<h3 id="no-conflicting-files"><a href="#no-conflicting-files" class="headerlink" title="no_conflicting_files"></a>no_conflicting_files</h3><ul>
<li>规则目的：防止没解决<code>merge conflicts</code>（合并冲突）的文件阻塞他人的开发</li>
<li>规则简介：开发者不能提交存在<code>merge conflicts</code>（合并冲突）的文件到工程仓库中</li>
</ul>
<h3 id="yy-commit-msg-convention"><a href="#yy-commit-msg-convention" class="headerlink" title="yy_commit_msg_convention"></a>yy_commit_msg_convention</h3><ul>
<li><p>规则目的：统一手Y和手Y业务组件的 Commit 日志规范</p>
</li>
<li><p>规则简介：开发者提交的 Commit 日志需要满足<a href="https://juejin.cn/post/6980910026151952391#heading-1" target="_blank" rel="noopener external nofollow noreferrer">《YY Commit 日志规范》</a></p>
<p>  <img src="/2021/%E6%89%8BY%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%8C%96%E5%BB%BA%E8%AE%BE%E4%BA%8C%EF%BC%9A%E6%89%8BY%E4%B8%9A%E5%8A%A1%E5%B7%A5%E7%A8%8B%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%BE/readme/yy-commit-msg-convention.webp" alt="image.png"></p>
</li>
</ul>
<h3 id="yy-assert-api-first"><a href="#yy-assert-api-first" class="headerlink" title="yy_assert_api_first"></a>yy_assert_api_first</h3><ul>
<li><p>规则目的：规范API使用，优先使用业务定制的<code>YY API</code>代替<code>System API</code>；以及让业务组件的二进制包在宿主的<code>debug</code>环境下可运行<code>Assert</code>代码</p>
</li>
<li><p>规则简介：工程若依赖了<code>YYAppEnvironment</code>，则该工程的代码应优先使用<code>YYAppAssert API</code>而不是 <code>NSAssert API</code>，比如：</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad case</span></span><br><span class="line"><span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@"unimplemented enum value"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;YYAppEnvironment/YYAppEnvironment.h&gt;</span></span></span><br><span class="line">YYAppAssert(<span class="literal">NO</span>, <span class="string">@"unimplemented enum value"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于规则目的提及的第2点：让业务组件的二进制包在宿主的<code>debug</code>环境下可运行<code>Assert</code>代码，这里补充一下知识点。目前业务组件的二进制包都是<code>release</code>编译，<code>release</code>编译时，业务组件中<code>NSAssert</code>代码会被编译器清理掉，这会导致业务组件的二进制包在宿主的<code>debug</code>环境下运行会失效，达不到开发者调试的目的。</p>
<p>为此我们的一个解决方案是： 业务组件使用<code>YYAppAssert API</code>代替<code>NSAssert API</code>，然后宿主接入<code>YYAppAssert</code>源码编译，然后业务组件的<code>Assert</code>代码可以和以前一样，宿主运行环境是<code>debug</code>环境时，<code>Assert</code>代码生效；宿主环境是<code>release</code>环境时，<code>Assert</code>代码不生效。</p>
</blockquote>
</li>
</ul>
<h3 id="yy-color-api-first"><a href="#yy-color-api-first" class="headerlink" title="yy_color_api_first"></a>yy_color_api_first</h3><ul>
<li><p>规则目的：规范API使用，优先使用业务定制的<code>YY API</code>代替<code>System API</code>；以及反向推动设计同事优先使用视觉规范上的色表颜色</p>
</li>
<li><p>规则简介：工程若依赖了<code>yybaseapisdk</code>，则该工程的代码应优先使用<code>YYColor API</code>而不是<code>UIColor API</code>，比如：</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad case</span></span><br><span class="line"><span class="built_in">UIColor</span> *bgColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line"></span><br><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;yybaseapisdk/YYColor.h&gt;</span></span></span><br><span class="line"><span class="built_in">UIColor</span> *bgColor = [YYColor B0Color];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="yy-http-api-first"><a href="#yy-http-api-first" class="headerlink" title="yy_http_api_first"></a>yy_http_api_first</h3><ul>
<li><p>规则目的：规范API使用，优先使用业务定制的<code>YY API</code>代替<code>System API</code></p>
</li>
<li><p>规则简介：工程若依赖了<code>yybaseapisdk</code>，则该工程的代码应优先使用<code>YYNetClient API</code>而不是 <code>NSURLSession/NSURLConnection API</code>，比如：</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad case</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br><span class="line"><span class="built_in">NSURL</span> *imgUrl = [<span class="built_in">NSURL</span> URLWithString:urlStr];</span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithURL:imgUrl completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;];</span><br><span class="line">[task resume];</span><br><span class="line"></span><br><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;yybaseapisdk/YYNetClient.h&gt;</span></span></span><br><span class="line">YYJumpLiveWinRecmdInfoRequest *request = [YYJumpLiveWinRecmdInfoRequest new];</span><br><span class="line">[YYNetClient sendUrl:urlStr</span><br><span class="line">              method:YYHttpRequestMethodGET</span><br><span class="line">             request:request</span><br><span class="line">       responseClass:YYJumpLiveWinRecmdInfoResponse.class</span><br><span class="line">          onFinished:responseBlock];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="yy-userdefaults-api-first"><a href="#yy-userdefaults-api-first" class="headerlink" title="yy_userdefaults_api_first"></a>yy_userdefaults_api_first</h3><ul>
<li><p>规则目的：规范API使用，优先使用业务定制的<code>YY API</code>代替<code>System API</code></p>
</li>
<li><p>规则简介：工程若依赖了<code>yybaseapisdk</code>，则该工程的代码应优先使用<code>YYUserDefaults API</code>而不是 <code>NSUserDefaults API</code>，比如：</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad case</span></span><br><span class="line"><span class="keyword">id</span> hiddenObj = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:key];</span><br><span class="line"><span class="built_in">BOOL</span> hidden = (hiddenObj != <span class="literal">nil</span>) ? [hiddenObj boolValue] : <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;yybaseapisdk/YYUserDefaults.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;yybaseapisdk/YYUserDefaultsDefine.h&gt;</span></span></span><br><span class="line"><span class="built_in">BOOL</span> hidden = [YYUserDefaults yy_boolForKey:key forModule:module];</span><br></pre></td></tr></table></figure>
<h3 id="yy-dispatch-task-block-api-first"><a href="#yy-dispatch-task-block-api-first" class="headerlink" title="yy_dispatch_task_block_api_first"></a>yy_dispatch_task_block_api_first</h3></li>
<li><p>规则目的：规范API使用，优先使用业务定制的<code>YY API</code>代替<code>System API</code></p>
</li>
<li><p>规则简介：工程若依赖了<code>yybaseapisdk</code>，则该工程的代码应优先使用<code>YY Dispatch Task Block API</code>（<code>dispatch_yy_sync</code>/<code>dispatch_yy_async</code>/<code>dispatch_sys_sync</code>/<code>dispatch_sys_async</code>） 而不是<code>System Dispatch Task Block API</code>（<code>dispatch_sync</code>/<code>dispatch_async</code>），比如：</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad case</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good case</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;yybaseapisdk/YYDispatchQueue.h&gt;</span></span></span><br><span class="line">dispatch_yy_async(dispatch_get_yy_main_queue(), ^&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="保障《手Y业务工程规范》实施的技术方案"><a href="#保障《手Y业务工程规范》实施的技术方案" class="headerlink" title="保障《手Y业务工程规范》实施的技术方案"></a>保障《手Y业务工程规范》实施的技术方案</h2><p>为保证《手Y业务工程规范》的实施，我们研发了配套的保障工具：<code>yy-commit-linter</code>：</p>
<ol>
<li><code>yy-commit-linter</code>是一个基于<code>Ruby</code>开发的<code>gem</code>包</li>
<li>为了实现<code>yy-commit-linter</code>的自动安装和升级，我们把<code>yy-commit-linter</code>包装成一个<code>Pod</code>库</li>
<li>然后在手Y主工程安装<code>Pod</code>库时，安装<code>yy-commit-linter CLI</code>到开发者的电脑，并设置<code>git global hooks</code>指向<code>yy-commit-linter git-hooks</code></li>
<li><code>yy-commit-linter git-hooks</code> 承载了《手Y业务工程规范》的每项检测，当开发者在手Y业务工程完成开发提交代码时，<code>yy-commit-linter git-hooks</code> 就会被触发，然后会对提交的内容进行检测，确保开发者遵守了制定的规范</li>
</ol>
<p><img src="/2021/%E6%89%8BY%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%8C%96%E5%BB%BA%E8%AE%BE%E4%BA%8C%EF%BC%9A%E6%89%8BY%E4%B8%9A%E5%8A%A1%E5%B7%A5%E7%A8%8B%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%BE/readme/yy-commit-linter%E6%8E%A5%E5%85%A5iOS%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88.webp" alt="image.png"></p>
<h2 id="手Y业务工程规范FAQ"><a href="#手Y业务工程规范FAQ" class="headerlink" title="手Y业务工程规范FAQ"></a>手Y业务工程规范FAQ</h2><h3 id="对于暂不需要做二进制化的业务组件工程，如何临时跳过no-unreferenced-code-files规则的检测？"><a href="#对于暂不需要做二进制化的业务组件工程，如何临时跳过no-unreferenced-code-files规则的检测？" class="headerlink" title="对于暂不需要做二进制化的业务组件工程，如何临时跳过no_unreferenced_code_files规则的检测？"></a>对于暂不需要做二进制化的业务组件工程，如何临时跳过<code>no_unreferenced_code_files</code>规则的检测？</h3><p>针对这种场景，<code>yy-commit-linter</code>为<code>no_unreferenced_code_files</code>规则设计和实现了名为【白名单凭证（<code>white_passport</code>）】的白名单机制：若业务组件工程存在白名单凭证文件，即可不受<code>no_unreferenced_code_files</code>规则的约束。</p>
<p>添加白名单凭证文件步骤如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入业务工程根目录</span></span><br><span class="line">cd path/to/yyxxxcomponent-ios</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为当前业务工程添加白名单凭证（white_passport）</span></span><br><span class="line">yy-commit-linter white_passport</span><br></pre></td></tr></table></figure>

<h3 id="图片资源体积超标但是又必须放置在本地时，这时候该如何跳过no-fat-resource-files规则的检测？"><a href="#图片资源体积超标但是又必须放置在本地时，这时候该如何跳过no-fat-resource-files规则的检测？" class="headerlink" title="图片资源体积超标但是又必须放置在本地时，这时候该如何跳过no_fat_resource_files规则的检测？"></a>图片资源体积超标但是又必须放置在本地时，这时候该如何跳过<code>no_fat_resource_files</code>规则的检测？</h3><p>针对这种场景，<code>yy-commit-linter</code>为<code>no_fat_resource_files</code>规则设计和实现了名为【白名单口令（<code>white_passphrase</code>）】的白名单机制：若违规的图片资源存在合法的白名单口令，则可不受<code>no_fat_resource_files</code>规则的约束。</p>
<p>为违规的图片资源添加合法的白名单口令的示例流程如下：</p>
<ol>
<li>向违规的图片资源向<code>yy-commit-linter</code>的持有人申请获得专属白名单口令</li>
<li>在工程根目录下为违规的图片资源添加专属白名单口令，示例如下： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入业务工程根目录</span></span><br><span class="line">cd path/to/yyxxxcomponent-ios</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为违规的图片资源文件添加分配给它的白名单口令（white_passphrase） xxx1（若你有多个，则执行多次该指令）</span></span><br><span class="line">yy-commit-linter white_passphrase --passphrase xxx1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为下一个违规的图片资源文件添加分配给它的白名单口令（white_passphrase）xxx2</span></span><br><span class="line">yy-commit-linter white_passphrase --passphrase xxx2</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="一些特殊场景下，必须使用System-API，这时候该如何跳过yy-api-first系列规则的检测？"><a href="#一些特殊场景下，必须使用System-API，这时候该如何跳过yy-api-first系列规则的检测？" class="headerlink" title="一些特殊场景下，必须使用System API，这时候该如何跳过yy_api_first系列规则的检测？"></a>一些特殊场景下，必须使用<code>System API</code>，这时候该如何跳过<code>yy_api_first</code>系列规则的检测？</h3><p>针对这种场景，<code>yy-commit-linter</code>为<code>yy_api_first</code>系列规则设计和实现了名为【白名单标签（<code>white_label</code>】的白名单机制：若违规的代码存在一个白名单标签，则可不受对应的<code>yy_api_first</code>规则的约束。</p>
<p>【白名单标签（<code>white_label</code>】形式上是一个 <code>ignore_yy_api_first</code>注释标签。</p>
<p>添加白名单标签示例如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [[<span class="built_in">NSUserDefaults</span> alloc] initWithSuiteName:groundIdentifier]; <span class="comment">//ignore_yy_api_first</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [[<span class="built_in">NSUserDefaults</span> alloc] initWithSuiteName:groundIdentifier]; <span class="comment">/* ignore_yy_api_first */</span></span><br></pre></td></tr></table></figure>

<h3 id="如果需要临时停用yy-commit-linter检测功能，应该如何处理"><a href="#如果需要临时停用yy-commit-linter检测功能，应该如何处理" class="headerlink" title="如果需要临时停用yy-commit-linter检测功能，应该如何处理?"></a>如果需要临时停用<code>yy-commit-linter</code>检测功能，应该如何处理?</h3><p>针对这种场景，<code>yy-commit-linter</code>为提供了<code>uninstall</code>功能，但是为了防止用户滥用，设计了<code>uninstall</code>口令：执行<code>uninstall</code>前，需要先向<code>yy-commit-linter</code>的持有人申请一个口令，然后执行<code>uninstall</code>时，输入该口令才能成功<code>uninstall</code>。</p>
<p>执行<code>uninstall</code>的示例如下：</p>
<p><img src="/2021/%E6%89%8BY%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%8C%96%E5%BB%BA%E8%AE%BE%E4%BA%8C%EF%BC%9A%E6%89%8BY%E4%B8%9A%E5%8A%A1%E5%B7%A5%E7%A8%8B%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%BE/readme/%E4%B8%B4%E6%97%B6%E5%81%9C%E7%94%A8yy-commit-linter.webp" alt="image.png"></p>
<blockquote>
<p>需要注意的是，<code>uninstall</code>口令具有定向性（只对申请人生效）和时效性（只在当天有效）。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>教程</tag>
        <tag>2021</tag>
        <tag>工程实践</tag>
      </tags>
  </entry>
</search>
